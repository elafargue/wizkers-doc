{
    "docs": [
        {
            "location": "/", 
            "text": "Wizkers documentation\n\n\nWizkers is a universal open source application for both data visualization and control of various kinds of scientific instruments. It is a full Javascript/HTML5 application which runs on nearly any computer, phone or tablet.\n\n\nIt can also run as a standalone server application, on any Linux platform, from a simple Raspberry Pi or Beaglebone black, all the way to cloud-hosted AWS instances, which gives it tremendous flexibility. Basically, it is a real open source simple 'cloud' system  and one of the only 'cloud' projects out there with a fully open source (GNU Affero General Public License) front-end \nand\n backend.\n\n\nOut of the box, Wizkers supports a variety of instruments, and it can easily be extended to support additional devices.\n\n\nThis documentation covers both \nuser instructions\n and \ndeveloper docs\n.\n\n\n\n\nWhat can Wizkers do?\n\n\nAt the core, Wizkers is designed to interface with various kind of sensors and scientific instruments and visualize and record their data. Wizkers lets you:\n\n\n\n\nVisualize the readings coming from your sensors and instruments\n\n\nRecord those readings\n\n\nForward the readings to a variety of backends - from HTTP REST APIs to WebRTC\n\n\nYou can use this capability to forward data to IoT services, and remain independent\n\n\n\n\n\n\nRemotely control and configure the sensors and instruments connected to it\n\n\n\n\nWho is Wizkers for ?\n\n\nWizkers is an ideal fit for anyone building or using measurement instruments, as it provides all the necessary capabilities to create an instrument utility that works on any operating system or device, is easy to maintain and fast to deploy. This enables instrument and sensor designers to focus on their project without spending too much time on the software part, and still create a best of class interface.\n\n\nWizkers is also a great solution for any sensor deployment project where there is a desire to be truly independent from third party service providers, or the deployment occurs in regions where 24/7 Internet connectivity is not a given. For this reason, Wizkers is popular with NGOs.\n\n\nWhy Wizkers ?\n\n\nWizkers came to life for a couple of simple reasons:\n\n\n\n\nMost lab instruments have no decent computer utilities even though they have great connectivity. Those utilities are usually less than user-friendly, Windows-only, and poorly supported.\n\n\nIt is becoming easier and easier to create and use many small and not-so-small sensors that generate data, but finding good ways to record, visualize and analyze their output, and remotely configure and control them with an engaging interface is often an afterthought.\n\n\nMost IoT services are all about 'dumb' sensors and easy and free APIs, but at the cost of a completely closed backend and limited control on your data once it is sent over. Basically, you are only getting access to half of the infrastructure, and the arguably most critical part is outside of your control. But there are many situations where you want to be able to deploy your own infrastructure without having to rely on a third party, especially if you are not deploying millions of sensors, or you cannot do 24/7 connectivity for some reason.\n\n\n\n\nAnother issue we have experienced many times over the last few years, is that most IoT startups cannot provide any kind of continuity and stability for a project: from Pinocc.io to Pachube, Spark.io, Helium.com, etc, most of those companies tend to review and modify their business model every couple of months, and put any project that relies on them at great risk.\n\n\nWizkers solves all this issues with one elegant framework: In a nutshell, Wizkers is both the missing link between your sensors, your instruments and the Cloud, as well as the missing universal utility for scientific instruments which works on any OS and any computer.\n\n\nWizkers overview\n\n\nSupported instruments\n\n\nThe following instruments are currently supported in Wizkers (as of August 2015):\n\n\n\n\n\n\n\n\nInstrument name\n\n\nChrome App\n\n\nAndroid App\n\n\nServer\n\n\n\n\n\n\n\n\n\n\n\n\nMedcom Onyx\n\n\nYes\n\n\nYes\n\n\nYes\n\n\n\n\n\n\n\n\nMedcom Geiger Link\n\n\nYes\n\n\nYes\n\n\nYes\n\n\n\n\n\n\n\n\nMedcom Blue Onyx\n\n\nChromebooks only\n\n\nYes\n\n\nNo\n\n\n\n\n\n\n\n\nMedcom Hawk Nest\n\n\n-\n\n\n-\n\n\nYes\n\n\n\n\n\n\n\n\nSafecast bGeigie Nano\n\n\nChromebooks only\n\n\nYes\n\n\nNo\n\n\n\n\n\n\n\n\nElecraft KX3\n\n\nYes\n\n\nYes\n\n\nYes\n\n\n\n\n\n\n\n\nRemote KX3 (Wizkers to Wizkers)\n\n\nYes\n\n\nNot tested\n\n\nNot tested\n\n\n\n\n\n\n\n\nFluke 287/289\n\n\nYes\n\n\nYes\n\n\nYes\n\n\n\n\n\n\n\n\nFried Circuits USB tester OLED backpack\n\n\nYes\n\n\nYes\n\n\nYes\n\n\n\n\n\n\n\n\nFried Circuits USB tested BTLE backpack\n\n\nChromebooks only\n\n\nYes\n\n\nNo\n\n\n\n\n\n\n\n\nSimple serial terminal\n\n\nYes\n\n\nYes\n\n\nYes\n\n\n\n\n\n\n\n\nSark 110 antena analyzer\n\n\nYes\n\n\nYes\n\n\nYes\n\n\n\n\n\n\n\n\nKromek Sigma 25\n\n\nYes\n\n\nYes\n\n\nYes\n\n\n\n\n\n\n\n\n\n\nWhat if my instrument is not supported ?\n\n\nWe can help! If you are a developer, you can head over to the \ndeveloper documentation\n and get started. You can also contact us at \ninfo@wizkers.io\n and find out how we can help.\n\n\nWizkers and Open Source\n\n\nWizkers is a fully open source project, released under the terms of the GNU Affero General Public License. The Affero version of the GPL means that if you use Wizkers in any manner (including by running it or offering it as a service), you must make the full source code, including any modifications you did available to all your users.\n\n\nWizkers also uses a variety of third party libraries which are released under multiple license schemes, but are all compatible with this global license.\n\n\nInstallation instructions\n\n\nBelow are installation instructions for the three run modes supported on Wizkers:\n\n\nChrome packaged app\n\n\nWizkers can be \ndownloaded\n from the Chrome app store, and is available on any computer that can run Chrome. This includes MacOS, Linux and Windows. \n\n\nChrome packaged apps rely on the Chrome runtime to run - this means you need to have Google Chrome installed on the computer - but otherwise behave as native applications.\n\n\nAndroid app\n\n\nWizkers will eventually be available on the Google Play store, but in the mean time, you will have to build Wizkers for Android yourself (refer to the \ndeveloper documentation\n for details on how to do this).\n\n\nServer\n\n\nYou can also run Wizkers as a standalone server. You then interact with a running Wizkers instance using a web browser. The advantage of running Wizkers in this mode, is that you can leave it connected to instruments 24/7. Server mode supports advanced features such as user management and user rights, multiple open instruments at the same time.\n\n\nRefer to the \ndeveloper documentation\n for instructions on how to checkout Wizkers from Github and build the server version.", 
            "title": "Overview"
        }, 
        {
            "location": "/#wizkers-documentation", 
            "text": "Wizkers is a universal open source application for both data visualization and control of various kinds of scientific instruments. It is a full Javascript/HTML5 application which runs on nearly any computer, phone or tablet.  It can also run as a standalone server application, on any Linux platform, from a simple Raspberry Pi or Beaglebone black, all the way to cloud-hosted AWS instances, which gives it tremendous flexibility. Basically, it is a real open source simple 'cloud' system  and one of the only 'cloud' projects out there with a fully open source (GNU Affero General Public License) front-end  and  backend.  Out of the box, Wizkers supports a variety of instruments, and it can easily be extended to support additional devices.  This documentation covers both  user instructions  and  developer docs .", 
            "title": "Wizkers documentation"
        }, 
        {
            "location": "/#what-can-wizkers-do", 
            "text": "At the core, Wizkers is designed to interface with various kind of sensors and scientific instruments and visualize and record their data. Wizkers lets you:   Visualize the readings coming from your sensors and instruments  Record those readings  Forward the readings to a variety of backends - from HTTP REST APIs to WebRTC  You can use this capability to forward data to IoT services, and remain independent    Remotely control and configure the sensors and instruments connected to it", 
            "title": "What can Wizkers do?"
        }, 
        {
            "location": "/#who-is-wizkers-for", 
            "text": "Wizkers is an ideal fit for anyone building or using measurement instruments, as it provides all the necessary capabilities to create an instrument utility that works on any operating system or device, is easy to maintain and fast to deploy. This enables instrument and sensor designers to focus on their project without spending too much time on the software part, and still create a best of class interface.  Wizkers is also a great solution for any sensor deployment project where there is a desire to be truly independent from third party service providers, or the deployment occurs in regions where 24/7 Internet connectivity is not a given. For this reason, Wizkers is popular with NGOs.", 
            "title": "Who is Wizkers for ?"
        }, 
        {
            "location": "/#why-wizkers", 
            "text": "Wizkers came to life for a couple of simple reasons:   Most lab instruments have no decent computer utilities even though they have great connectivity. Those utilities are usually less than user-friendly, Windows-only, and poorly supported.  It is becoming easier and easier to create and use many small and not-so-small sensors that generate data, but finding good ways to record, visualize and analyze their output, and remotely configure and control them with an engaging interface is often an afterthought.  Most IoT services are all about 'dumb' sensors and easy and free APIs, but at the cost of a completely closed backend and limited control on your data once it is sent over. Basically, you are only getting access to half of the infrastructure, and the arguably most critical part is outside of your control. But there are many situations where you want to be able to deploy your own infrastructure without having to rely on a third party, especially if you are not deploying millions of sensors, or you cannot do 24/7 connectivity for some reason.   Another issue we have experienced many times over the last few years, is that most IoT startups cannot provide any kind of continuity and stability for a project: from Pinocc.io to Pachube, Spark.io, Helium.com, etc, most of those companies tend to review and modify their business model every couple of months, and put any project that relies on them at great risk.  Wizkers solves all this issues with one elegant framework: In a nutshell, Wizkers is both the missing link between your sensors, your instruments and the Cloud, as well as the missing universal utility for scientific instruments which works on any OS and any computer.", 
            "title": "Why Wizkers ?"
        }, 
        {
            "location": "/#wizkers-overview", 
            "text": "", 
            "title": "Wizkers overview"
        }, 
        {
            "location": "/#supported-instruments", 
            "text": "The following instruments are currently supported in Wizkers (as of August 2015):     Instrument name  Chrome App  Android App  Server       Medcom Onyx  Yes  Yes  Yes     Medcom Geiger Link  Yes  Yes  Yes     Medcom Blue Onyx  Chromebooks only  Yes  No     Medcom Hawk Nest  -  -  Yes     Safecast bGeigie Nano  Chromebooks only  Yes  No     Elecraft KX3  Yes  Yes  Yes     Remote KX3 (Wizkers to Wizkers)  Yes  Not tested  Not tested     Fluke 287/289  Yes  Yes  Yes     Fried Circuits USB tester OLED backpack  Yes  Yes  Yes     Fried Circuits USB tested BTLE backpack  Chromebooks only  Yes  No     Simple serial terminal  Yes  Yes  Yes     Sark 110 antena analyzer  Yes  Yes  Yes     Kromek Sigma 25  Yes  Yes  Yes", 
            "title": "Supported instruments"
        }, 
        {
            "location": "/#what-if-my-instrument-is-not-supported", 
            "text": "We can help! If you are a developer, you can head over to the  developer documentation  and get started. You can also contact us at  info@wizkers.io  and find out how we can help.", 
            "title": "What if my instrument is not supported ?"
        }, 
        {
            "location": "/#wizkers-and-open-source", 
            "text": "Wizkers is a fully open source project, released under the terms of the GNU Affero General Public License. The Affero version of the GPL means that if you use Wizkers in any manner (including by running it or offering it as a service), you must make the full source code, including any modifications you did available to all your users.  Wizkers also uses a variety of third party libraries which are released under multiple license schemes, but are all compatible with this global license.", 
            "title": "Wizkers and Open Source"
        }, 
        {
            "location": "/#installation-instructions", 
            "text": "Below are installation instructions for the three run modes supported on Wizkers:", 
            "title": "Installation instructions"
        }, 
        {
            "location": "/#chrome-packaged-app", 
            "text": "Wizkers can be  downloaded  from the Chrome app store, and is available on any computer that can run Chrome. This includes MacOS, Linux and Windows.   Chrome packaged apps rely on the Chrome runtime to run - this means you need to have Google Chrome installed on the computer - but otherwise behave as native applications.", 
            "title": "Chrome packaged app"
        }, 
        {
            "location": "/#android-app", 
            "text": "Wizkers will eventually be available on the Google Play store, but in the mean time, you will have to build Wizkers for Android yourself (refer to the  developer documentation  for details on how to do this).", 
            "title": "Android app"
        }, 
        {
            "location": "/#server", 
            "text": "You can also run Wizkers as a standalone server. You then interact with a running Wizkers instance using a web browser. The advantage of running Wizkers in this mode, is that you can leave it connected to instruments 24/7. Server mode supports advanced features such as user management and user rights, multiple open instruments at the same time.  Refer to the  developer documentation  for instructions on how to checkout Wizkers from Github and build the server version.", 
            "title": "Server"
        }, 
        {
            "location": "/userdoc/", 
            "text": "Wizkers User documentation\n\n\nWelcome to the user documentation of Wizkers. This section will help you make the most of the various capabilities of Wizkers.\n\n\nRefer to the \nintroduction\n for installation instructions.\n\n\nHome screen\n\n\nThe home screen contains three main zones:\n\n\n\n\nConnect/Setup/Record zone\n\n\nMain view / Live view\n\n\nSide view\n\n\n\n\n\n\nThe first time you start Wizkers, you will need to create a new instrument, as described in the next section.\n\n\nConnecting instruments\n\n\n\n\nThe top buttons are pretty much self-explanatory: the \u201cConnect\u201d button opens the connection to the instrument. The \u201cDevice Setup\u201d button will only be enabled if the device supports a Setup screen (not all do). Last, the \u201cRecord Session\u201d button lets you do a live recording of the data coming in from the device. You can view the logs that are saved there in the \u201cLogs and recordings\u201d screen.\n\n\nConfiguring instruments\n\n\nAll instrument configuration is done on the \u201cInstruments\u201d screen. The first time you start the application, no instruments will be present. To create a new instrument, click on \u201cAdd Instrument\u201d card:\n\n\n\n\nAfter pressing \u201cAdd Instrument\u201c, you will be presented with a blank configuration screen, as shown below. Some instruments display extra settings, but the following is always present:\n\n\n\n\nFirst of all, give a \u201cFriendly Name\u201d to your instrument, and select the correct instrument type.\n\n\nDepending on the instrument type, the \"port\" section will be different. Port can be:\n\n\n\n\nA serial port\n\n\nA bluetooth device\n\n\nA network address\n\n\nAn API Key\n\n\n\n\nRefer to the documentation of each instrument for more details on how to configure those fields.\n\n\nThe \nLive view length\n option defines the time length of the the home screen live view - by defaults, Wizkers displays the last five minutes of data, or last 500 points.\n\n\nPolling period\n defines how often Wizkers requests information from the instrument. Some instruments will send data at their own rate, in which case this setting will be unused for that instrument.\n\n\nLogs and recordings\n\n\nThe Logs and recordings screen gives you access to all the recordings and logs saved on Wizkers, as well as an interface to download device logs if the currently connected instrument supports this.\n\n\nOutputs\n\n\nOutput plugins are one of the great features of Wizkers: using those plugins, you can automatically send the data generated by your instruments to various backend services.\n\n\nAt the moment, Wizkers ships with four output plugins:\n\n\n\n\nGeneric REST output\n\n\nSafecast output\n\n\nHAM Radio \n\u201crigctld\u201d emulation plugin\n, for remote control of radios.\n\n\nWebRTC Output\n\n\n\n\nCreating and configuring an output\n\n\nAll output plugins share quite a few settings: selecting what fields should be sent to the output, how often and with what conditions:\n\n\nWhen you create an output from the \u201cData Output\u201d screen (option on the top menu bar), you will see the screen below:\n\n\n\n\nNote: you should be connected to the current instrument before creating an output, because the output plugin detects the data sent by the instrument for creating its configuration.\n\n\nYou can select the output plugin, give it a name and write notes in the top part of the window.\n\n\nThe section on the right tells you when the plugin was last triggered with success, when it last attempted to send data, and what the last message from the backend was. Very useful for debugging.\n\n\nThen the screen contains three tabs: \u201cData to send\u201d, \u201cWhen to send it\u201d, \u201cOutput Settings\u201d. Only the last one (\u201cOutput Settings\u201d) is plugin-specific, the first two are identical for all output plugins.\n\n\nData to send\n\n\nAgain, you need to be connected to your instrument in order to be able to do anything with this screen. If not, it only displays a help message encouraging you to do so.\n\n\nWizkers in server mode\n\n\nIn server mode, you connect to Wizkers by pointing your Chrome browser to the IP address of the computer running Wizkers.\n\n\nIn this mode, Wizkers will behave a little bit differently:\n\n\n\n\nIt will enforce a simple user authentication mechanism\n\n\nIt will support multiple open instruments at once\n\n\nIt will keep all open instruments connected even when the user logs out of the interface\n\n\n\n\nThis makes it possible to use Wizkers for autonomous monitoring stations. When combined with local recording and output capabilties, this actually turns Wizkers into a pretty powerful system.\n\n\nUser authentication\n\n\nThe first time you access Wizkesr through the network, a default \nadmin\n user will be created. Wizkers will force you to change the default admin password before letting you access most of its functionality.\n\n\nTODO: describe user roles\n\n\nAutorecord and autoreconnect\n\n\nWizkers is designed to be a very resilient system: when running by itself on small embedded devices, there can be situations such as power cuts which will lead the device to reboot. For this reason, in server mode you will see two extra flags on Wizkers on each instrument configuration screen:\n\n\n\n\nThose two options are fairly self-explanatory: when the Wizkers server is started, it will go through all configured instruments, and automatically reconnect (and start recording) them according to those check boxes.\n\n\nMultiple open devices\n\n\nWhile Wizkers in Chrome and Android modes only supports one open instrument at a time, you can open multiple instruments simultaneously in server mode, and simply switch from one to another without closing them. In the \"Instruments\" screen, you will see a little green badge next to all connected instruments.", 
            "title": "Users"
        }, 
        {
            "location": "/userdoc/#wizkers-user-documentation", 
            "text": "Welcome to the user documentation of Wizkers. This section will help you make the most of the various capabilities of Wizkers.  Refer to the  introduction  for installation instructions.", 
            "title": "Wizkers User documentation"
        }, 
        {
            "location": "/userdoc/#home-screen", 
            "text": "The home screen contains three main zones:   Connect/Setup/Record zone  Main view / Live view  Side view    The first time you start Wizkers, you will need to create a new instrument, as described in the next section.", 
            "title": "Home screen"
        }, 
        {
            "location": "/userdoc/#connecting-instruments", 
            "text": "The top buttons are pretty much self-explanatory: the \u201cConnect\u201d button opens the connection to the instrument. The \u201cDevice Setup\u201d button will only be enabled if the device supports a Setup screen (not all do). Last, the \u201cRecord Session\u201d button lets you do a live recording of the data coming in from the device. You can view the logs that are saved there in the \u201cLogs and recordings\u201d screen.", 
            "title": "Connecting instruments"
        }, 
        {
            "location": "/userdoc/#configuring-instruments", 
            "text": "All instrument configuration is done on the \u201cInstruments\u201d screen. The first time you start the application, no instruments will be present. To create a new instrument, click on \u201cAdd Instrument\u201d card:   After pressing \u201cAdd Instrument\u201c, you will be presented with a blank configuration screen, as shown below. Some instruments display extra settings, but the following is always present:   First of all, give a \u201cFriendly Name\u201d to your instrument, and select the correct instrument type.  Depending on the instrument type, the \"port\" section will be different. Port can be:   A serial port  A bluetooth device  A network address  An API Key   Refer to the documentation of each instrument for more details on how to configure those fields.  The  Live view length  option defines the time length of the the home screen live view - by defaults, Wizkers displays the last five minutes of data, or last 500 points.  Polling period  defines how often Wizkers requests information from the instrument. Some instruments will send data at their own rate, in which case this setting will be unused for that instrument.", 
            "title": "Configuring instruments"
        }, 
        {
            "location": "/userdoc/#logs-and-recordings", 
            "text": "The Logs and recordings screen gives you access to all the recordings and logs saved on Wizkers, as well as an interface to download device logs if the currently connected instrument supports this.", 
            "title": "Logs and recordings"
        }, 
        {
            "location": "/userdoc/#outputs", 
            "text": "Output plugins are one of the great features of Wizkers: using those plugins, you can automatically send the data generated by your instruments to various backend services.  At the moment, Wizkers ships with four output plugins:   Generic REST output  Safecast output  HAM Radio  \u201crigctld\u201d emulation plugin , for remote control of radios.  WebRTC Output", 
            "title": "Outputs"
        }, 
        {
            "location": "/userdoc/#creating-and-configuring-an-output", 
            "text": "All output plugins share quite a few settings: selecting what fields should be sent to the output, how often and with what conditions:  When you create an output from the \u201cData Output\u201d screen (option on the top menu bar), you will see the screen below:   Note: you should be connected to the current instrument before creating an output, because the output plugin detects the data sent by the instrument for creating its configuration.  You can select the output plugin, give it a name and write notes in the top part of the window.  The section on the right tells you when the plugin was last triggered with success, when it last attempted to send data, and what the last message from the backend was. Very useful for debugging.  Then the screen contains three tabs: \u201cData to send\u201d, \u201cWhen to send it\u201d, \u201cOutput Settings\u201d. Only the last one (\u201cOutput Settings\u201d) is plugin-specific, the first two are identical for all output plugins.", 
            "title": "Creating and configuring an output"
        }, 
        {
            "location": "/userdoc/#data-to-send", 
            "text": "Again, you need to be connected to your instrument in order to be able to do anything with this screen. If not, it only displays a help message encouraging you to do so.", 
            "title": "Data to send"
        }, 
        {
            "location": "/userdoc/#wizkers-in-server-mode", 
            "text": "In server mode, you connect to Wizkers by pointing your Chrome browser to the IP address of the computer running Wizkers.  In this mode, Wizkers will behave a little bit differently:   It will enforce a simple user authentication mechanism  It will support multiple open instruments at once  It will keep all open instruments connected even when the user logs out of the interface   This makes it possible to use Wizkers for autonomous monitoring stations. When combined with local recording and output capabilties, this actually turns Wizkers into a pretty powerful system.", 
            "title": "Wizkers in server mode"
        }, 
        {
            "location": "/userdoc/#user-authentication", 
            "text": "The first time you access Wizkesr through the network, a default  admin  user will be created. Wizkers will force you to change the default admin password before letting you access most of its functionality.  TODO: describe user roles", 
            "title": "User authentication"
        }, 
        {
            "location": "/userdoc/#autorecord-and-autoreconnect", 
            "text": "Wizkers is designed to be a very resilient system: when running by itself on small embedded devices, there can be situations such as power cuts which will lead the device to reboot. For this reason, in server mode you will see two extra flags on Wizkers on each instrument configuration screen:   Those two options are fairly self-explanatory: when the Wizkers server is started, it will go through all configured instruments, and automatically reconnect (and start recording) them according to those check boxes.", 
            "title": "Autorecord and autoreconnect"
        }, 
        {
            "location": "/userdoc/#multiple-open-devices", 
            "text": "While Wizkers in Chrome and Android modes only supports one open instrument at a time, you can open multiple instruments simultaneously in server mode, and simply switch from one to another without closing them. In the \"Instruments\" screen, you will see a little green badge next to all connected instruments.", 
            "title": "Multiple open devices"
        }, 
        {
            "location": "/devdoc/", 
            "text": "Developer documentation\n\n\nBuilding Wizkers\n\n\nRefer to the \nbuild instructions\n to do a check out and initial build of the code. Wizkers mostly being a javascript application, there is no \"compilation\" per se, but rather automated code optimization, download of dependencies, etc.\n\n\nWizkers architecture\n\n\nDue to its multiple supported run modes, the structure of Wizkers is split between a \u201cfront-end\u201d and a \u201cback-end\u201d part, even when it runs 100% in a browser.\n\n\nThe diagram below shows how the the various components of Wizkers interact with each other. If you want to add new instruments, this will be a good reference, though you will usually not need to go deep into those modules, and only implement instrument views and the instruments\u2019s front-end/back-end API.\n\n\n\n\nGlobal Wizkers services\n\n\nThe Wizkers front-end exposes a couple of global objects/services throughout the application:\n\n\n\n\nThe Instrument manager\n\n\nThe Output manager\n\n\nThe link manager\n\n\n\n\nAll communication between the various parts of Wizkers, whether they are located in the browser or on the server, are done using those three services.\n\n\nWizkers also exposes a couple of utility services:\n\n\n\n\nThe statistics service, which enables the connection of Wizkers to analytics services\n\n\nThe global settings\n\n\n\n\nThe link manager\n\n\nThe link manager is the interface between the front-end and the back-end of Wizkers. In particular, the front-end only talks to instruments through the link manager.\n\n\nEven when Wizkers is running on its own (not in server mode), it makes use of the link manager, which makes it possible to use a single architecture for both in-app and server modes.\n\n\nIn server mode, the link manager uses socket.io to communicate with the server for all commands and instrument data - the HTML and javascript resources are loaded directly using HTTP.\n\n\nIn Chrome or Cordova mode, the link manager talks to the \nchromeSocket.js\n object, which emulates the API of socker.io but implements the backend on the app directly.\n\n\nThe Instrument manager\n\n\nThe instrument manager loads new instruments, switches between instruments.\n\n\nThe Output manager\n\n\nThe output manager subscribes to all data coming in from instruments, is in charge or starting/stopping outputs depending on what is enabled for a particular instrument, and forwards instrument data to all active outputs.\n\n\nSource tree organization\n\n\nThe Wizkers source tree is organized as follows:\n\n\nREADME.md            # Top level Readme, for the benefit of Github\nbuild-tools          # A couple of build scripts used to optimize the javascript for the Chrome version\ncordova              # Cordova-specific files used to build Wizkers\ndocumentation        # The documentation you are reading right now\nserver               # Files used by Wizkers in server mode\nchrome               # Files used by Wizkers in Chrome mode\ngulpfile.js          # The toplevel gulpfile\nmerges               # er....\npackage.json         # npm toplevel package file\nwww                  # The complete javascript app - frontend only in server mode, complete app in Chrome/Cordova mode\n\n\n\n\nwww tree\n\n\nMost of the code of Wizkers is contained in the \nwww\n directory, which is organized as follows:\n\n\nwww/css             # Stylesheets used by the app\nwww/fonts           # Fonts used be the app\nwww/img             # Images used by the app\nwww/js              # The core of Wizkers, see below for organization\n...                 # A couple of extra files used for examples\n\n\n\n\nThe \njs\n directory is then structured in a modular fashion, to make it easy to extend Wizkers:\n\n\nwww/js/app              # The main Wizkers app\nwww/js/app/connections  # Used in Chrome/Cordova mode: low-level drivers for serial/bluetooth/etc\nwww/js/app/instruments  # All instruments supported by Wizkers\nwww/js/app/lib          # Wizkers shared libraries\nwww/js/app/models       # Wizkers Backbone models\nwww/js/app/outputs      # Output plugins\nwww/js/app/views        # Wizkers views (screens)\nwww/js/lib              # All third party libraries used by Wizkers\nwww/js/tpl              # All HTML templates used by the various Wizkers screens/views.\n\n\n\n\nRun-mode specific trees\n\n\nThe \ncordova\n, \nserver\n and \nchrome\n directories contain all the files that are specific to those run-modes. When \nbuilding\n Wizkers, Gulp will add the contents of those directories to the \ndist\n directory to end up with a working version of Wizkers for those various run modes.", 
            "title": "Overview"
        }, 
        {
            "location": "/devdoc/#developer-documentation", 
            "text": "", 
            "title": "Developer documentation"
        }, 
        {
            "location": "/devdoc/#building-wizkers", 
            "text": "Refer to the  build instructions  to do a check out and initial build of the code. Wizkers mostly being a javascript application, there is no \"compilation\" per se, but rather automated code optimization, download of dependencies, etc.", 
            "title": "Building Wizkers"
        }, 
        {
            "location": "/devdoc/#wizkers-architecture", 
            "text": "Due to its multiple supported run modes, the structure of Wizkers is split between a \u201cfront-end\u201d and a \u201cback-end\u201d part, even when it runs 100% in a browser.  The diagram below shows how the the various components of Wizkers interact with each other. If you want to add new instruments, this will be a good reference, though you will usually not need to go deep into those modules, and only implement instrument views and the instruments\u2019s front-end/back-end API.", 
            "title": "Wizkers architecture"
        }, 
        {
            "location": "/devdoc/#global-wizkers-services", 
            "text": "The Wizkers front-end exposes a couple of global objects/services throughout the application:   The Instrument manager  The Output manager  The link manager   All communication between the various parts of Wizkers, whether they are located in the browser or on the server, are done using those three services.  Wizkers also exposes a couple of utility services:   The statistics service, which enables the connection of Wizkers to analytics services  The global settings", 
            "title": "Global Wizkers services"
        }, 
        {
            "location": "/devdoc/#the-link-manager", 
            "text": "The link manager is the interface between the front-end and the back-end of Wizkers. In particular, the front-end only talks to instruments through the link manager.  Even when Wizkers is running on its own (not in server mode), it makes use of the link manager, which makes it possible to use a single architecture for both in-app and server modes.  In server mode, the link manager uses socket.io to communicate with the server for all commands and instrument data - the HTML and javascript resources are loaded directly using HTTP.  In Chrome or Cordova mode, the link manager talks to the  chromeSocket.js  object, which emulates the API of socker.io but implements the backend on the app directly.", 
            "title": "The link manager"
        }, 
        {
            "location": "/devdoc/#the-instrument-manager", 
            "text": "The instrument manager loads new instruments, switches between instruments.", 
            "title": "The Instrument manager"
        }, 
        {
            "location": "/devdoc/#the-output-manager", 
            "text": "The output manager subscribes to all data coming in from instruments, is in charge or starting/stopping outputs depending on what is enabled for a particular instrument, and forwards instrument data to all active outputs.", 
            "title": "The Output manager"
        }, 
        {
            "location": "/devdoc/#source-tree-organization", 
            "text": "The Wizkers source tree is organized as follows:  README.md            # Top level Readme, for the benefit of Github\nbuild-tools          # A couple of build scripts used to optimize the javascript for the Chrome version\ncordova              # Cordova-specific files used to build Wizkers\ndocumentation        # The documentation you are reading right now\nserver               # Files used by Wizkers in server mode\nchrome               # Files used by Wizkers in Chrome mode\ngulpfile.js          # The toplevel gulpfile\nmerges               # er....\npackage.json         # npm toplevel package file\nwww                  # The complete javascript app - frontend only in server mode, complete app in Chrome/Cordova mode", 
            "title": "Source tree organization"
        }, 
        {
            "location": "/devdoc/#www-tree", 
            "text": "Most of the code of Wizkers is contained in the  www  directory, which is organized as follows:  www/css             # Stylesheets used by the app\nwww/fonts           # Fonts used be the app\nwww/img             # Images used by the app\nwww/js              # The core of Wizkers, see below for organization\n...                 # A couple of extra files used for examples  The  js  directory is then structured in a modular fashion, to make it easy to extend Wizkers:  www/js/app              # The main Wizkers app\nwww/js/app/connections  # Used in Chrome/Cordova mode: low-level drivers for serial/bluetooth/etc\nwww/js/app/instruments  # All instruments supported by Wizkers\nwww/js/app/lib          # Wizkers shared libraries\nwww/js/app/models       # Wizkers Backbone models\nwww/js/app/outputs      # Output plugins\nwww/js/app/views        # Wizkers views (screens)\nwww/js/lib              # All third party libraries used by Wizkers\nwww/js/tpl              # All HTML templates used by the various Wizkers screens/views.", 
            "title": "www tree"
        }, 
        {
            "location": "/devdoc/#run-mode-specific-trees", 
            "text": "The  cordova ,  server  and  chrome  directories contain all the files that are specific to those run-modes. When  building  Wizkers, Gulp will add the contents of those directories to the  dist  directory to end up with a working version of Wizkers for those various run modes.", 
            "title": "Run-mode specific trees"
        }, 
        {
            "location": "/building/", 
            "text": "Building Wizkers\n\n\nPrerequisites (all platforms)\n\n\nThe only prerequisite for building (and running Wizkers in server mode) are NodeJS and npm.\n\n\nYou will need to install a recent version of NodeJS. This used to be a tricky requirement on Linux, but not anymore, since it is now easy to install Node JS using \nmost package managers\n.\n\n\nNote that NodeJS is a project that evolves very fast, and pretty much 100% of all distributions out there ship with very outdated version of Node. Resist the temptation to use the version of Node that is shipped with\nyour distribution, it won't work properly. Likewise, do not try to use you distribution's package manager to install Node sub-dependencies, those will also be outdated and will break. Like Python, NodeJS does not play very well with\nthe classic packaging model, which is unfortunate but beyond the scope of this discussion...\n\n\nAt the time of this writing, Wizkers can be built and run using \nNode version 6.9.1\n (aka \"LTS\" on the nodejs.org website).\n\n\nPlatform-specific prerequisites\n\n\nMacOS\n\n\nNo additional prerequisites.\n\n\nLinux (Debian and Ubuntu based Linux distributions)\n\n\nWe assume here that you are starting with a computer/server/board running on Debian or Ubuntu Linux, or a variant. This includes\nfor instance most Beaglebone images, Rapsberry Pi, etc. Installation of Linux itself is out of the scope of this document.\n\n\nOn a new installation, you will need to install the basic development toolchains, as well as NodeJS and git:\n\n\nsudo apt-get update\nsudo apt-get upgrade\nsudo apt-get dist-upgrade\nsudo apt-get install --yes ntpdate\nsudo ntpdate -b -s -u pool.ntp.org\nsudo apt-get install --yes build-essential\nsudo apt-get install --yes curl\ncurl -sL https://deb.nodesource.com/setup_6.x | sudo -E bash -\nsudo apt-get install --yes nodejs\nsudo apt-get install --yes git\n\n\n\n\nYou can then move on to checking out the code, as described in the next section.\n\n\nNode-serialport issues on Linux\n\n\n(Note: this might be outdated on current versions of Debian/Ubuntu, to be validated)\n\n\nYou might have to add rules in udev to make sure the right entries are created in \n/dev/serial\n because Debian does not do it by default, at least on the BeagleBone.\n\n\ndebian@aprs:~$ cat /etc/udev/rules.d/60-ed-persistent-serial.rules \nENV{.ID_PORT}==\n, SYMLINK+=\nserial/by-id/$env{ID_BUS}-$env{ID_SERIAL}-if$env{ID_USB_INTERFACE_NUM}\n\nENV{.ID_PORT}==\n?*\n, SYMLINK+=\nserial/by-id/$env{ID_BUS}-$env{ID_SERIAL}-if$env{ID_USB_INTERFACE_NUM}-port$env{.ID_PORT}\n\n\n\n\n\nThis way, you will be able to list serial ports even on the most recent versions on node-serialport.    \n\n\nWindows\n\n\nWhile there is no good reason why building Wizkers on Windows shouldn't work, I have never attempted it. If you would like to contribute instructions, please reach out at \ninfo@wizkers.io\n.\n\n\nBuilding steps (all platforms)\n\n\nCheck out the code\n\n\nWizkers is hosted on \ngithub\n. These instructions suggest you use \"git\", but you can actually simply download the source code as a ZIP archive \nhere\n.\nThe upside of using git, though, is that you can easily upgrade to newer version of wizkers at a later stage by typing a simple \ngit pull\n from the \nwizkers\n directory and follow the \ngulp\n steps below again.\n\n\nAssuming you are using git: Create a work directory on your machine and check out the code from Github:\n\n\ngit clone https://github.com/wizkers/wizkers.git\ncd wizkers/wizkers\n\n\n\n\nBuild it - step 1\n\n\nThe next step is to install all dependencies using npm:\n\n\nsudo npm install -g gulp-cli\nnpm install\n\n\n\n\nThis can take from a couple of minutes to quite some time if you are building on a low power system such as a Beaglebone.\n\n\nOnce all dependencies are installed, Wizkers uses 'gulp' as its build system. Gulp automates all build steps which would otherwise be pretty complex.\n\n\nPick your run mode\n\n\nWizkers supports multiple modes: server, nwjs, chrome, cordova, etc. Below is a short description of each mode:\n\n\n\n\n\n\n\n\nMode name\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\n\n\nserver\n\n\nRun in server mode (port 8090 by default)\n\n\n\n\n\n\n\n\ncordova\n\n\nRun as an Android or iOS application. The output of the build will be an Android or iOS app that you have to install on your device.\n\n\n\n\n\n\n\n\nnsjw\n\n\nRun as a native application using the nwjs.io framework. Instructions will be added below at a later stage on how to run Wizkers in that mode.\n\n\n\n\n\n\n\n\nchrome\n\n\nRun as a Chrome app. See below for instructions on how to run in that mode.\n\n\n\n\n\n\n\n\n\n\nPick your flavor\n\n\nThere are also multiple Flavors of Wizker: Wizkers:Radio, Wizkers:Nuclear, etc. You will need to indicate the build flavor on the command\nline by using the \"OEM\" variable. All build flavors correspond to an actual application that is built using the Wizkers framework, and they are listed in the \"oem\" directory.\nThe flavors that are defined at the time of this writing are:\n\n\n\n\n\n\n\n\nFlavor name\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\n\n\nradio\n\n\nWizkers:Radio\n\n\n\n\n\n\n\n\nnuclear\n\n\nWizkers:Nuclear\n\n\n\n\n\n\n\n\nbench\n\n\nWork in progress, for benchtop instruments\n\n\n\n\n\n\n\n\nsafecast\n\n\nBuilds Safecast:Drive, the Safecast.org Android app\n\n\n\n\n\n\n\n\n\n\nBuild it!\n\n\nYou can now build wizkers in the mode/flavor of your choice. For instance, for Wizkers:Radio in 'server' mode:\n\n\nOEM=radio gulp server\n\n\n\n\nThe results of the build are in the \ndist\n directory.\n\n\nFinalizing and packaging\n\n\nOnce the base code is built through Gulp, the instructions below will show you how to finalize the build for the various run modes and launch Wizkers:\n\n\nChrome app\n\n\nAfter building, the Chrome version of Wizkers will be ready in \ndist/chrome\n and \ndist/chrome-debug\n. The \nchrome-debug\n directory can be immediately loaded into Google Chrome by visiting (chrome://extensions) and loading Wizkers from there.\n\n\nThe \nchrome\n version requires finalizing the compilation by launching \nbuild-toold/build-chrome.sh\n which will optimize the javascript code. The resulting Chrome app in \ndist/chrome\n will run faster but it won't be possible to debug it easily.\n\n\nCordova (Android and/or iOS app)\n\n\nThe Android app version of Wizker uses the Cordova framework to package Wizkers into a native Android application.\n\n\nThe first thing to do is to install Cordova on your machine:\n\n\nnpm install -g cordova\n\n\n\n\nThen cd to the \ndist/cordova-debug\n directory and add the target Cordova plaforms of your choice, and build, for instance:\n\n\ncordova platform add Android\ncordova build\n\n\n\n\nFor further instructions on how to complete the build and install on your device, please refer to the \nCordova documentation\n online.\n\n\nServer\n\n\nThe server build of Wizkers is available in \ndist/server\n. Simply go to that directory and launch the server:\n\n\ncd dist/server\n./start-server.sh", 
            "title": "Building"
        }, 
        {
            "location": "/building/#building-wizkers", 
            "text": "", 
            "title": "Building Wizkers"
        }, 
        {
            "location": "/building/#prerequisites-all-platforms", 
            "text": "The only prerequisite for building (and running Wizkers in server mode) are NodeJS and npm.  You will need to install a recent version of NodeJS. This used to be a tricky requirement on Linux, but not anymore, since it is now easy to install Node JS using  most package managers .  Note that NodeJS is a project that evolves very fast, and pretty much 100% of all distributions out there ship with very outdated version of Node. Resist the temptation to use the version of Node that is shipped with\nyour distribution, it won't work properly. Likewise, do not try to use you distribution's package manager to install Node sub-dependencies, those will also be outdated and will break. Like Python, NodeJS does not play very well with\nthe classic packaging model, which is unfortunate but beyond the scope of this discussion...  At the time of this writing, Wizkers can be built and run using  Node version 6.9.1  (aka \"LTS\" on the nodejs.org website).", 
            "title": "Prerequisites (all platforms)"
        }, 
        {
            "location": "/building/#platform-specific-prerequisites", 
            "text": "", 
            "title": "Platform-specific prerequisites"
        }, 
        {
            "location": "/building/#macos", 
            "text": "No additional prerequisites.", 
            "title": "MacOS"
        }, 
        {
            "location": "/building/#linux-debian-and-ubuntu-based-linux-distributions", 
            "text": "We assume here that you are starting with a computer/server/board running on Debian or Ubuntu Linux, or a variant. This includes\nfor instance most Beaglebone images, Rapsberry Pi, etc. Installation of Linux itself is out of the scope of this document.  On a new installation, you will need to install the basic development toolchains, as well as NodeJS and git:  sudo apt-get update\nsudo apt-get upgrade\nsudo apt-get dist-upgrade\nsudo apt-get install --yes ntpdate\nsudo ntpdate -b -s -u pool.ntp.org\nsudo apt-get install --yes build-essential\nsudo apt-get install --yes curl\ncurl -sL https://deb.nodesource.com/setup_6.x | sudo -E bash -\nsudo apt-get install --yes nodejs\nsudo apt-get install --yes git  You can then move on to checking out the code, as described in the next section.", 
            "title": "Linux (Debian and Ubuntu based Linux distributions)"
        }, 
        {
            "location": "/building/#node-serialport-issues-on-linux", 
            "text": "(Note: this might be outdated on current versions of Debian/Ubuntu, to be validated)  You might have to add rules in udev to make sure the right entries are created in  /dev/serial  because Debian does not do it by default, at least on the BeagleBone.  debian@aprs:~$ cat /etc/udev/rules.d/60-ed-persistent-serial.rules \nENV{.ID_PORT}== , SYMLINK+= serial/by-id/$env{ID_BUS}-$env{ID_SERIAL}-if$env{ID_USB_INTERFACE_NUM} \nENV{.ID_PORT}== ?* , SYMLINK+= serial/by-id/$env{ID_BUS}-$env{ID_SERIAL}-if$env{ID_USB_INTERFACE_NUM}-port$env{.ID_PORT}   This way, you will be able to list serial ports even on the most recent versions on node-serialport.", 
            "title": "Node-serialport issues on Linux"
        }, 
        {
            "location": "/building/#windows", 
            "text": "While there is no good reason why building Wizkers on Windows shouldn't work, I have never attempted it. If you would like to contribute instructions, please reach out at  info@wizkers.io .", 
            "title": "Windows"
        }, 
        {
            "location": "/building/#building-steps-all-platforms", 
            "text": "", 
            "title": "Building steps (all platforms)"
        }, 
        {
            "location": "/building/#check-out-the-code", 
            "text": "Wizkers is hosted on  github . These instructions suggest you use \"git\", but you can actually simply download the source code as a ZIP archive  here .\nThe upside of using git, though, is that you can easily upgrade to newer version of wizkers at a later stage by typing a simple  git pull  from the  wizkers  directory and follow the  gulp  steps below again.  Assuming you are using git: Create a work directory on your machine and check out the code from Github:  git clone https://github.com/wizkers/wizkers.git\ncd wizkers/wizkers", 
            "title": "Check out the code"
        }, 
        {
            "location": "/building/#build-it-step-1", 
            "text": "The next step is to install all dependencies using npm:  sudo npm install -g gulp-cli\nnpm install  This can take from a couple of minutes to quite some time if you are building on a low power system such as a Beaglebone.  Once all dependencies are installed, Wizkers uses 'gulp' as its build system. Gulp automates all build steps which would otherwise be pretty complex.", 
            "title": "Build it - step 1"
        }, 
        {
            "location": "/building/#pick-your-run-mode", 
            "text": "Wizkers supports multiple modes: server, nwjs, chrome, cordova, etc. Below is a short description of each mode:     Mode name  Description       server  Run in server mode (port 8090 by default)     cordova  Run as an Android or iOS application. The output of the build will be an Android or iOS app that you have to install on your device.     nsjw  Run as a native application using the nwjs.io framework. Instructions will be added below at a later stage on how to run Wizkers in that mode.     chrome  Run as a Chrome app. See below for instructions on how to run in that mode.", 
            "title": "Pick your run mode"
        }, 
        {
            "location": "/building/#pick-your-flavor", 
            "text": "There are also multiple Flavors of Wizker: Wizkers:Radio, Wizkers:Nuclear, etc. You will need to indicate the build flavor on the command\nline by using the \"OEM\" variable. All build flavors correspond to an actual application that is built using the Wizkers framework, and they are listed in the \"oem\" directory.\nThe flavors that are defined at the time of this writing are:     Flavor name  Description       radio  Wizkers:Radio     nuclear  Wizkers:Nuclear     bench  Work in progress, for benchtop instruments     safecast  Builds Safecast:Drive, the Safecast.org Android app", 
            "title": "Pick your flavor"
        }, 
        {
            "location": "/building/#build-it", 
            "text": "You can now build wizkers in the mode/flavor of your choice. For instance, for Wizkers:Radio in 'server' mode:  OEM=radio gulp server  The results of the build are in the  dist  directory.", 
            "title": "Build it!"
        }, 
        {
            "location": "/building/#finalizing-and-packaging", 
            "text": "Once the base code is built through Gulp, the instructions below will show you how to finalize the build for the various run modes and launch Wizkers:", 
            "title": "Finalizing and packaging"
        }, 
        {
            "location": "/building/#chrome-app", 
            "text": "After building, the Chrome version of Wizkers will be ready in  dist/chrome  and  dist/chrome-debug . The  chrome-debug  directory can be immediately loaded into Google Chrome by visiting (chrome://extensions) and loading Wizkers from there.  The  chrome  version requires finalizing the compilation by launching  build-toold/build-chrome.sh  which will optimize the javascript code. The resulting Chrome app in  dist/chrome  will run faster but it won't be possible to debug it easily.", 
            "title": "Chrome app"
        }, 
        {
            "location": "/building/#cordova-android-andor-ios-app", 
            "text": "The Android app version of Wizker uses the Cordova framework to package Wizkers into a native Android application.  The first thing to do is to install Cordova on your machine:  npm install -g cordova  Then cd to the  dist/cordova-debug  directory and add the target Cordova plaforms of your choice, and build, for instance:  cordova platform add Android\ncordova build  For further instructions on how to complete the build and install on your device, please refer to the  Cordova documentation  online.", 
            "title": "Cordova (Android and/or iOS app)"
        }, 
        {
            "location": "/building/#server", 
            "text": "The server build of Wizkers is available in  dist/server . Simply go to that directory and launch the server:  cd dist/server\n./start-server.sh", 
            "title": "Server"
        }, 
        {
            "location": "/deploying/", 
            "text": "Deploy Wizkers as a server application\n\n\nWizkers runs great as a server application. In that mode, you access Wizkers through a standard browser (Google Chrome being the reference browser for our tests).\n\n\nThis section describes the various database backends you can select when running Wizkers, as well as how you should configure it with reverse proxies like nginx.\n\n\nSelecting the database\n\n\nWizkers will run fine out of the box with no particular additional configuration: a simple\n\n\ngulp server\ncd dist/server\nnode server.js\n\n\n\n\nwill be enough to get you started. In that mode, Wizkers will use a disk database called LevelDB which is the default storage mechanism for PouchDB, the internal Wizkers database API.\n\n\nFor larger deployments where you have potentially dozens or more sensors connected at once, levelDB will not be adequate, which is why Wizkers also supports standard CouchDB servers.\n\n\nThe database engine is selected in \nserver/pouchdb-config.js\n with the \nbackend\n variable. Set it to \nCouchDB\n to use CouchDB rather than PouchDB (which is the default).\n\n\nvar backend = 'CouchDB';\n\n\n\n\nDo not forget to run \ngulp server\n again after making a change.\n\n\nConfiguring CouchDB\n\n\nPlease head over to the \nCouchDB documentation\n for details on how to install CouchDB on your particular machine. Most Linux distributions already include Couch in their standard packages, so this should be very easy.\n\n\nBy default, CouchDB binds to the 127.0.0.1 interface, and lets anyone connect to it with no authentication. You probably do not want this for a production system, and should take the appropriate steps to secure your installation. For development purposes, this should be fine, though.\n\n\nThe only Wizkers-specific configuration you should do on CouchDB (and this can become critical for large number of connected sensors), is configure the auto_compaction daemon so that there are no runaway databases due to frequent document updates. This can be done from the admin interface of couchdb at \nhttp://127.0.0.1:5984/_utils\n. From this interface, head over to \"configuration\" (menu on the right) and add the configuration for compactions: at the bottom of the page, click on the \"add a new section\" link, and enter the following:\n\n\n\n\nSection: compactions\n\n\nOption:  _default\n\n\nvalue: \n[{db_fragmentation, \"70%\"}, {view_fragmentation, \"60%\"}]\n\n\n\n\n\n\nThis way, CouchDB will make sure that even with frequent document updates, the overall database size does not get out of hand.\n\n\nMigrating from Pouch to Couch\n\n\nIf you started your deployment with PouchDB and later decided to migrate to CouchDB, a script in the \nserver/utils\n directory will automatically migrate all your data and settings to CouchDB.\n\n\nFirst of all, make sure Wizkers is not running. Then go to \ndist/server/utils\n and launch \nnode migrate_to_couchdb.js\n. The process should take from a couple of seconds to a couple of minutes depending on how much data you have in your database.\n\n\nLast, make sure that the \nbackend\n variable in \ndist/server/pouchdb-config.jg\n is set to \nCouchDB\n, then relaunch Wizkers. You should be able to login exactly like before.\n\n\nWizkers auto start\n\n\nOn a Linux distribution, you will probably want to have Wizkers automatically start when the device/computer boots. The init scripts below give you an example of how to do this. Tweak as needed!\n\n\nOn recent Ubuntu distributions, you will need to create a \n/etc/init/wizkers.conf\n script. Note that you can enable debugging output in \n/tmp\n or not, this is optional...\n\n\n# Ubuntu upstart file at /etc/init/wizkers.conf\n\nstart on runlevel [2345]\nstop on runlevel [06]\n\nsetuid ubuntu\n\nscript\n  export HOME=\n/home/ubuntu/wizkers/server/dist/server\n\n  ENABLE_CONTROLLER=\nyes\n\n  export DEBUG=\nwizkers*\n\n  DAEMON_ARGS=\n/home/ubuntu/wizkers/server/dist/server/server.js\n\n  if [ -f /etc/default/wizkers ]; then . /etc/default/wizkers; fi\n  if [ \nx$ENABLE_CONTROLLER\n = \nxyes\n ]; then cd $HOME; exec node $DAEMON_ARGS \n /tmp/wizkers.log 2\n1 ; fi\nend script\n\n\n\n\nWizkers behind a proxy\n\n\nIn a production environment, you will want to run Wizkers behind a web server that will be running on port 80. NGINX or just Apache 2 are two good choices:\n\n\nNGINX\n\n\nTo be detailed\n\n\nApache2\n\n\nOn Apache2, a 'sites-available' configuration that is adequate to run Wizkers is as follows. This works for Apache 2.4 + with mod rewrite and mod proxy enabled. The trick being to handle socket.io in websockets mode without having it fall back into http polling mode:\n\n\n# Setup for Wizkers\n\nVirtualHost *:80\n\n\n    ServerAlias *\n\n    RewriteEngine On\n    RewriteCond %{REQUEST_URI}  ^/socket.io            [NC]\n    RewriteCond %{QUERY_STRING} transport=websocket    [NC]\n    RewriteRule /(.*)           ws://localhost:8090/$1 [P,L]\n\n    ProxyPass /aprs !\n    ProxyPass / http://localhost:8090/\n    ProxyPassReverse / http://localhost:8090/\n\n\n/VirtualHost", 
            "title": "Deploying (server)"
        }, 
        {
            "location": "/deploying/#deploy-wizkers-as-a-server-application", 
            "text": "Wizkers runs great as a server application. In that mode, you access Wizkers through a standard browser (Google Chrome being the reference browser for our tests).  This section describes the various database backends you can select when running Wizkers, as well as how you should configure it with reverse proxies like nginx.", 
            "title": "Deploy Wizkers as a server application"
        }, 
        {
            "location": "/deploying/#selecting-the-database", 
            "text": "Wizkers will run fine out of the box with no particular additional configuration: a simple  gulp server\ncd dist/server\nnode server.js  will be enough to get you started. In that mode, Wizkers will use a disk database called LevelDB which is the default storage mechanism for PouchDB, the internal Wizkers database API.  For larger deployments where you have potentially dozens or more sensors connected at once, levelDB will not be adequate, which is why Wizkers also supports standard CouchDB servers.  The database engine is selected in  server/pouchdb-config.js  with the  backend  variable. Set it to  CouchDB  to use CouchDB rather than PouchDB (which is the default).  var backend = 'CouchDB';  Do not forget to run  gulp server  again after making a change.", 
            "title": "Selecting the database"
        }, 
        {
            "location": "/deploying/#configuring-couchdb", 
            "text": "Please head over to the  CouchDB documentation  for details on how to install CouchDB on your particular machine. Most Linux distributions already include Couch in their standard packages, so this should be very easy.  By default, CouchDB binds to the 127.0.0.1 interface, and lets anyone connect to it with no authentication. You probably do not want this for a production system, and should take the appropriate steps to secure your installation. For development purposes, this should be fine, though.  The only Wizkers-specific configuration you should do on CouchDB (and this can become critical for large number of connected sensors), is configure the auto_compaction daemon so that there are no runaway databases due to frequent document updates. This can be done from the admin interface of couchdb at  http://127.0.0.1:5984/_utils . From this interface, head over to \"configuration\" (menu on the right) and add the configuration for compactions: at the bottom of the page, click on the \"add a new section\" link, and enter the following:   Section: compactions  Option:  _default  value:  [{db_fragmentation, \"70%\"}, {view_fragmentation, \"60%\"}]    This way, CouchDB will make sure that even with frequent document updates, the overall database size does not get out of hand.", 
            "title": "Configuring CouchDB"
        }, 
        {
            "location": "/deploying/#migrating-from-pouch-to-couch", 
            "text": "If you started your deployment with PouchDB and later decided to migrate to CouchDB, a script in the  server/utils  directory will automatically migrate all your data and settings to CouchDB.  First of all, make sure Wizkers is not running. Then go to  dist/server/utils  and launch  node migrate_to_couchdb.js . The process should take from a couple of seconds to a couple of minutes depending on how much data you have in your database.  Last, make sure that the  backend  variable in  dist/server/pouchdb-config.jg  is set to  CouchDB , then relaunch Wizkers. You should be able to login exactly like before.", 
            "title": "Migrating from Pouch to Couch"
        }, 
        {
            "location": "/deploying/#wizkers-auto-start", 
            "text": "On a Linux distribution, you will probably want to have Wizkers automatically start when the device/computer boots. The init scripts below give you an example of how to do this. Tweak as needed!  On recent Ubuntu distributions, you will need to create a  /etc/init/wizkers.conf  script. Note that you can enable debugging output in  /tmp  or not, this is optional...  # Ubuntu upstart file at /etc/init/wizkers.conf\n\nstart on runlevel [2345]\nstop on runlevel [06]\n\nsetuid ubuntu\n\nscript\n  export HOME= /home/ubuntu/wizkers/server/dist/server \n  ENABLE_CONTROLLER= yes \n  export DEBUG= wizkers* \n  DAEMON_ARGS= /home/ubuntu/wizkers/server/dist/server/server.js \n  if [ -f /etc/default/wizkers ]; then . /etc/default/wizkers; fi\n  if [  x$ENABLE_CONTROLLER  =  xyes  ]; then cd $HOME; exec node $DAEMON_ARGS   /tmp/wizkers.log 2 1 ; fi\nend script", 
            "title": "Wizkers auto start"
        }, 
        {
            "location": "/deploying/#wizkers-behind-a-proxy", 
            "text": "In a production environment, you will want to run Wizkers behind a web server that will be running on port 80. NGINX or just Apache 2 are two good choices:", 
            "title": "Wizkers behind a proxy"
        }, 
        {
            "location": "/deploying/#nginx", 
            "text": "To be detailed", 
            "title": "NGINX"
        }, 
        {
            "location": "/deploying/#apache2", 
            "text": "On Apache2, a 'sites-available' configuration that is adequate to run Wizkers is as follows. This works for Apache 2.4 + with mod rewrite and mod proxy enabled. The trick being to handle socket.io in websockets mode without having it fall back into http polling mode:  # Setup for Wizkers VirtualHost *:80 \n\n    ServerAlias *\n\n    RewriteEngine On\n    RewriteCond %{REQUEST_URI}  ^/socket.io            [NC]\n    RewriteCond %{QUERY_STRING} transport=websocket    [NC]\n    RewriteRule /(.*)           ws://localhost:8090/$1 [P,L]\n\n    ProxyPass /aprs !\n    ProxyPass / http://localhost:8090/\n    ProxyPassReverse / http://localhost:8090/ /VirtualHost", 
            "title": "Apache2"
        }, 
        {
            "location": "/dev/connections/", 
            "text": "Connections\n\n\nConnections are the low-level hardware drivers which connect instrument drivers to the actual instruments. They can be serial ports, Bluetooth, network sockets, etc. depending on the instrument type.\n\n\nFrom an architecture standpoint, connections are created and managed by instrument backend drivers (\nwizkers/server/www/js/app/instruments/XXX/backend_driver.js\n in Chrome/Cordova mode and \nwizkers/server/server/parsers\n in server mode). The backend driver listens to the various events coming from the low level drivers.\n\n\nAll modes\n\n\nAll connections implement the following API:\n\n\n\n\nopen\n\n\nclose\n\n\nwrite\n\n\n(optional) \nread\n\n\n(optional) \nflush\n\n\n\n\nAnd connections emit the \ndata\n event whenever there is data ready to be sent to the upper level driver.\n\n\nConnection configuration\n\n\nEach connection type should also provide a configuration view, located in \nwizkers/server/www/js/app/views/instruments/\n, along with a template in \nwizkers/server/www/js/tpl/connections\n. You can refer to the structure of existing connections to get a clearer understanding of how they work.\n\n\nMaking a new connection available to instruments\n\n\nIn Chrome/Cordova mode, a new connection is connected to the rest of the Wizkers codebase by refering to it in \nwizkers/server/www/js/app/instruments/connectionmanager.js\n as part of the instrument plugin setup.\n\n\nIn server mode, new connections are used directly by instrument backend-drivers (in \nwizkers/server/server/parsers\n).\n\n\nConnection support by mode\n\n\n\n\n\n\n\n\nConnection type\n\n\nChrome\n\n\nCordova\n\n\nServer\n\n\nComment\n\n\n\n\n\n\n\n\n\n\nSerial\n\n\nYes\n\n\nYes\n\n\nYes\n\n\nStandard serial ports (incl. serial over USB)\n\n\n\n\n\n\nTCP/IP Sockets\n\n\nYes\n\n\nNo\n\n\nNo\n\n\nSerial over TCP sockets\n\n\n\n\n\n\nUSB HID\n\n\nYes\n\n\nNo\n\n\nNo\n\n\nUSB HID communications.\n\n\n\n\n\n\nHelium\n\n\nNo\n\n\nNo\n\n\nYes\n\n\nNetwork connection to the \nhelium.com\n IoT network.\n\n\n\n\n\n\nPinocc.io\n\n\nNo\n\n\nNo\n\n\nYes\n\n\nNetwork connection to the Pinocc.io IoT network\n\n\n\n\n\n\nBluetooth LE\n\n\nYes\n\n\nYes\n\n\nNo\n\n\nChrome support on Chromebooks only\n\n\n\n\n\n\nWebRTC\n\n\nYes\n\n\nNot tested\n\n\nNo\n\n\nConnection over a WebRTC data channel (using the \npeerjs.com\n library)\n\n\n\n\n\n\n\n\nSerial Connection\n\n\nThe  serial connection is the first that was supported in Wizkers. It works in every mode (Server, Android/Cordova, Chrome) and provides access to any serial device that is connected to the computer.\n\n\nSerial over TCP/IP Sockets\n\n\nThis is accessible in Chrome mode only for now. TCP/IP sockets are an extension to the serial connection, and are managed along with the serial connection (this adds an extra entry in the serial port dropdown). You will have to explicitely add support for this on your instrument's backend driver, like you can see here: \nwww/js/app/instruments/elecraft/backend_driver.js\n.\n\n\nUSB HID Connection\n\n\nThis connection type is only supported in Chrome packaged app mode at the moment (0.9.3). It provides read/write access to generic USB HID devices through the usual connection API.\n\n\nDue to the nature of USB HID, which is a polling system, you will need to call the \u201cread\u201d method on the driver to get data from the device. You can look at the Sark110 backend driver in \nwww/js/app/instruments/sark110/backend_driver.js\n for an example of how this can be implemented.\n\n\nHelium connection\n\n\nThis connection is only supported in server mode. It establishes a 'subscription' to a device on the Helium.com netword, and supports the usual write/open/close methods. Data is automatically sent through the 'data' event.\n\n\nPinocc.io connection\n\n\nLikewise, the Pinocc.io plugin lets you talk and receive data from devices connected to the Pinocc.io IoT network.\n\n\nNote:\n the Pinocc.io network is now obsolete, and a standalone \npinoccio-server.js\n alternative makes it possible to use Pinocc.io devices without the Pinocc.io IoT backend.\n\n\nBluetooth LE connection\n\n\nThis connection is supported on Chromebooks only because of a Chrome runtime limitation (August 2015)\n\n\nWebRTC\n\n\nThis connection should work on both Chrome and Cordova, but is only tested on Chrome. This is very experimental.", 
            "title": "Connections"
        }, 
        {
            "location": "/dev/connections/#connections", 
            "text": "Connections are the low-level hardware drivers which connect instrument drivers to the actual instruments. They can be serial ports, Bluetooth, network sockets, etc. depending on the instrument type.  From an architecture standpoint, connections are created and managed by instrument backend drivers ( wizkers/server/www/js/app/instruments/XXX/backend_driver.js  in Chrome/Cordova mode and  wizkers/server/server/parsers  in server mode). The backend driver listens to the various events coming from the low level drivers.", 
            "title": "Connections"
        }, 
        {
            "location": "/dev/connections/#all-modes", 
            "text": "All connections implement the following API:   open  close  write  (optional)  read  (optional)  flush   And connections emit the  data  event whenever there is data ready to be sent to the upper level driver.", 
            "title": "All modes"
        }, 
        {
            "location": "/dev/connections/#connection-configuration", 
            "text": "Each connection type should also provide a configuration view, located in  wizkers/server/www/js/app/views/instruments/ , along with a template in  wizkers/server/www/js/tpl/connections . You can refer to the structure of existing connections to get a clearer understanding of how they work.", 
            "title": "Connection configuration"
        }, 
        {
            "location": "/dev/connections/#making-a-new-connection-available-to-instruments", 
            "text": "In Chrome/Cordova mode, a new connection is connected to the rest of the Wizkers codebase by refering to it in  wizkers/server/www/js/app/instruments/connectionmanager.js  as part of the instrument plugin setup.  In server mode, new connections are used directly by instrument backend-drivers (in  wizkers/server/server/parsers ).", 
            "title": "Making a new connection available to instruments"
        }, 
        {
            "location": "/dev/connections/#connection-support-by-mode", 
            "text": "Connection type  Chrome  Cordova  Server  Comment      Serial  Yes  Yes  Yes  Standard serial ports (incl. serial over USB)    TCP/IP Sockets  Yes  No  No  Serial over TCP sockets    USB HID  Yes  No  No  USB HID communications.    Helium  No  No  Yes  Network connection to the  helium.com  IoT network.    Pinocc.io  No  No  Yes  Network connection to the Pinocc.io IoT network    Bluetooth LE  Yes  Yes  No  Chrome support on Chromebooks only    WebRTC  Yes  Not tested  No  Connection over a WebRTC data channel (using the  peerjs.com  library)", 
            "title": "Connection support by mode"
        }, 
        {
            "location": "/dev/connections/#serial-connection", 
            "text": "The  serial connection is the first that was supported in Wizkers. It works in every mode (Server, Android/Cordova, Chrome) and provides access to any serial device that is connected to the computer.", 
            "title": "Serial Connection"
        }, 
        {
            "location": "/dev/connections/#serial-over-tcpip-sockets", 
            "text": "This is accessible in Chrome mode only for now. TCP/IP sockets are an extension to the serial connection, and are managed along with the serial connection (this adds an extra entry in the serial port dropdown). You will have to explicitely add support for this on your instrument's backend driver, like you can see here:  www/js/app/instruments/elecraft/backend_driver.js .", 
            "title": "Serial over TCP/IP Sockets"
        }, 
        {
            "location": "/dev/connections/#usb-hid-connection", 
            "text": "This connection type is only supported in Chrome packaged app mode at the moment (0.9.3). It provides read/write access to generic USB HID devices through the usual connection API.  Due to the nature of USB HID, which is a polling system, you will need to call the \u201cread\u201d method on the driver to get data from the device. You can look at the Sark110 backend driver in  www/js/app/instruments/sark110/backend_driver.js  for an example of how this can be implemented.", 
            "title": "USB HID Connection"
        }, 
        {
            "location": "/dev/connections/#helium-connection", 
            "text": "This connection is only supported in server mode. It establishes a 'subscription' to a device on the Helium.com netword, and supports the usual write/open/close methods. Data is automatically sent through the 'data' event.", 
            "title": "Helium connection"
        }, 
        {
            "location": "/dev/connections/#pinoccio-connection", 
            "text": "Likewise, the Pinocc.io plugin lets you talk and receive data from devices connected to the Pinocc.io IoT network.  Note:  the Pinocc.io network is now obsolete, and a standalone  pinoccio-server.js  alternative makes it possible to use Pinocc.io devices without the Pinocc.io IoT backend.", 
            "title": "Pinocc.io connection"
        }, 
        {
            "location": "/dev/connections/#bluetooth-le-connection", 
            "text": "This connection is supported on Chromebooks only because of a Chrome runtime limitation (August 2015)", 
            "title": "Bluetooth LE connection"
        }, 
        {
            "location": "/dev/connections/#webrtc", 
            "text": "This connection should work on both Chrome and Cordova, but is only tested on Chrome. This is very experimental.", 
            "title": "WebRTC"
        }, 
        {
            "location": "/dev/instruments/", 
            "text": "Adding a new instrument\n\n\nThe basic structure\n\n\nInstrument plugins are stored in \nwizkers/server/www/js/app/instruments\n. Each instrument plugin is made of the following:\n\n\nIn every run mode:\n\n\n\n\nicon.png\n should be a 350x350px icon representing the instrument\n\n\ninstrument.js\n . The main plugin entry point: defines what capabilities the instrument has, and the path to the other plugin files.\n\n\ndriver_frontend.js\n The front-end driver, which runs in the browser\n\n\nsettings.js\n  Instruments specific settings screen (displayed in the \"instrument details\" view)\n\n\ndisplay_live.js\n The main \"live\" visualization. Can be as simple as a graph, or as sophisticated as the Elecraft KX3 controller\n\n\ndisplay_numeric.js\n The right side visualization\n\n\ndisplay_diag.js\n The interface for instrument configuration\n\n\ndisplay_.log.js\n Log visualization interface, usually similar to \u2018display_live\u2019\n\n\ndisplay_logmanager.js\n  Interface to manage and download on-device logs, if supported\n\n\ndisplay_logedit.js\n Interface to manage editing log contents directly on Wizkers (optional)\n\n\n\n\nAll these files can be optional, depending on the capabilities you want to implement in your instrument.\n\n\nIn Chrome and Cordova mode, you will also need to add the following:\n\n\n\n\ndriver_backend.js\n The back-end driver: the low-level driver for the instrument, which forwards its data to the front-end driver.\n\n\n\n\nIn server mode, the backend driver lives in \nwizkers/server/server/parsers/\n . Usually, the Chrome/Cordova \ndriver_backend.js\n and the \nparsers/instrument_backend.js\n are similar, though the server-mode low level drivers tend to make use of the NodeJS buffer objects whereas the Chrome version uses pure Javascript ArrayBuffers.\n\n\nThis list might seem a bit overwhelming, but there are already many instruments defined in Wizkers, and you should definitely start a new instrument by 'borrowing' from an existing intrument, rather than restart everything from scratch. Wizkers also contains a \nwizkers/server/www/js/app/instruments/sample_instrument\n which is a sample instrument scaffolding and can be used to quickly add a new instrument.\n\n\nConnecting your instrument plugin to the rest of Wizkers\n\n\nOnce you have implemented those files, you will need to add a reference to the main plugin file (instrument.js) in \nserver/www/js/app/instruments/instrumentmanager.js\n.\n\n\nIn server mode, you will also need to add a reference to the parser in \nwizkers/server/server/connectionmanager.js\n to make it available on the server.\n\n\nInstrument view templates\n\n\nAll templates are stored in \nwizkers/server/www/js/tpl\n. The best practice for new instruments is to add new templates in \nwww/js/tpl/instruments/instrument_name/XXX.html\n.\n\n\nWizkers uses the basic BackboneJS \"handlebars\" template style.", 
            "title": "Instruments"
        }, 
        {
            "location": "/dev/instruments/#adding-a-new-instrument", 
            "text": "", 
            "title": "Adding a new instrument"
        }, 
        {
            "location": "/dev/instruments/#the-basic-structure", 
            "text": "Instrument plugins are stored in  wizkers/server/www/js/app/instruments . Each instrument plugin is made of the following:  In every run mode:   icon.png  should be a 350x350px icon representing the instrument  instrument.js  . The main plugin entry point: defines what capabilities the instrument has, and the path to the other plugin files.  driver_frontend.js  The front-end driver, which runs in the browser  settings.js   Instruments specific settings screen (displayed in the \"instrument details\" view)  display_live.js  The main \"live\" visualization. Can be as simple as a graph, or as sophisticated as the Elecraft KX3 controller  display_numeric.js  The right side visualization  display_diag.js  The interface for instrument configuration  display_.log.js  Log visualization interface, usually similar to \u2018display_live\u2019  display_logmanager.js   Interface to manage and download on-device logs, if supported  display_logedit.js  Interface to manage editing log contents directly on Wizkers (optional)   All these files can be optional, depending on the capabilities you want to implement in your instrument.  In Chrome and Cordova mode, you will also need to add the following:   driver_backend.js  The back-end driver: the low-level driver for the instrument, which forwards its data to the front-end driver.   In server mode, the backend driver lives in  wizkers/server/server/parsers/  . Usually, the Chrome/Cordova  driver_backend.js  and the  parsers/instrument_backend.js  are similar, though the server-mode low level drivers tend to make use of the NodeJS buffer objects whereas the Chrome version uses pure Javascript ArrayBuffers.  This list might seem a bit overwhelming, but there are already many instruments defined in Wizkers, and you should definitely start a new instrument by 'borrowing' from an existing intrument, rather than restart everything from scratch. Wizkers also contains a  wizkers/server/www/js/app/instruments/sample_instrument  which is a sample instrument scaffolding and can be used to quickly add a new instrument.", 
            "title": "The basic structure"
        }, 
        {
            "location": "/dev/instruments/#connecting-your-instrument-plugin-to-the-rest-of-wizkers", 
            "text": "Once you have implemented those files, you will need to add a reference to the main plugin file (instrument.js) in  server/www/js/app/instruments/instrumentmanager.js .  In server mode, you will also need to add a reference to the parser in  wizkers/server/server/connectionmanager.js  to make it available on the server.", 
            "title": "Connecting your instrument plugin to the rest of Wizkers"
        }, 
        {
            "location": "/dev/instruments/#instrument-view-templates", 
            "text": "All templates are stored in  wizkers/server/www/js/tpl . The best practice for new instruments is to add new templates in  www/js/tpl/instruments/instrument_name/XXX.html .  Wizkers uses the basic BackboneJS \"handlebars\" template style.", 
            "title": "Instrument view templates"
        }, 
        {
            "location": "/dev/outputs/", 
            "text": "Outputs\n\n\nOutputs are plugins which subscribe to 'data' events coming from connected instruments, and are able to forward those events to other services. They extend the capabilities of Wizkers a great deal by turning it into a middleware between your sensors and any number of backend services.\n\n\nA typical use case for outputs, is using the \nsafecast\n output to connect a Geiger counter to the \nSafecast.org\n service to send regular radiation readings to the Safecast API.\n\n\nGeneral architecture.\n\n\nDue to the fact Wizkers in server mode supports multiple open devices at once and standalone operation, there are slight differences in the way outputs work in server vs Chrome mode, but a lot of similarities too.\n\n\n\n\nwizkers/server/www/js/app/outputs/\noutput_name\n/logo.png\n is the output logo.\n\n\n\n\nOutput definition\n\n\nOutputs are defined in \nwizkers/server/www/js/app/outputs/\noutput_name\n/\noutput_name\n.js\n. This file defines a couple of high level output characteristics which are used by Wizkers to understand how and when it can be used.\n\n\n\n\nthis.wantOnly\n returns an array of strings that describe the type of data the output will accept. For instance, the \nsafecast.js\n output will return \n['radioactivity']\n so that it does not show up as an available output to devices which don't sent that sort of reading.\n\n\nthis.requestAllData\n is true if the output want Wizkers to send it everything in \"pass through\" mode rather than use the regular/alarm mechanism\n\n\nthis.outputFields\n is the list of fields required by the output to work. The result can be \"variable\" in case the output does not have a fixed number of fields or \"none\" if the output does not support the concept of fields.\n\n\n\n\nFront-end output config\n\n\nOutputs always provide a configuration view, which is located in \nwizkers/server/www/js/app/outputs/\noutput_name\n/settings.js\n. The corresponding template, by convention, lives in \nwizkers/server/www/js/tpl/outputs/\n.\n\n\nThe front-end view is a Backbone view: refer to the existing outputs to get an idea of how to manage output-specific settings, which are merged with general output settings automatically.\n\n\nOutput backend drivers\n\n\nChrome/Cordova mode\n\n\nIn this mode, you want to implement \nwizkers/server/www/js/app/outputs/\noutput_name\n/backend_driver.js\n . The backend driver needs to implement a couple of public methods which are expected by the output manager:\n\n\n\n\nsetup\n\n\nonClose\n\n\nresolveMapping\n\n\nsendData\n\n\n\n\nServer mode\n\n\nIn server mode, output backends live in \nwizkers/server/server/outputs/\n and implement the same API as in Chrome/Cordova mode. Since the outputs are executed in a NodeJS environment, they often use different low-level APIs which is the reason why they are separate from the 'app mode' output code.", 
            "title": "Outputs"
        }, 
        {
            "location": "/dev/outputs/#outputs", 
            "text": "Outputs are plugins which subscribe to 'data' events coming from connected instruments, and are able to forward those events to other services. They extend the capabilities of Wizkers a great deal by turning it into a middleware between your sensors and any number of backend services.  A typical use case for outputs, is using the  safecast  output to connect a Geiger counter to the  Safecast.org  service to send regular radiation readings to the Safecast API.", 
            "title": "Outputs"
        }, 
        {
            "location": "/dev/outputs/#general-architecture", 
            "text": "Due to the fact Wizkers in server mode supports multiple open devices at once and standalone operation, there are slight differences in the way outputs work in server vs Chrome mode, but a lot of similarities too.   wizkers/server/www/js/app/outputs/ output_name /logo.png  is the output logo.", 
            "title": "General architecture."
        }, 
        {
            "location": "/dev/outputs/#output-definition", 
            "text": "Outputs are defined in  wizkers/server/www/js/app/outputs/ output_name / output_name .js . This file defines a couple of high level output characteristics which are used by Wizkers to understand how and when it can be used.   this.wantOnly  returns an array of strings that describe the type of data the output will accept. For instance, the  safecast.js  output will return  ['radioactivity']  so that it does not show up as an available output to devices which don't sent that sort of reading.  this.requestAllData  is true if the output want Wizkers to send it everything in \"pass through\" mode rather than use the regular/alarm mechanism  this.outputFields  is the list of fields required by the output to work. The result can be \"variable\" in case the output does not have a fixed number of fields or \"none\" if the output does not support the concept of fields.", 
            "title": "Output definition"
        }, 
        {
            "location": "/dev/outputs/#front-end-output-config", 
            "text": "Outputs always provide a configuration view, which is located in  wizkers/server/www/js/app/outputs/ output_name /settings.js . The corresponding template, by convention, lives in  wizkers/server/www/js/tpl/outputs/ .  The front-end view is a Backbone view: refer to the existing outputs to get an idea of how to manage output-specific settings, which are merged with general output settings automatically.", 
            "title": "Front-end output config"
        }, 
        {
            "location": "/dev/outputs/#output-backend-drivers", 
            "text": "", 
            "title": "Output backend drivers"
        }, 
        {
            "location": "/dev/outputs/#chromecordova-mode", 
            "text": "In this mode, you want to implement  wizkers/server/www/js/app/outputs/ output_name /backend_driver.js  . The backend driver needs to implement a couple of public methods which are expected by the output manager:   setup  onClose  resolveMapping  sendData", 
            "title": "Chrome/Cordova mode"
        }, 
        {
            "location": "/dev/outputs/#server-mode", 
            "text": "In server mode, output backends live in  wizkers/server/server/outputs/  and implement the same API as in Chrome/Cordova mode. Since the outputs are executed in a NodeJS environment, they often use different low-level APIs which is the reason why they are separate from the 'app mode' output code.", 
            "title": "Server mode"
        }, 
        {
            "location": "/dev/debugging/", 
            "text": "Debugging Wizkers\n\n\nDepending on the run mode of Wizkers, several options are available to you:\n\n\nChrome app\n\n\nThe best way to debug Mouse Wizkers is to use the Developer tools in Chrome. You can simply load the Wizkers chrome app manually by going to the \u201cExtensions\u201d menu in Chrome, and use \u201cLoad Unpacked Extension\u2026\u201d and make it point to the the \u201cserver\u201d directory.\n\n\n\n\nThis will start Mouse Wizkers with all developer tools enabled (which is not the case in the Chrome Store version where those are disabled).\n\n\nYou can then fire up the Chrome developer tools and do complete debugging of Wizkers by clicking on the \"Inspect views:\" links as shown below:\n\n\n\n\nServer mode\n\n\nIn server mode, Wizkers uses the Node.js \u201cdebug\u201d facility: simply define a \u201cDEBUG\u201d variable to enable debug output. All modules in Wizkers already define a unique debug name, so you get fairly fine grained output. You can try a \u201cDEBUG=* node server.js\u201d to get an idea of the maximum level of debug output you can get.\n\n\nUsing node-inspector\n\n\nYou can also debug the server side using the Chrome debugger, thanks to \nnode-inspector\n. This gives your nearly the same ease of debugging as doing everything browser-side.\n\n\nYou can install node-inspector by visiting \ngithub\n and following the instructions.\n\n\nAndroid application\n\n\nYou can also use Chrome to debug Wizkers running as an Android application: you need to have the Android SDK installed on your computer, and your test device connected through USB using \nadb\n.\n\n\nNetwork debugging of Android\n\n\nSince Wizkers lets you use the USB port of your Android device to connect to various kinds of instruments, you will often end up in situatino where you cannot do USB debugging. This is not a problem, since adb can also work on the network. You still need to link your Android device to the adb server on your computer through USB once:\n\n\n$ adb tcpip 5555\n\n\n\n\nThen you can disconnect the Android device from USB, and connect through the Wifi network:\n\n\n$ adb connect \ndevice-ip-address\n\n\n\n\n\nThe Chrome Webview contained in Wizkers will then start showing up on Chrome's \nchrome://inspect\n screen.", 
            "title": "Debugging"
        }, 
        {
            "location": "/dev/debugging/#debugging-wizkers", 
            "text": "Depending on the run mode of Wizkers, several options are available to you:", 
            "title": "Debugging Wizkers"
        }, 
        {
            "location": "/dev/debugging/#chrome-app", 
            "text": "The best way to debug Mouse Wizkers is to use the Developer tools in Chrome. You can simply load the Wizkers chrome app manually by going to the \u201cExtensions\u201d menu in Chrome, and use \u201cLoad Unpacked Extension\u2026\u201d and make it point to the the \u201cserver\u201d directory.   This will start Mouse Wizkers with all developer tools enabled (which is not the case in the Chrome Store version where those are disabled).  You can then fire up the Chrome developer tools and do complete debugging of Wizkers by clicking on the \"Inspect views:\" links as shown below:", 
            "title": "Chrome app"
        }, 
        {
            "location": "/dev/debugging/#server-mode", 
            "text": "In server mode, Wizkers uses the Node.js \u201cdebug\u201d facility: simply define a \u201cDEBUG\u201d variable to enable debug output. All modules in Wizkers already define a unique debug name, so you get fairly fine grained output. You can try a \u201cDEBUG=* node server.js\u201d to get an idea of the maximum level of debug output you can get.", 
            "title": "Server mode"
        }, 
        {
            "location": "/dev/debugging/#using-node-inspector", 
            "text": "You can also debug the server side using the Chrome debugger, thanks to  node-inspector . This gives your nearly the same ease of debugging as doing everything browser-side.  You can install node-inspector by visiting  github  and following the instructions.", 
            "title": "Using node-inspector"
        }, 
        {
            "location": "/dev/debugging/#android-application", 
            "text": "You can also use Chrome to debug Wizkers running as an Android application: you need to have the Android SDK installed on your computer, and your test device connected through USB using  adb .", 
            "title": "Android application"
        }, 
        {
            "location": "/dev/debugging/#network-debugging-of-android", 
            "text": "Since Wizkers lets you use the USB port of your Android device to connect to various kinds of instruments, you will often end up in situatino where you cannot do USB debugging. This is not a problem, since adb can also work on the network. You still need to link your Android device to the adb server on your computer through USB once:  $ adb tcpip 5555  Then you can disconnect the Android device from USB, and connect through the Wifi network:  $ adb connect  device-ip-address   The Chrome Webview contained in Wizkers will then start showing up on Chrome's  chrome://inspect  screen.", 
            "title": "Network debugging of Android"
        }, 
        {
            "location": "/dev/api/", 
            "text": "Wizkers API access in server mode\n\n\nWhen running on a server, you can also interact with it using a REST API, so that all the data from the server can be queried/streamed to external systems.\n\n\nLive recording\n\n\nWizkers exposes a public \"live recording\" API, which lets you query data that is currently being recorded. The syntax is as follows\n\n\n/live/:id/:period\n with \nid\n being the instrument ID, and \nperiod\n being in minutes - get the live recording for the last \nperiod\n minutes.\n\n\nLow level API access\n\n\nYou can access the low level RESTFUL API of Wizkers using the standard authentication mechanism that is used by the Wizkers front-end web app. The simple Shell script below demonstrates how to get a list of instruments in JSON format.\n\n\n#!/bin/sh\n\n## Example of Wizkers authentication then API request\n\n## Save cookies to the \ncookies.txt\n file\ncurl --cookie-jar cookies.txt -H \nContent-Type: application/json\n -X POST http://localhost:8090/login -d \n{\\\nemail\\\n: \\\nadmin\\\n, \\\npassword\\\n: \\\nabc123\\\n}\n\n\n## Now you can do queries:\ncurl --cookie cookies.txt -X GET http://localhost:8090/instruments\n\n\n\n\nListing instruments\n\n\nYou can get a list of all instruments registered in a Wizkers instance by doing an HTTP GET to /instruments/ . Note that this returns all instruments contents, not only a list of references. \n\n\nExample below:\n\n\n[\n    {\n    \nname\n:\nPiglet\n,\n    \ntype\n:\nsimple_serial\n,\n    \ntag\n:\n,\n    \nuuid\n:\n00000000 (n.a.)\n,\n    \nport\n:\n/dev/cu.usbserial-FTGDPEGI\n,\n    \ncomment\n:\nenter your notes here\n,\n    \nicon\n:\n,\n    \nliveviewspan\n:600,\n    \nliveviewperiod\n:1,\n    \nliveviewlogscale\n:false,\n    \nmetadata\n:{\nbaudrate\n:\n9600\n,\nlines\n:\n40\n},\n    \n_id\n:\n5AD6B170-A8AC-820E-9070-6DB9619661C4\n,\n    \n_rev\n:\n19-5199b8924f8388771d32d13f0b26c508\n\n    },\n    {\n    \nname\n:\nOLED\n,\n    \ntype\n:\nfcoledv1\n,\n    \ntag\n:\n,\n    \nuuid\n:\n00000000 (n.a.)\n,\n    \nport\n:\n/dev/cu.usbmodem14121\n,\n    \ncomment\n:\nenter your notes here\n,\n    \nicon\n:\n,\n    \nliveviewspan\n:600,\n    \nliveviewperiod\n:1,\n    \nliveviewlogscale\n:false,\n    \nmetadata\n:{},\n    \n_id\n:\n6C8BCEB8-77C7-DF73-930A-3DEA48992119\n,\n    \n_rev\n:\n3-643fc192e8094b885f0b29c4f944e8f3\n\n    },\n    {\n    \nname\n:\nFCOLED\n,\n    \ntype\n:\nfcoledv1\n,\n    \ntag\n:\n,\n    \nuuid\n:\n00000000 (n.a.)\n,\n    \nport\n:\n/dev/cu.usbmodem1451\n,\n    \ncomment\n:\nenter your notes here\n,\n    \nicon\n:\n,\n    \nliveviewspan\n:600,\n    \nliveviewperiod\n:1,\n    \nliveviewlogscale\n:false,\n    \nmetadata\n:{},\n    \n_id\n:\n8E7A801E-8AD1-FB5C-B772-CABA61B8FCC6\n,\n    \n_rev\n:\n7-13d2c6309ffeab1bcf87833fae563764\n\n    },\n]\n\n\n\n\nInstruments details\n\n\nReturns one instrument's details (http GET):\n\n\nhttp://localhost:8090/instruments/6C8BCEB8-77C7-DF73-930A-3DEA48992119\n\n\nListing logs for an instrument\n\n\nYou can get all the logs for a given instrument by doing a GET on /logs :\n\n\nhttp://localhost:8090/instruments/E1B65550-BEA8-63BB-9AFA-58F94E0D881D/logs\n\n\n[\n    {\n    \ninstrumentid\n:\nE1B65550-BEA8-63BB-9AFA-58F94E0D881D\n,    \n    \nname\n:\nAutorecord\n,\n    \ndescription\n:\nAutorecord\n,\n    \nlogtype\n:\nlive\n,\n    \nstartstamp\n:1437430818782.795,\n    \nisrecording\n:false,\n    \ndatapoints\n:11,\n    \nswversion\n:0,\n    \nendstamp\n:1437431082121.264,\n    \n_id\n:\n4E148536-1F12-8F85-AF9B-6E48401F030C\n,\n    \n_rev\n:\n5-ef4df5e4f9a9e85e26252cbfc175706f\n\n    }\n]\n\n\n\n\nLog download\n\n\nThe contents of a log are returned with (http GET):\n\n\nhttp://localhost:8090/logs/4E148536-1F12-8F85-AF9B-6E48401F030C/entries\n\n\nEach log record contains two keys:\n\n\n\n\ntimestamp: javascript timestamp (milliseconds since January 1 1970). Time when the entry was added to the log. Sometimes (esp for on-intrument log download), the timestamp in the 'data' key will be more important.\n\n\ndata : structure depends on the instrument.\n\n\n\n\n[\n    {\n       \ntimestamp\n:1437430818782.795,\n       \ndata\n:{\nuniqueID\n:\n00000000 (n.a.)\n},\n       \n_id\n:\n1437430818782.795\n\n    },\n    {\n        \ntimestamp\n:1437430878351.307,\n        \ndata\n:{\n            \nprobeid\n:3001739,\n            \ntimestamp\n:25544,\n            \ndevicestamp\n:1437426924000,\n            \ncpm\n:{\n                \nvalue\n:0,\n                \nvalid\n:true\n            },\n            \ncpm2\n:{\n                 \nvalue\n:0,\n                 \nvalid\n:true\n                }\n        },\n        \n_id\n:\n1437430878351.307\n\n    },\n    {\n        \ntimestamp\n:1437430878351.7,\n        \ndata\n:{\n           ...\n        },\n        \n_id\n:\n1437430878351.7\n\n    }\n\n....\n\n    ]", 
            "title": "API Access"
        }, 
        {
            "location": "/dev/api/#wizkers-api-access-in-server-mode", 
            "text": "When running on a server, you can also interact with it using a REST API, so that all the data from the server can be queried/streamed to external systems.", 
            "title": "Wizkers API access in server mode"
        }, 
        {
            "location": "/dev/api/#live-recording", 
            "text": "Wizkers exposes a public \"live recording\" API, which lets you query data that is currently being recorded. The syntax is as follows  /live/:id/:period  with  id  being the instrument ID, and  period  being in minutes - get the live recording for the last  period  minutes.", 
            "title": "Live recording"
        }, 
        {
            "location": "/dev/api/#low-level-api-access", 
            "text": "You can access the low level RESTFUL API of Wizkers using the standard authentication mechanism that is used by the Wizkers front-end web app. The simple Shell script below demonstrates how to get a list of instruments in JSON format.  #!/bin/sh\n\n## Example of Wizkers authentication then API request\n\n## Save cookies to the  cookies.txt  file\ncurl --cookie-jar cookies.txt -H  Content-Type: application/json  -X POST http://localhost:8090/login -d  {\\ email\\ : \\ admin\\ , \\ password\\ : \\ abc123\\ } \n\n## Now you can do queries:\ncurl --cookie cookies.txt -X GET http://localhost:8090/instruments", 
            "title": "Low level API access"
        }, 
        {
            "location": "/dev/api/#listing-instruments", 
            "text": "You can get a list of all instruments registered in a Wizkers instance by doing an HTTP GET to /instruments/ . Note that this returns all instruments contents, not only a list of references.   Example below:  [\n    {\n     name : Piglet ,\n     type : simple_serial ,\n     tag : ,\n     uuid : 00000000 (n.a.) ,\n     port : /dev/cu.usbserial-FTGDPEGI ,\n     comment : enter your notes here ,\n     icon : ,\n     liveviewspan :600,\n     liveviewperiod :1,\n     liveviewlogscale :false,\n     metadata :{ baudrate : 9600 , lines : 40 },\n     _id : 5AD6B170-A8AC-820E-9070-6DB9619661C4 ,\n     _rev : 19-5199b8924f8388771d32d13f0b26c508 \n    },\n    {\n     name : OLED ,\n     type : fcoledv1 ,\n     tag : ,\n     uuid : 00000000 (n.a.) ,\n     port : /dev/cu.usbmodem14121 ,\n     comment : enter your notes here ,\n     icon : ,\n     liveviewspan :600,\n     liveviewperiod :1,\n     liveviewlogscale :false,\n     metadata :{},\n     _id : 6C8BCEB8-77C7-DF73-930A-3DEA48992119 ,\n     _rev : 3-643fc192e8094b885f0b29c4f944e8f3 \n    },\n    {\n     name : FCOLED ,\n     type : fcoledv1 ,\n     tag : ,\n     uuid : 00000000 (n.a.) ,\n     port : /dev/cu.usbmodem1451 ,\n     comment : enter your notes here ,\n     icon : ,\n     liveviewspan :600,\n     liveviewperiod :1,\n     liveviewlogscale :false,\n     metadata :{},\n     _id : 8E7A801E-8AD1-FB5C-B772-CABA61B8FCC6 ,\n     _rev : 7-13d2c6309ffeab1bcf87833fae563764 \n    },\n]", 
            "title": "Listing instruments"
        }, 
        {
            "location": "/dev/api/#instruments-details", 
            "text": "Returns one instrument's details (http GET):  http://localhost:8090/instruments/6C8BCEB8-77C7-DF73-930A-3DEA48992119", 
            "title": "Instruments details"
        }, 
        {
            "location": "/dev/api/#listing-logs-for-an-instrument", 
            "text": "You can get all the logs for a given instrument by doing a GET on /logs :  http://localhost:8090/instruments/E1B65550-BEA8-63BB-9AFA-58F94E0D881D/logs  [\n    {\n     instrumentid : E1B65550-BEA8-63BB-9AFA-58F94E0D881D ,    \n     name : Autorecord ,\n     description : Autorecord ,\n     logtype : live ,\n     startstamp :1437430818782.795,\n     isrecording :false,\n     datapoints :11,\n     swversion :0,\n     endstamp :1437431082121.264,\n     _id : 4E148536-1F12-8F85-AF9B-6E48401F030C ,\n     _rev : 5-ef4df5e4f9a9e85e26252cbfc175706f \n    }\n]", 
            "title": "Listing logs for an instrument"
        }, 
        {
            "location": "/dev/api/#log-download", 
            "text": "The contents of a log are returned with (http GET):  http://localhost:8090/logs/4E148536-1F12-8F85-AF9B-6E48401F030C/entries  Each log record contains two keys:   timestamp: javascript timestamp (milliseconds since January 1 1970). Time when the entry was added to the log. Sometimes (esp for on-intrument log download), the timestamp in the 'data' key will be more important.  data : structure depends on the instrument.   [\n    {\n        timestamp :1437430818782.795,\n        data :{ uniqueID : 00000000 (n.a.) },\n        _id : 1437430818782.795 \n    },\n    {\n         timestamp :1437430878351.307,\n         data :{\n             probeid :3001739,\n             timestamp :25544,\n             devicestamp :1437426924000,\n             cpm :{\n                 value :0,\n                 valid :true\n            },\n             cpm2 :{\n                  value :0,\n                  valid :true\n                }\n        },\n         _id : 1437430878351.307 \n    },\n    {\n         timestamp :1437430878351.7,\n         data :{\n           ...\n        },\n         _id : 1437430878351.7 \n    }\n\n....\n\n    ]", 
            "title": "Log download"
        }, 
        {
            "location": "/ins/medcom-onyx/", 
            "text": "Medcom Onyx\n\n\nThe Onyx is a state of the art Geiger counter, based on an Open Source design by \nBunnie Huang\n. What puts it apart from other open source Geiger counter designs, is that the Onyx is built, calibrated and supported by \nInternational Medcom\n, one of the most respected names in the nuclear detection industry.\n\n\nWizkers is the official utility for the Medcom Onxy and is guaranteed to support all its capabilities.\n\n\nWizkers displays the current and historical radiation graph on the main screen, can record the output of the Onyx at any rate, and regularly upload radioactivity values to backend services, including Safecast. Wizkers also support configuring the Onyx, remote calibrations as well as device log data downloads.\n\n\nLast, it also lets you update the firmware of the Onyx.\n\n\nThe main screen\n\n\nThe main screen of Wizkers when connected to an Onyx is similar to what you will see with most other supported Geiger Counters:\n\n\n\n\nThe main graph displays instant CPM readings (in orange) as well as a rolling 10 minute average (in dark brown). The side display shows the current CPM and \u00b5Sv/h readings, as well as a \"valid/invalid\" pill which reflects the status of the Onyx.\n\n\nDevice Setup\n\n\nSince Wizkers provides official support to Medcom for the Onyx, nearly all the capabilities of this device are supported in the Device Setup screen\n\n\n\n\nLog downloads\n\n\nThe Onyx can store 3000+ recordings in its flash memory. You can download the logs from the \"logs and recordings\" screen. Wizkers supports all Onyx log formats, including single datapoint logs, and min/max logs.\n\n\n\n\nLog display\n\n\nThe \"Logs and recordings\" screen lets you visualize both Wizkers recordings and downloaded device logs.\n\n\nDepending on the logging mode on the Onyx, logs will be displayed either as a single recording, or as minimum/maximum limits and recording, as shown below:\n\n\n\n\nYou can also save any log in CSV format by clicking on the \"Download as CSV\" button.\n\n\nFirmware upgrades\n\n\nNote:\n firmware upgrades have been tested on Wizkers running on Chromebooks, MacOS, as well as Windows on all version from XP to Windows 10.\n\n\nStarting with Onyx firmware 12.26-b, it is now possible to upgrade the firmware of the Onyx directly from Wizkers. \n\n\nImportant:\n if your Onyx firmware version is lower than 12.26-b, you will need to do one final manual upgrade to get it up to date, by following the \"Recovering from a failed upgrade\" procedure described just below.\n\n\nIf your firmware is 12.26-b or more recent, simply head over to the \"Settings\" screen, then click on \"Upgrade Firmware\", as shown below:\n\n\n\n\nWizkers will first verify that the existing Onyx firmware can be upgraded, then, if successful, will let you either manually select a firmware file on your hard drive, or download the latest version of the Onyx firmware directly from the Wizkers firmware service.\n\n\n\n\nYou can then press \u201cUpgrade Firmware\u201d (it should turn green once Wizkers is happy with the firmware file or download).\n\n\nDo not switch screens once the firmware upgrade starts, it will crash the upgrade process and the Onyx will be temporarily \u2018bricked\u2019. Which brings us to the next section: recovering from a failed firmware upgrade.\n\n\nRecovering from a failed upgrade\n\n\nIf for any reason, the firmware upgrade process is not successful, the Onyx screen will remain blank and the unit will not react to its power/standby switch anymore. Fear not, though, you can recover from this fairly easily. Depending on the operating system you are using, the procedure will be slightly different. Please note that at the moment, it is not possible to recover from a failed upgrade from a Chromebook, you will need a Mac, Linux or a Windows computer.\n\n\nRecovering on MacOS X\n\n\nIn order to recover from a failed upgrade, you will need access to the two files below:\n\n\n\n\nOnyx firmware loader (MacOS)\n\n\nOnyx firmware\n\n\n\n\nYou then need to uncompress the Onyx firmware loader in your home directory. Also put the firmware file in the same location. The rest takes place on a terminal: launch the \u201cTerminal\u201d application and follow the procedure below:\n\n\n\n\nUnload the FTDI drivers from the MacOS kernel:\n\n\n\n\nsudo kextunload -b com.apple.driver.AppleUSBFTDI\n\n\n\n\nThis command works on MacOS Yosemite and later. If you are running an older version of MacOS, please replace com.apple.driver.AppleUSBFTDI with \u201ccom.FTDI.driver.FTDIUSBSerialDriver\u201d.\n\n\nYou might get an error at this stage, but this is nothing to worry about, the driver is unloaded anyway.\n\n\n\n\nDo the firmware recovery (please use the correct name for the firmware file, 12.26-c is used here as an example)\n\n\n\n\nchmod a+x fwload\n./fwload -f firmware-12.26-c.bin\n\n\n\n\nRecovery takes about two minutes, you will see a progress indicator move slowly. If the utility complains it cannot find the Onyx, please unplug it, wait a couple of seconds, then replug it and retry the last step (./fwload -f firmware-12.26-c.bin)\n\n\nYou should now be up and running again.\n\n\n\n\nReload the MacOS FTDI drivers so that the Onyx serial port is available again:\n\n\n\n\nsudo kextload -b com.apple.driver.AppleUSBFTDI\n\n\n\n\nAgain, this is for Yosemite and later, use \u201ccom.FTDI.driver.FTDIUSBSerialDriver\u201d for earlier MacOS versions.\n\n\nRecovering on Windows\n\n\nRecovery on Windows is done with a different utility, and the same firmware file: firmware 12.26-c and the OnyxLink utility are bundled in the ZIP file below:\n\n\n\n\nOnyxLink\n\n\n\n\nOnce you have downloaded OnyxLink.zip, extract it to your desktop, and run the \u201cOnyxLink\u201d application, to do a firmware upgrade using firmware.12-26-c.bin and get back on your feet . You will then be able to use Wizkers to upgrade to the latest firmware.", 
            "title": "Medcom Onyx"
        }, 
        {
            "location": "/ins/medcom-onyx/#medcom-onyx", 
            "text": "The Onyx is a state of the art Geiger counter, based on an Open Source design by  Bunnie Huang . What puts it apart from other open source Geiger counter designs, is that the Onyx is built, calibrated and supported by  International Medcom , one of the most respected names in the nuclear detection industry.  Wizkers is the official utility for the Medcom Onxy and is guaranteed to support all its capabilities.  Wizkers displays the current and historical radiation graph on the main screen, can record the output of the Onyx at any rate, and regularly upload radioactivity values to backend services, including Safecast. Wizkers also support configuring the Onyx, remote calibrations as well as device log data downloads.  Last, it also lets you update the firmware of the Onyx.", 
            "title": "Medcom Onyx"
        }, 
        {
            "location": "/ins/medcom-onyx/#the-main-screen", 
            "text": "The main screen of Wizkers when connected to an Onyx is similar to what you will see with most other supported Geiger Counters:   The main graph displays instant CPM readings (in orange) as well as a rolling 10 minute average (in dark brown). The side display shows the current CPM and \u00b5Sv/h readings, as well as a \"valid/invalid\" pill which reflects the status of the Onyx.", 
            "title": "The main screen"
        }, 
        {
            "location": "/ins/medcom-onyx/#device-setup", 
            "text": "Since Wizkers provides official support to Medcom for the Onyx, nearly all the capabilities of this device are supported in the Device Setup screen", 
            "title": "Device Setup"
        }, 
        {
            "location": "/ins/medcom-onyx/#log-downloads", 
            "text": "The Onyx can store 3000+ recordings in its flash memory. You can download the logs from the \"logs and recordings\" screen. Wizkers supports all Onyx log formats, including single datapoint logs, and min/max logs.", 
            "title": "Log downloads"
        }, 
        {
            "location": "/ins/medcom-onyx/#log-display", 
            "text": "The \"Logs and recordings\" screen lets you visualize both Wizkers recordings and downloaded device logs.  Depending on the logging mode on the Onyx, logs will be displayed either as a single recording, or as minimum/maximum limits and recording, as shown below:   You can also save any log in CSV format by clicking on the \"Download as CSV\" button.", 
            "title": "Log display"
        }, 
        {
            "location": "/ins/medcom-onyx/#firmware-upgrades", 
            "text": "Note:  firmware upgrades have been tested on Wizkers running on Chromebooks, MacOS, as well as Windows on all version from XP to Windows 10.  Starting with Onyx firmware 12.26-b, it is now possible to upgrade the firmware of the Onyx directly from Wizkers.   Important:  if your Onyx firmware version is lower than 12.26-b, you will need to do one final manual upgrade to get it up to date, by following the \"Recovering from a failed upgrade\" procedure described just below.  If your firmware is 12.26-b or more recent, simply head over to the \"Settings\" screen, then click on \"Upgrade Firmware\", as shown below:   Wizkers will first verify that the existing Onyx firmware can be upgraded, then, if successful, will let you either manually select a firmware file on your hard drive, or download the latest version of the Onyx firmware directly from the Wizkers firmware service.   You can then press \u201cUpgrade Firmware\u201d (it should turn green once Wizkers is happy with the firmware file or download).  Do not switch screens once the firmware upgrade starts, it will crash the upgrade process and the Onyx will be temporarily \u2018bricked\u2019. Which brings us to the next section: recovering from a failed firmware upgrade.", 
            "title": "Firmware upgrades"
        }, 
        {
            "location": "/ins/medcom-onyx/#recovering-from-a-failed-upgrade", 
            "text": "If for any reason, the firmware upgrade process is not successful, the Onyx screen will remain blank and the unit will not react to its power/standby switch anymore. Fear not, though, you can recover from this fairly easily. Depending on the operating system you are using, the procedure will be slightly different. Please note that at the moment, it is not possible to recover from a failed upgrade from a Chromebook, you will need a Mac, Linux or a Windows computer.", 
            "title": "Recovering from a failed upgrade"
        }, 
        {
            "location": "/ins/medcom-onyx/#recovering-on-macos-x", 
            "text": "In order to recover from a failed upgrade, you will need access to the two files below:   Onyx firmware loader (MacOS)  Onyx firmware   You then need to uncompress the Onyx firmware loader in your home directory. Also put the firmware file in the same location. The rest takes place on a terminal: launch the \u201cTerminal\u201d application and follow the procedure below:   Unload the FTDI drivers from the MacOS kernel:   sudo kextunload -b com.apple.driver.AppleUSBFTDI  This command works on MacOS Yosemite and later. If you are running an older version of MacOS, please replace com.apple.driver.AppleUSBFTDI with \u201ccom.FTDI.driver.FTDIUSBSerialDriver\u201d.  You might get an error at this stage, but this is nothing to worry about, the driver is unloaded anyway.   Do the firmware recovery (please use the correct name for the firmware file, 12.26-c is used here as an example)   chmod a+x fwload\n./fwload -f firmware-12.26-c.bin  Recovery takes about two minutes, you will see a progress indicator move slowly. If the utility complains it cannot find the Onyx, please unplug it, wait a couple of seconds, then replug it and retry the last step (./fwload -f firmware-12.26-c.bin)  You should now be up and running again.   Reload the MacOS FTDI drivers so that the Onyx serial port is available again:   sudo kextload -b com.apple.driver.AppleUSBFTDI  Again, this is for Yosemite and later, use \u201ccom.FTDI.driver.FTDIUSBSerialDriver\u201d for earlier MacOS versions.", 
            "title": "Recovering on MacOS X"
        }, 
        {
            "location": "/ins/medcom-onyx/#recovering-on-windows", 
            "text": "Recovery on Windows is done with a different utility, and the same firmware file: firmware 12.26-c and the OnyxLink utility are bundled in the ZIP file below:   OnyxLink   Once you have downloaded OnyxLink.zip, extract it to your desktop, and run the \u201cOnyxLink\u201d application, to do a firmware upgrade using firmware.12-26-c.bin and get back on your feet . You will then be able to use Wizkers to upgrade to the latest firmware.", 
            "title": "Recovering on Windows"
        }, 
        {
            "location": "/ins/medcom-onyx-ble/", 
            "text": "Medcom Blue Onyx\n\n\nThe Blue Onyx is an exciting upcoming device from Medcom. Wizkers already support the beta devices that were issued to field testers. Since the Blue Onyx is a Bluetooth LE device, support is limited to BLE-enabled hardware.\n\n\nAs of 0.9.19, Wizkers supports BLE on the Chromebook platform only.", 
            "title": "Medcom Blue Onyx"
        }, 
        {
            "location": "/ins/medcom-onyx-ble/#medcom-blue-onyx", 
            "text": "The Blue Onyx is an exciting upcoming device from Medcom. Wizkers already support the beta devices that were issued to field testers. Since the Blue Onyx is a Bluetooth LE device, support is limited to BLE-enabled hardware.  As of 0.9.19, Wizkers supports BLE on the Chromebook platform only.", 
            "title": "Medcom Blue Onyx"
        }, 
        {
            "location": "/ins/bgeigie/", 
            "text": "Safecast bGeigie Nano\n\n\nThe bGeigie Nano is a portable Geiger counter / logger designed by \nSafecast\n. The full story behind the bGeigie is fascinating, as it was created as a rapid response instrument after the Fukushima Daiichi nuclear accident, and is really a brilliant 'no nonsense' design.\n\n\nHundreds of bGeigie units have been built so far, and they can all be equipped with Bluetooth Low Energy modules for serial communications.\n\n\nWizkers supports the bGeigie when running on a Chromebook, or as an Android app, as long as the Android device supports Bluetooth Low Energy.\n\n\nDevice setup\n\n\nWhen creating a bGeigie device, you will need to select the Bluetooth device name that corresponds to your bGeigie. This is also where you can enter your Safecast API key (you can get an API key at http://api.safecast.org/).\n\n\nWithout the API key, you will not be able to upload your drives to Safecast. You can add the key at any point, even after creating a drive.\n\n\nThe main screen (Chrome)\n\n\nOn Chromebooks, the bGeigie Nano instrument displays pretty much the same data as the Onyx, except that the GPS coordinates come from the bGeigie and not the localization API of Chrome.\n\n\nDue to content policy restrictions on Chrome, there is no mapping support for the bGeigie yet, though a future revision of Wizkers will probably add this.\n\n\n\n\nThe main screen (Cordova app / Android)\n\n\nMapping is enabled by default in Android mode. Wizkers displays the trace on the map using color dots that go from white to red depending on the CPM value.", 
            "title": "Safecast bGeigie Nano"
        }, 
        {
            "location": "/ins/bgeigie/#safecast-bgeigie-nano", 
            "text": "The bGeigie Nano is a portable Geiger counter / logger designed by  Safecast . The full story behind the bGeigie is fascinating, as it was created as a rapid response instrument after the Fukushima Daiichi nuclear accident, and is really a brilliant 'no nonsense' design.  Hundreds of bGeigie units have been built so far, and they can all be equipped with Bluetooth Low Energy modules for serial communications.  Wizkers supports the bGeigie when running on a Chromebook, or as an Android app, as long as the Android device supports Bluetooth Low Energy.", 
            "title": "Safecast bGeigie Nano"
        }, 
        {
            "location": "/ins/bgeigie/#device-setup", 
            "text": "When creating a bGeigie device, you will need to select the Bluetooth device name that corresponds to your bGeigie. This is also where you can enter your Safecast API key (you can get an API key at http://api.safecast.org/).  Without the API key, you will not be able to upload your drives to Safecast. You can add the key at any point, even after creating a drive.", 
            "title": "Device setup"
        }, 
        {
            "location": "/ins/bgeigie/#the-main-screen-chrome", 
            "text": "On Chromebooks, the bGeigie Nano instrument displays pretty much the same data as the Onyx, except that the GPS coordinates come from the bGeigie and not the localization API of Chrome.  Due to content policy restrictions on Chrome, there is no mapping support for the bGeigie yet, though a future revision of Wizkers will probably add this.", 
            "title": "The main screen (Chrome)"
        }, 
        {
            "location": "/ins/bgeigie/#the-main-screen-cordova-app-android", 
            "text": "Mapping is enabled by default in Android mode. Wizkers displays the trace on the map using color dots that go from white to red depending on the CPM value.", 
            "title": "The main screen (Cordova app / Android)"
        }, 
        {
            "location": "/ins/fcoled/", 
            "text": "Fried Circuits OLED Backpack\n\n\nThis plugin really unlocks the potential of this great instrument: the OLED backpack actually contains pretty sophisticated code that monitors current/voltage fluctuations within each sampling period. The build-in monochrome OLED screen is too low resolution to visualize this, but Wizkers is able to create great graphs, as shown below:\n\n\n\n\nOn the right side of the screen, you can adjust the sampling rate of the backpack, from 150ms to several seconds per sample. You can also set the alarm level (current above which the blue LED switches on), and manually switch screens on the backpack.\n\n\nFirmware Upgrade\n\n\nOne exciting feature of this instrument, is that you can upgrade the OLED backpack firmware directly from Wizkers: go to \"Settings\", and click on \"Firmware Upgrade\", the rest should be fairly self-explanatory.\n\n\nYou can either pick a pre-compiled firmware package (\"Hex\" file), or click on \"Download\" to automatically fetch the latest firmware from Fried Circuits. Once the firmware is ready and checked by Wizkers, the \"Download\" button will turn green and you can upgrade the backpack\u2019s firmware, which takes about 10 seconds\u2026", 
            "title": "Fried Circuits OLED backpack"
        }, 
        {
            "location": "/ins/fcoled/#fried-circuits-oled-backpack", 
            "text": "This plugin really unlocks the potential of this great instrument: the OLED backpack actually contains pretty sophisticated code that monitors current/voltage fluctuations within each sampling period. The build-in monochrome OLED screen is too low resolution to visualize this, but Wizkers is able to create great graphs, as shown below:   On the right side of the screen, you can adjust the sampling rate of the backpack, from 150ms to several seconds per sample. You can also set the alarm level (current above which the blue LED switches on), and manually switch screens on the backpack.", 
            "title": "Fried Circuits OLED Backpack"
        }, 
        {
            "location": "/ins/fcoled/#firmware-upgrade", 
            "text": "One exciting feature of this instrument, is that you can upgrade the OLED backpack firmware directly from Wizkers: go to \"Settings\", and click on \"Firmware Upgrade\", the rest should be fairly self-explanatory.  You can either pick a pre-compiled firmware package (\"Hex\" file), or click on \"Download\" to automatically fetch the latest firmware from Fried Circuits. Once the firmware is ready and checked by Wizkers, the \"Download\" button will turn green and you can upgrade the backpack\u2019s firmware, which takes about 10 seconds\u2026", 
            "title": "Firmware Upgrade"
        }, 
        {
            "location": "/ins/sark110/", 
            "text": "Sark 110\n\n\nThe \nSark110\n is a powerful graphical antenna analyzer. Wizkers provides basic support for it at this stage.", 
            "title": "Sark 110"
        }, 
        {
            "location": "/ins/sark110/#sark-110", 
            "text": "The  Sark110  is a powerful graphical antenna analyzer. Wizkers provides basic support for it at this stage.", 
            "title": "Sark 110"
        }, 
        {
            "location": "/ins/elecraft-kx3/", 
            "text": "Elecraft KX3\n\n\nThe KX3 instrument plugin gives you pretty extensive rig controller capabilities from your computer. The first and foremost feature of this plugin is the reproduction of the KX3 faceplace \u2013 you can click on the buttons, nearly everything works. But this instrument also support advanced capabilities including complete KXPA100 monitoring and configuration, as well as PX3 support with Screenshots.\n\n\n\n\nYou will also get access to features that are either not directly supported or a bit involved to work with on the KX3 such as:\n\n\n\n\nMemory Management\n\n\nMonitoring of KXPA100 health\n\n\nDirect frequency access\n\n\nTX and RX equalizer setup\n\n\n\n\nAnd when used with the \"rigctld\" output plugin, you can use Wizkers as the rig controller for third party software such as fldigi.\n\n\nThe main screen\n\n\nThe KX3 Faceplace\n\n\nNot much to say there: most buttons work as they should \u2013 click on the text below the buttons for accessing those functions which are usually accessed by \u201cholding\u201d the buttons.\n\n\nThe display mostly works, a few elements are not kept in sync, most notably the SWR. This will be implemented in a future revision.\n\n\nDirect input area\n\n\nIn this area, you can enter VFO A and VFO B frequencies, select input power, and adjust AF gain, RF attenuation, Mic gain, filter bandwidth and center frequency. Press the \n*\n button to recenter the filter.\n\n\n\n\nWaterfall display\n\n\nThe waterfall display is the most recent feature of this plugin. It is an Audio (not IQ) display, and uses the computer\u2019s default sound input. Press the small \"power\" icon on the upper left to start the waterfall. The Headphones icon sends the audio to the computer\u2019s speakers, which is good for monitoring in digital modes, for instance.\n\n\nThe \"Scale\" and \"Ref\" controls let you change the rendering of the waterfall. Smoothing and FFT window are further controls to fine-tune how the waterfall looks.\n\n\nGraph displays\n\n\nThe right side of the page shows you three graphs:\n\n\n\n\nAmplifier temperature\n\n\nTransmit power\n\n\nPower supply voltage/current\n\n\n\n\nThose graphs really make most sense when a KXPA100 unit is connected to the setup. But even witout a KXPA100, you can graph the KX3 amp temperature (PA.I) or the internal oscillator temp (OSC) by enabling the display of that value on VFOB. Only one value at a time can be monitored, due to the way the KX3 is designed.\n\n\nData mode\n\n\nYou can access a simple data mode terminal by clicking on the \"Data\" tab next to the \"Memories\" tab:\n\n\n\n\nThe layout should be pretty much self-explanatory. Note that Wizkers will continuously scan for call signs in the terminal window and populate the \"you\" dropdown menu for you.\n\n\nThe buttons called CQ, ANS, KN, etc. are macros, which can be configured in the \"Settings\" screen of Wizkers, on the top black menu on the right:\n\n\n\n\nKX3 Setup\n\n\nThe \"Device Setup\" screen cover the following capabilities:\n\n\n\n\nQuick diagnostics: KX3, KXPA100, PX3 versions, options installed, etc\n\n\nConfiguration of the KX3 receive and transmit equalizers\n\n\nFull KXPA100 configuration and monitoring\n\n\nPX3 screenshots\n\n\n\n\nKX3 diagnostics\n\n\n\n\nThis screen is a quick summary of the current state of the KX-line setup: KX3, KXPA100 and PX3 configurations, options etc.\n\n\nAudio settings\n\n\n\n\nYou can adjust the TX and RX equalizers there. This is a feature of the KX3 that is often underused because changing those settings on the radio is fairly cumbersome: the Wizkers UI makes it super easy.\n\n\nNote:\n the KX3 seems to keep separate TX/RX EQ settings depending on the band. Moreover, if your KX3 is in \"DATA\" mode when trying to modify the settings, the UI will freeze. Put the Radio in USB mode to resume operations.\n\n\nKXPA100 configuration and monitoring\n\n\n\n\nThis tab reproduces nearly all the capabilities of the official Elecraft KXPA100 utility, and is also able to graph most amplifier values in real time.\n\n\nYou can adjust your KXPA100 settings from there and check all operating parameters. The values are refreshed twice per second.\n\n\nPX3 Utility\n\n\nThe PX3 utility lets you take screenshots of the PX3 screen, not much to say there. Click on the image to save it:\n\n\n\n\nConfiguring KX3 instruments on Wizkers\n\n\nOn the \"Instruments\" screen, create a new \"Elecraft Radio\" instrument, as shown below. Most of the fields are self-explanatory:\n\n\n\n\nPick the correct serial port\n\n\nIf you are planning to connect your radio audio to the KX3, you can also setup your sound cards here\n\n\n\n\nImportant note: you will need to set your KX3 baud rate to 38400 for Wizkers to talk to your KX3.\n\n\nIf you want to use the Pignology Piglet with this instrument, select \"TCP/IP\" in the serial port dropdown. You will then need to enter the Piglet's IP address and port (7373 by default). You also need to make sure the Piglet is configured for 38'400 baud.\n\n\n\n\nSound card setup\n\n\nThe KX3 instrument gives you the ability to visualize the audio from the KX3 on a \"waterfall\" display, as well as monitor the audio on the computer. It can also send audio coming from your computer (a microphone for instance) to the radio. This is convenient since the radio's audio input and output are connected to your computer, to it is not possible to connect your microphone to the radio anymore.\n\n\nFor doing this, you will need to setup the \"audio from radio\" and \"audio to radio\" drop-downs to indicate which sound card the radio is connected to. And you can use the \"audio from/to operator\" dropdowns to indicate the sound card used by the operator.\n\n\nNote that making full use of this setup requires two sound cards, but you can choose to simply setup the \"audio from radio\" and \"audio to operator\" dropdowns to do a simple monitoring when working on digital modes.\n\n\nWhy are the \"Audio to...\" dropdowns empty ?\n : You need to enable experimental support in Chrome 45.0.2441.x or later by selecting Enable experimental Web Platform features in chrome://flags or by using command line flag \"--enable-blink-features=EnumerateDevices,AudioOutputDevices\"", 
            "title": "Elecraft KX3"
        }, 
        {
            "location": "/ins/elecraft-kx3/#elecraft-kx3", 
            "text": "The KX3 instrument plugin gives you pretty extensive rig controller capabilities from your computer. The first and foremost feature of this plugin is the reproduction of the KX3 faceplace \u2013 you can click on the buttons, nearly everything works. But this instrument also support advanced capabilities including complete KXPA100 monitoring and configuration, as well as PX3 support with Screenshots.   You will also get access to features that are either not directly supported or a bit involved to work with on the KX3 such as:   Memory Management  Monitoring of KXPA100 health  Direct frequency access  TX and RX equalizer setup   And when used with the \"rigctld\" output plugin, you can use Wizkers as the rig controller for third party software such as fldigi.", 
            "title": "Elecraft KX3"
        }, 
        {
            "location": "/ins/elecraft-kx3/#the-main-screen", 
            "text": "", 
            "title": "The main screen"
        }, 
        {
            "location": "/ins/elecraft-kx3/#the-kx3-faceplace", 
            "text": "Not much to say there: most buttons work as they should \u2013 click on the text below the buttons for accessing those functions which are usually accessed by \u201cholding\u201d the buttons.  The display mostly works, a few elements are not kept in sync, most notably the SWR. This will be implemented in a future revision.", 
            "title": "The KX3 Faceplace"
        }, 
        {
            "location": "/ins/elecraft-kx3/#direct-input-area", 
            "text": "In this area, you can enter VFO A and VFO B frequencies, select input power, and adjust AF gain, RF attenuation, Mic gain, filter bandwidth and center frequency. Press the  *  button to recenter the filter.", 
            "title": "Direct input area"
        }, 
        {
            "location": "/ins/elecraft-kx3/#waterfall-display", 
            "text": "The waterfall display is the most recent feature of this plugin. It is an Audio (not IQ) display, and uses the computer\u2019s default sound input. Press the small \"power\" icon on the upper left to start the waterfall. The Headphones icon sends the audio to the computer\u2019s speakers, which is good for monitoring in digital modes, for instance.  The \"Scale\" and \"Ref\" controls let you change the rendering of the waterfall. Smoothing and FFT window are further controls to fine-tune how the waterfall looks.", 
            "title": "Waterfall display"
        }, 
        {
            "location": "/ins/elecraft-kx3/#graph-displays", 
            "text": "The right side of the page shows you three graphs:   Amplifier temperature  Transmit power  Power supply voltage/current   Those graphs really make most sense when a KXPA100 unit is connected to the setup. But even witout a KXPA100, you can graph the KX3 amp temperature (PA.I) or the internal oscillator temp (OSC) by enabling the display of that value on VFOB. Only one value at a time can be monitored, due to the way the KX3 is designed.", 
            "title": "Graph displays"
        }, 
        {
            "location": "/ins/elecraft-kx3/#data-mode", 
            "text": "You can access a simple data mode terminal by clicking on the \"Data\" tab next to the \"Memories\" tab:   The layout should be pretty much self-explanatory. Note that Wizkers will continuously scan for call signs in the terminal window and populate the \"you\" dropdown menu for you.  The buttons called CQ, ANS, KN, etc. are macros, which can be configured in the \"Settings\" screen of Wizkers, on the top black menu on the right:", 
            "title": "Data mode"
        }, 
        {
            "location": "/ins/elecraft-kx3/#kx3-setup", 
            "text": "The \"Device Setup\" screen cover the following capabilities:   Quick diagnostics: KX3, KXPA100, PX3 versions, options installed, etc  Configuration of the KX3 receive and transmit equalizers  Full KXPA100 configuration and monitoring  PX3 screenshots", 
            "title": "KX3 Setup"
        }, 
        {
            "location": "/ins/elecraft-kx3/#kx3-diagnostics", 
            "text": "This screen is a quick summary of the current state of the KX-line setup: KX3, KXPA100 and PX3 configurations, options etc.", 
            "title": "KX3 diagnostics"
        }, 
        {
            "location": "/ins/elecraft-kx3/#audio-settings", 
            "text": "You can adjust the TX and RX equalizers there. This is a feature of the KX3 that is often underused because changing those settings on the radio is fairly cumbersome: the Wizkers UI makes it super easy.  Note:  the KX3 seems to keep separate TX/RX EQ settings depending on the band. Moreover, if your KX3 is in \"DATA\" mode when trying to modify the settings, the UI will freeze. Put the Radio in USB mode to resume operations.", 
            "title": "Audio settings"
        }, 
        {
            "location": "/ins/elecraft-kx3/#kxpa100-configuration-and-monitoring", 
            "text": "This tab reproduces nearly all the capabilities of the official Elecraft KXPA100 utility, and is also able to graph most amplifier values in real time.  You can adjust your KXPA100 settings from there and check all operating parameters. The values are refreshed twice per second.", 
            "title": "KXPA100 configuration and monitoring"
        }, 
        {
            "location": "/ins/elecraft-kx3/#px3-utility", 
            "text": "The PX3 utility lets you take screenshots of the PX3 screen, not much to say there. Click on the image to save it:", 
            "title": "PX3 Utility"
        }, 
        {
            "location": "/ins/elecraft-kx3/#configuring-kx3-instruments-on-wizkers", 
            "text": "On the \"Instruments\" screen, create a new \"Elecraft Radio\" instrument, as shown below. Most of the fields are self-explanatory:   Pick the correct serial port  If you are planning to connect your radio audio to the KX3, you can also setup your sound cards here   Important note: you will need to set your KX3 baud rate to 38400 for Wizkers to talk to your KX3.  If you want to use the Pignology Piglet with this instrument, select \"TCP/IP\" in the serial port dropdown. You will then need to enter the Piglet's IP address and port (7373 by default). You also need to make sure the Piglet is configured for 38'400 baud.", 
            "title": "Configuring KX3 instruments on Wizkers"
        }, 
        {
            "location": "/ins/elecraft-kx3/#sound-card-setup", 
            "text": "The KX3 instrument gives you the ability to visualize the audio from the KX3 on a \"waterfall\" display, as well as monitor the audio on the computer. It can also send audio coming from your computer (a microphone for instance) to the radio. This is convenient since the radio's audio input and output are connected to your computer, to it is not possible to connect your microphone to the radio anymore.  For doing this, you will need to setup the \"audio from radio\" and \"audio to radio\" drop-downs to indicate which sound card the radio is connected to. And you can use the \"audio from/to operator\" dropdowns to indicate the sound card used by the operator.  Note that making full use of this setup requires two sound cards, but you can choose to simply setup the \"audio from radio\" and \"audio to operator\" dropdowns to do a simple monitoring when working on digital modes.  Why are the \"Audio to...\" dropdowns empty ?  : You need to enable experimental support in Chrome 45.0.2441.x or later by selecting Enable experimental Web Platform features in chrome://flags or by using command line flag \"--enable-blink-features=EnumerateDevices,AudioOutputDevices\"", 
            "title": "Sound card setup"
        }, 
        {
            "location": "/ins/elecraft-remote-kx3/", 
            "text": "Elecraft remote KX3\n\n\nThe remote KX3 instrument is very similar to the standard \nKX3 instrument\n, with one very big difference: instead of connecting to a local KX3, this instrument will connect to a remote Wizkers instance over a WebRTC channel.\n\n\nFull rig control as well as full duplex audio are supported.\n\n\nNote:\n KX3 remote capabilities are very experimental and require a bit of manual setup in order to work properly. Contact us at \ninfo@wizkers.io\n for help if required.\n\n\nSetting up Wizkers for KX3 remote control\n\n\nLocal end\n\n\nThe first requirement for using this instrument, is to have another Chrome instance of Wizkers running somewhere, and configured with a standard \nKX3 instrument\n.\n\n\nOn that first instance, you need to then enable a \nWebRTC output\n. Refer to the WebRTC output documentation for details on how to do this.\n\n\nOnce the KX3 and the WebRTC output are configured, simply connect the KX3. You are done on this end.\n\n\nRemote end\n\n\nOn the remote end, things are a lot simpler: just create a Remote KX3 instrument. Most of the screen is similar to any other instrument, with the following differences:\n\n\n\n\nWebRTC Peer needs to point to the call establishment server (see the \nWebRTC output\n doc for details on what this is).\n\n\nYou should select the correct sound card inputs and outputs for the audio. Audio from the radio comes in from the WebRTC audio channel, what you are setting up here is local audio (your microphone and speaker/headphones, in other words).\n\n\n\n\n\n\nEstablishing a call\n\n\nWith the KX3 turned on and connected to the 'local end' Wizkers, you can now start Wizkers on the \"remote end\" device - which can be as simple as a low-end Chromebook, and press \"Connect\". You should see the KX3 display start to update, and you will be able to remotely control the KX3 in the same way you would with the local instance.\n\n\nIn order to start audio, press the \"power\" icon next to the waterfall. This will establish audio communications. You can now use the \"XMIT\" button on the KX3 faceplate to start talking. Be very careful about Audio feedback if you are not using headphones!", 
            "title": "Elecraft Remote KX3"
        }, 
        {
            "location": "/ins/elecraft-remote-kx3/#elecraft-remote-kx3", 
            "text": "The remote KX3 instrument is very similar to the standard  KX3 instrument , with one very big difference: instead of connecting to a local KX3, this instrument will connect to a remote Wizkers instance over a WebRTC channel.  Full rig control as well as full duplex audio are supported.  Note:  KX3 remote capabilities are very experimental and require a bit of manual setup in order to work properly. Contact us at  info@wizkers.io  for help if required.", 
            "title": "Elecraft remote KX3"
        }, 
        {
            "location": "/ins/elecraft-remote-kx3/#setting-up-wizkers-for-kx3-remote-control", 
            "text": "", 
            "title": "Setting up Wizkers for KX3 remote control"
        }, 
        {
            "location": "/ins/elecraft-remote-kx3/#local-end", 
            "text": "The first requirement for using this instrument, is to have another Chrome instance of Wizkers running somewhere, and configured with a standard  KX3 instrument .  On that first instance, you need to then enable a  WebRTC output . Refer to the WebRTC output documentation for details on how to do this.  Once the KX3 and the WebRTC output are configured, simply connect the KX3. You are done on this end.", 
            "title": "Local end"
        }, 
        {
            "location": "/ins/elecraft-remote-kx3/#remote-end", 
            "text": "On the remote end, things are a lot simpler: just create a Remote KX3 instrument. Most of the screen is similar to any other instrument, with the following differences:   WebRTC Peer needs to point to the call establishment server (see the  WebRTC output  doc for details on what this is).  You should select the correct sound card inputs and outputs for the audio. Audio from the radio comes in from the WebRTC audio channel, what you are setting up here is local audio (your microphone and speaker/headphones, in other words).", 
            "title": "Remote end"
        }, 
        {
            "location": "/ins/elecraft-remote-kx3/#establishing-a-call", 
            "text": "With the KX3 turned on and connected to the 'local end' Wizkers, you can now start Wizkers on the \"remote end\" device - which can be as simple as a low-end Chromebook, and press \"Connect\". You should see the KX3 display start to update, and you will be able to remotely control the KX3 in the same way you would with the local instance.  In order to start audio, press the \"power\" icon next to the waterfall. This will establish audio communications. You can now use the \"XMIT\" button on the KX3 faceplate to start talking. Be very careful about Audio feedback if you are not using headphones!", 
            "title": "Establishing a call"
        }, 
        {
            "location": "/ins/elecraft-kxpa100/", 
            "text": "Elecraft KXPA100\n\n\nThe KXPA100 instrument plugin is a complete interface for monitoring and configuring the Elecraft KXPA100 HF amplifier.\n\n\n\n\nNearly all LEDs on the front panel monitor are functional, so you can get a display of the KXPA100 even when it is located far away.\n\n\nYou can either use the KXPA100 monitor along with a KX3, in which case you can access it through the \"Device Setup\" screen, or simply in standalone mode, in case you are using the KXPA100 without a KX3. In that case, just configure it as a standalone instrument through the \"Instruments\" screen.\n\n\nThe main screen\n\n\nThe KXPA100 faceplate\n\n\nAs mentioned above, most LEDs on the faceplate follow the LEDs on the KXPA100 display - the only LED that is not implemented at the moment is the \"TX\" led.\n\n\nTwo LED brightness levels are used, in order to avoid polling the KXPA100 too fast but still provide great visual feedback\n\n\nAMP and ATU Configuration\n\n\nAs shown on the screenshot above, you can control pretty much every aspect of the configuration of the KXPA100 by directly clicking on the checkboxes and dropdowns. Changes are done instantly.\n\n\nParameter Monitoring\n\n\nThe bottom of the screen displays four graphs:\n\n\n\n\nPower: input, forward and reflected power\n\n\nTemperature\n\n\nVoltage and current\n\n\nSWR\n\n\n\n\nEvolutions\n\n\nIn a future release, the KXPA100 monitor will also display the fault history.", 
            "title": "Elecraft KXPA100"
        }, 
        {
            "location": "/ins/elecraft-kxpa100/#elecraft-kxpa100", 
            "text": "The KXPA100 instrument plugin is a complete interface for monitoring and configuring the Elecraft KXPA100 HF amplifier.   Nearly all LEDs on the front panel monitor are functional, so you can get a display of the KXPA100 even when it is located far away.  You can either use the KXPA100 monitor along with a KX3, in which case you can access it through the \"Device Setup\" screen, or simply in standalone mode, in case you are using the KXPA100 without a KX3. In that case, just configure it as a standalone instrument through the \"Instruments\" screen.", 
            "title": "Elecraft KXPA100"
        }, 
        {
            "location": "/ins/elecraft-kxpa100/#the-main-screen", 
            "text": "", 
            "title": "The main screen"
        }, 
        {
            "location": "/ins/elecraft-kxpa100/#the-kxpa100-faceplate", 
            "text": "As mentioned above, most LEDs on the faceplate follow the LEDs on the KXPA100 display - the only LED that is not implemented at the moment is the \"TX\" led.  Two LED brightness levels are used, in order to avoid polling the KXPA100 too fast but still provide great visual feedback", 
            "title": "The KXPA100 faceplate"
        }, 
        {
            "location": "/ins/elecraft-kxpa100/#amp-and-atu-configuration", 
            "text": "As shown on the screenshot above, you can control pretty much every aspect of the configuration of the KXPA100 by directly clicking on the checkboxes and dropdowns. Changes are done instantly.", 
            "title": "AMP and ATU Configuration"
        }, 
        {
            "location": "/ins/elecraft-kxpa100/#parameter-monitoring", 
            "text": "The bottom of the screen displays four graphs:   Power: input, forward and reflected power  Temperature  Voltage and current  SWR", 
            "title": "Parameter Monitoring"
        }, 
        {
            "location": "/ins/elecraft-kxpa100/#evolutions", 
            "text": "In a future release, the KXPA100 monitor will also display the fault history.", 
            "title": "Evolutions"
        }, 
        {
            "location": "/ins/elecraft-xg3/", 
            "text": "Elecraft XG3\n\n\nThe XG3 instrument plugin lets you configure and operate the Elecraft XG3 RF signal source. One of this really nice features is that it makes it very simple to operate the XG3 in CW or RTTY beacon mode, which is not very easy when just interfacing with the XG3 Elecraft utility or a serial terminal.\n\n\n\n\nThe main screen\n\n\nThe XG3 faceplate\n\n\nThe XG3 faceplate is active. In particular, in order to select a band memory, simply click on the LED of the band you want to select. Same thing for the output levels.\n\n\nNote that the red buttons are not active yet.\n\n\nDirect frequency selection and memory edit\n\n\nYou can select a frequency directly in the \"Current frequency\" field.\n\n\nThe monitor screen displays the frequency of all band memories. You can modify any memory and press \"Save\" to send the changes to the XG3. Note that Wizkers is 'smart' and will only send actual changes to the XG3 and will not overwrite a memory for unchanged memories.\n\n\nCW/RTTY beacon\n\n\nThe \"Beacon Mode\" panel lets you define the beacon string. The XG3 supports quite a few special characters as part of the beacon string, and the monitor can display a quick 'cheat sheet' by pressing \"Syntax Help\".\n\n\nNote that when clicking \"Send Beacon\", the XG3 PF1 memory is automatically reprogrammed to activate beacon memory. The XG3 will send the beacon (continuously if the beacon ends with '#') until a command is sent to the XG3, for instance by changing the band.\n\n\nThe XG3 can also send an arbitraty string of characters in CW or RTTY mode using the \"send immediately\" field.\n\n\nSweep mode\n\n\nSweeps are not implemented on this version yet!", 
            "title": "Elecraft XG3"
        }, 
        {
            "location": "/ins/elecraft-xg3/#elecraft-xg3", 
            "text": "The XG3 instrument plugin lets you configure and operate the Elecraft XG3 RF signal source. One of this really nice features is that it makes it very simple to operate the XG3 in CW or RTTY beacon mode, which is not very easy when just interfacing with the XG3 Elecraft utility or a serial terminal.", 
            "title": "Elecraft XG3"
        }, 
        {
            "location": "/ins/elecraft-xg3/#the-main-screen", 
            "text": "", 
            "title": "The main screen"
        }, 
        {
            "location": "/ins/elecraft-xg3/#the-xg3-faceplate", 
            "text": "The XG3 faceplate is active. In particular, in order to select a band memory, simply click on the LED of the band you want to select. Same thing for the output levels.  Note that the red buttons are not active yet.", 
            "title": "The XG3 faceplate"
        }, 
        {
            "location": "/ins/elecraft-xg3/#direct-frequency-selection-and-memory-edit", 
            "text": "You can select a frequency directly in the \"Current frequency\" field.  The monitor screen displays the frequency of all band memories. You can modify any memory and press \"Save\" to send the changes to the XG3. Note that Wizkers is 'smart' and will only send actual changes to the XG3 and will not overwrite a memory for unchanged memories.", 
            "title": "Direct frequency selection and memory edit"
        }, 
        {
            "location": "/ins/elecraft-xg3/#cwrtty-beacon", 
            "text": "The \"Beacon Mode\" panel lets you define the beacon string. The XG3 supports quite a few special characters as part of the beacon string, and the monitor can display a quick 'cheat sheet' by pressing \"Syntax Help\".  Note that when clicking \"Send Beacon\", the XG3 PF1 memory is automatically reprogrammed to activate beacon memory. The XG3 will send the beacon (continuously if the beacon ends with '#') until a command is sent to the XG3, for instance by changing the band.  The XG3 can also send an arbitraty string of characters in CW or RTTY mode using the \"send immediately\" field.", 
            "title": "CW/RTTY beacon"
        }, 
        {
            "location": "/ins/elecraft-xg3/#sweep-mode", 
            "text": "Sweeps are not implemented on this version yet!", 
            "title": "Sweep mode"
        }, 
        {
            "location": "/ins/fluke289/", 
            "text": "Fluke 287/289 Multimeters\n\n\nThe Fluke 287/289 instrument provides real time visualization and data logging when connected to those multimeters. It also enables complete remote control through the \"Instrument Settings\" screen, with remote display of the screen and control of all the buttons of the multimeter.\n\n\nThe plugin also support downloading data from the instrument memory, visualize and export it.", 
            "title": "Fluke 287/289 DMMs"
        }, 
        {
            "location": "/ins/fluke289/#fluke-287289-multimeters", 
            "text": "The Fluke 287/289 instrument provides real time visualization and data logging when connected to those multimeters. It also enables complete remote control through the \"Instrument Settings\" screen, with remote display of the screen and control of all the buttons of the multimeter.  The plugin also support downloading data from the instrument memory, visualize and export it.", 
            "title": "Fluke 287/289 Multimeters"
        }, 
        {
            "location": "/ins/simple-serial/", 
            "text": "Simple serial terminal\n\n\nSometimes, you just want to hook up a serial device to your computer and check if it works: this is exactly what the simple serial terminal is for.\n\n\n\n\nTerminal settings\n\n\nSo far, the simple serial terminal does not support many settings, only a switch between \"raw\" mode and \"Hexadecimal\" which will output the data as a Hex dump.", 
            "title": "Simple serial terminal"
        }, 
        {
            "location": "/ins/simple-serial/#simple-serial-terminal", 
            "text": "Sometimes, you just want to hook up a serial device to your computer and check if it works: this is exactly what the simple serial terminal is for.", 
            "title": "Simple serial terminal"
        }, 
        {
            "location": "/ins/simple-serial/#terminal-settings", 
            "text": "So far, the simple serial terminal does not support many settings, only a switch between \"raw\" mode and \"Hexadecimal\" which will output the data as a Hex dump.", 
            "title": "Terminal settings"
        }, 
        {
            "location": "/out/rest/", 
            "text": "REST Output\n\n\nThe REST output is deceptively simple: you can use it to talk to a very large number of REST endpoints, with very little configuration.\n\n\n\n\nNumber of Fields: input the number of data elements that will be used to build the \u201cServer URL\u201d below.\n\n\nServer URL: using the simple \u201ctag\u201d syntax explained below this field, you can design the structure of the URL that will be called or posted to.\n\n\nDo a GET or POST: as it says, you can select whether to GET or POST to the URL above.\n\n\nNotes on development\n\n\nAs it stands today, this plugin is already very useful. Future development of Wizkers might include additional predefined tags such as current time, GPS location and others, that can be combined with instrument outputs to build more complex calls. Contributions are welcome!", 
            "title": "REST API"
        }, 
        {
            "location": "/out/rest/#rest-output", 
            "text": "The REST output is deceptively simple: you can use it to talk to a very large number of REST endpoints, with very little configuration.   Number of Fields: input the number of data elements that will be used to build the \u201cServer URL\u201d below.  Server URL: using the simple \u201ctag\u201d syntax explained below this field, you can design the structure of the URL that will be called or posted to.  Do a GET or POST: as it says, you can select whether to GET or POST to the URL above.", 
            "title": "REST Output"
        }, 
        {
            "location": "/out/rest/#notes-on-development", 
            "text": "As it stands today, this plugin is already very useful. Future development of Wizkers might include additional predefined tags such as current time, GPS location and others, that can be combined with instrument outputs to build more complex calls. Contributions are welcome!", 
            "title": "Notes on development"
        }, 
        {
            "location": "/out/safecast/", 
            "text": "Safecast output\n\n\nThe Safecast output is ony available for instrument which are sending radioactivity readings. It lets you forward the readings to the \nSafecast.org\n API.", 
            "title": "Safecast"
        }, 
        {
            "location": "/out/safecast/#safecast-output", 
            "text": "The Safecast output is ony available for instrument which are sending radioactivity readings. It lets you forward the readings to the  Safecast.org  API.", 
            "title": "Safecast output"
        }, 
        {
            "location": "/out/rigctld/", 
            "text": "RigCTLd Output\n\n\nThis output is available for HAM radio transceivers. It emulates a Hamlib \"Rigctld\" daemon, so that programs like fldigi can control the KX3 through Wizkers.", 
            "title": "rigctld"
        }, 
        {
            "location": "/out/rigctld/#rigctld-output", 
            "text": "This output is available for HAM radio transceivers. It emulates a Hamlib \"Rigctld\" daemon, so that programs like fldigi can control the KX3 through Wizkers.", 
            "title": "RigCTLd Output"
        }, 
        {
            "location": "/out/text/", 
            "text": "Text output\n\n\nThe text output plugin is simple but very effective: it will regularly create - or append to - a file with the data fields of your choice.\n\n\nThis makes it possible to either create flat log files for later analysis, or more interestingly, interact with external processes which will read those files and process the data in real time.\n\n\nConfiguration\n\n\n\n\nThe text output works with a simple tag style template which lets you create lines containing the fields of your choice. You can setup the location of the output file, as well as whether Wizkers should append to the file or overwrite it at each plugin trigger.\n\n\nThe example above shows how Wizkers can be setup to simply write an instrument value (radioactivity in this case) so that an external program can use it (direwolf in this case, for broadcasting this value as a telemetry packet over the Amateur Radio band).", 
            "title": "Text"
        }, 
        {
            "location": "/out/text/#text-output", 
            "text": "The text output plugin is simple but very effective: it will regularly create - or append to - a file with the data fields of your choice.  This makes it possible to either create flat log files for later analysis, or more interestingly, interact with external processes which will read those files and process the data in real time.", 
            "title": "Text output"
        }, 
        {
            "location": "/out/text/#configuration", 
            "text": "The text output works with a simple tag style template which lets you create lines containing the fields of your choice. You can setup the location of the output file, as well as whether Wizkers should append to the file or overwrite it at each plugin trigger.  The example above shows how Wizkers can be setup to simply write an instrument value (radioactivity in this case) so that an external program can use it (direwolf in this case, for broadcasting this value as a telemetry packet over the Amateur Radio band).", 
            "title": "Configuration"
        }, 
        {
            "location": "/out/webrtc/", 
            "text": "WebRTC Output\n\n\nThis output plugin forwards all the data coming from the instrument over a WebRTC data channel. If can also send bidirectional audio to a remote end. The data channel is also bidirectional.\n\n\n\n\nYou can use this plugin in two different ways: display instrument data and do remote control from remote web pages, or connect to an instrument from Wizkers running on a remote computer. Think of it as \"Wizkers to Wizkers\" communication.\n\n\nAs of 0.9.19, you can use this Output for the Elecraft KX3 for remote operations: configure a \u201cElecraft KX3 Radio\u201d instrument on a local Wizkers instance, then add the WebRTC output. Then, on another computer, create a \u201cRemote KX3\u201d instrument, which will let you connect to your KX3 remotely, including full duplex audio.\n\n\nAudio settings\n\n\nIf enabled, the WebRTC output will forward local audio to any peer connected to it, and will receive remote audio.\n\n\nSelf-hosted vs PeerJS\n\n\nThe WebRTC is now working fine. But in order to establish communication between two peers, a broker service is required: we are using \nPeerJS\n to do this. The PeerJS seems to be a bit dormant at the moment and its broker service does not work. But PeerJS also provides everything you need to run your own broker service, and this is currently the recommended way of working with the WebRTC output.\n\n\nFollow instructions on \nGithub\n to run PeerServer on a local machine on your network.\n\n\nOnce your PeerServer is running, configure the WebRTC output as \"Self-hosted\" in the connection method, and put the IP:Port of the peer server in the \"Server IP:Port\" field.\n\n\nInterfacing a web page with the WebRTC Output\n\n\nThe WebRTC output uses the \nPeerJS\n library to implement a simple wrapper around WebRTC. This makes it easy to display instrument data on a remote web page.\n\n\nTODO: create a detailed guide on how to implement an example web page once all the code is on github.\n\n\nFuture evolutions of the WebRTC output\n\n\nWe are currently investigating running a Wizkers.io PeerServer for Wizkers users, which will make it a lot easier to use the output (no manual installation of PeerServer required). But self-hosting will always be supported anyway.", 
            "title": "WebRTC"
        }, 
        {
            "location": "/out/webrtc/#webrtc-output", 
            "text": "This output plugin forwards all the data coming from the instrument over a WebRTC data channel. If can also send bidirectional audio to a remote end. The data channel is also bidirectional.   You can use this plugin in two different ways: display instrument data and do remote control from remote web pages, or connect to an instrument from Wizkers running on a remote computer. Think of it as \"Wizkers to Wizkers\" communication.  As of 0.9.19, you can use this Output for the Elecraft KX3 for remote operations: configure a \u201cElecraft KX3 Radio\u201d instrument on a local Wizkers instance, then add the WebRTC output. Then, on another computer, create a \u201cRemote KX3\u201d instrument, which will let you connect to your KX3 remotely, including full duplex audio.", 
            "title": "WebRTC Output"
        }, 
        {
            "location": "/out/webrtc/#audio-settings", 
            "text": "If enabled, the WebRTC output will forward local audio to any peer connected to it, and will receive remote audio.", 
            "title": "Audio settings"
        }, 
        {
            "location": "/out/webrtc/#self-hosted-vs-peerjs", 
            "text": "The WebRTC is now working fine. But in order to establish communication between two peers, a broker service is required: we are using  PeerJS  to do this. The PeerJS seems to be a bit dormant at the moment and its broker service does not work. But PeerJS also provides everything you need to run your own broker service, and this is currently the recommended way of working with the WebRTC output.  Follow instructions on  Github  to run PeerServer on a local machine on your network.  Once your PeerServer is running, configure the WebRTC output as \"Self-hosted\" in the connection method, and put the IP:Port of the peer server in the \"Server IP:Port\" field.", 
            "title": "Self-hosted vs PeerJS"
        }, 
        {
            "location": "/out/webrtc/#interfacing-a-web-page-with-the-webrtc-output", 
            "text": "The WebRTC output uses the  PeerJS  library to implement a simple wrapper around WebRTC. This makes it easy to display instrument data on a remote web page.  TODO: create a detailed guide on how to implement an example web page once all the code is on github.", 
            "title": "Interfacing a web page with the WebRTC Output"
        }, 
        {
            "location": "/out/webrtc/#future-evolutions-of-the-webrtc-output", 
            "text": "We are currently investigating running a Wizkers.io PeerServer for Wizkers users, which will make it a lot easier to use the output (no manual installation of PeerServer required). But self-hosting will always be supported anyway.", 
            "title": "Future evolutions of the WebRTC output"
        }, 
        {
            "location": "/out/xmlrpc/", 
            "text": "XML-RPC Output\n\n\nThis output is available for HAM radio transceivers only.\n\n\nIt is a fairly complete implementation of the XML-RPC server that fldigi expects for rig control. While you can use the rigctld output with fldigi as well, the XML-RPC implementation is much more robust, faster and flexible.\n\n\nIn essence, this lets Wizkers emulate the 'flrig' program, so any software that is compatible with flrig will be able to work with Wizkers.\n\n\nThere are no specific settings for the XML-RPC output, just create it, then enable it in the \"Outputs\" screen, fldigi will automatically connect to Wizkers as soon as it starts.", 
            "title": "XML-RPC"
        }, 
        {
            "location": "/out/xmlrpc/#xml-rpc-output", 
            "text": "This output is available for HAM radio transceivers only.  It is a fairly complete implementation of the XML-RPC server that fldigi expects for rig control. While you can use the rigctld output with fldigi as well, the XML-RPC implementation is much more robust, faster and flexible.  In essence, this lets Wizkers emulate the 'flrig' program, so any software that is compatible with flrig will be able to work with Wizkers.  There are no specific settings for the XML-RPC output, just create it, then enable it in the \"Outputs\" screen, fldigi will automatically connect to Wizkers as soon as it starts.", 
            "title": "XML-RPC Output"
        }
    ]
}