{
    "docs": [
        {
            "location": "/", 
            "text": "Wizkers documentation\n\n\nWizkers is a universal open source application for both data visualization and control of various kinds of scientific instruments. It is a full Javascript/HTML5 application which runs on nearly any computer, phone or tablet.\n\n\nIt can also run as a standalone server application, on any Linux platform, from a simple Raspberry Pi or Beaglebone black, all the way to cloud-hosted AWS instances, which gives it tremendous flexibility. Basically, it is a real open source simple 'cloud' system  and one of the only 'cloud' projects out there with a fully open source (GNU Affero General Public License) front-end \nand\n backend.\n\n\nOut of the box, Wizkers supports a variety of instruments, and it can easily be extended to support additional devices.\n\n\nThis documentation covers both \nuser instructions\n as well as \ndeveloper docs\n.\n\n\n\n\nWhat can Wizkers do?\n\n\nAt the core, Wizkers is designed to interface with various kind of sensors and scientific instruments and visualize and record their data. Wizkers lets you:\n\n\n\n\nVisualize the readings coming from your sensors and instruments\n\n\nRecord those readings\n\n\nForward the readings to a variety of backends - from HTTP REST APIs to WebRTC\n\n\nYou can use this capability to forward data to IoT services, and remain independent\n\n\n\n\n\n\nRemotely control and configure the sensors and instruments connected to it\n\n\n\n\nWho is Wizkers for ?\n\n\nWizkers is an ideal fit for anyone building or using measurement instruments, as it provides all the necessary capabilities to create an instrument utility that works on any operating system or device, is easy to maintain and fast to deploy. This enables instrument and sensor designers to focus on their project without spending too much time on the software part, and still create a best of class interface.\n\n\nWizkers is also a great solution for any sensor deployment project where there is a desire to be truly independent from third party service providers, or the deployment occurs in regions where 24/7 Internet connectivity is not a given. For this reason, Wizkers is popular with NGOs.\n\n\nWhy Wizkers ?\n\n\nWizkers came to life for a couple of simple reasons:\n\n\n\n\nMost lab instruments have no decent computer utilities even though they have great connectivity. Those utilities are usually less than user-friendly, Windows-only, and poorly supported.\n\n\nIt is becoming easier and easier to create and use many small and not-so-small sensors that generate data, but finding good ways to record, visualize and analyze their output, and remotely configure and control them with an engaging interface is often an afterthought.\n\n\nMost IoT services are all about 'dumb' sensors and easy and free APIs, but at the cost of a completely closed backend and limited control on your data once it is sent over. Basically, you are only getting access to half of the infrastructure, and the arguably most critical part is outside of your control. But there are many situations where you want to be able to deploy your own infrastructure without having to rely on a third party, especially if you are not deploying millions of sensors, or you cannot do 24/7 connectivity for some reason.\n\n\n\n\nAnother issue we have experienced many times over the last few years, is that most IoT startups cannot provide any kind of continuity and stability for a project: from Pinocc.io to Pachube, Spark.io, Helium.com, etc, most of those companies tend to review and modify their business model every couple of months, and put any project that relies on them at great risk.\n\n\nWizkers solves all this issues with one elegant framework: In a nutshell, Wizkers is both the missing link between your sensors, your instruments and the Cloud, as well as the missing universal utility for scientific instruments which works on any OS and any computer.\n\n\nWizkers overview\n\n\nSupported instruments\n\n\nThe following instruments are currently supported in Wizkers (as of August 2015):\n\n\n\n\n\n\n\n\nInstrument name\n\n\nChrome App\n\n\nAndroid App\n\n\nServer\n\n\n\n\n\n\n\n\n\n\n\n\nMedcom Onyx\n\n\nYes\n\n\nYes\n\n\nYes\n\n\n\n\n\n\n\n\nMedcom Geiger Link\n\n\nYes\n\n\nYes\n\n\nYes\n\n\n\n\n\n\n\n\nMedcom Blue Onyx\n\n\nChromebooks only\n\n\nNo\n\n\nNo\n\n\n\n\n\n\n\n\nMedcom Hawk Nest\n\n\n-\n\n\n-\n\n\nYes\n\n\n\n\n\n\n\n\nElecraft KX3\n\n\nYes\n\n\nYes\n\n\nYes\n\n\n\n\n\n\n\n\nRemote KX3 (Wizkers to Wizkers)\n\n\nYes\n\n\nNot tested\n\n\nNot tested\n\n\n\n\n\n\n\n\nFluke 287/289\n\n\nYes\n\n\nYes\n\n\nYes\n\n\n\n\n\n\n\n\nFried Circuits USB tester OLED backpack\n\n\nYes\n\n\nYes\n\n\nYes\n\n\n\n\n\n\n\n\nSimple serial terminal\n\n\nYes\n\n\nYes\n\n\nYes\n\n\n\n\n\n\n\n\nSark 110 antena analyzer\n\n\nYes\n\n\nYes\n\n\nYes\n\n\n\n\n\n\n\n\nKromek Sigma 25\n\n\nYes\n\n\nYes\n\n\nYes\n\n\n\n\n\n\n\n\n\n\nWhat if my instrument is not supported ?\n\n\nWe can help! If you are a developer, you can head over to the \ndeveloper documentation\n and get started. You can also contact us at \ninfo@wizkers.io\n and find out how we can help.\n\n\nWizkers and Open Source\n\n\nWizkers is a fully open source project, released under the terms of the GNU Affero General Public License. The Affero version of the GPL means that if you use Wizkers in any manner (including by running it or offering it as a service), you must make the full source code, including any modifications you did available to all your users.\n\n\nWizkers also uses a variety of third party libraries which are released under multiple license schemes, but are all compatible with this global license.\n\n\nInstallation instructions\n\n\nBelow are installation instructions for the three run modes supported on Wizkers:\n\n\nChrome packaged app\n\n\nWizkers can be \ndownloaded\n from the Chrome app store, and is available on any computer that can run Chrome. This includes MacOS, Linux and Windows. \n\n\nChrome packaged apps rely on the Chrome runtime to run - this means you need to have Google Chrome installed on the computer - but otherwise behave as native applications.\n\n\nAndroid app\n\n\nWizkers will eventually be available on the Google Play store, but in the mean time, you will have to build Wizkers for Android yourself (refer to the \ndeveloper documentation\n for details on how to do this).\n\n\nServer\n\n\nYou can also run Wizkers as a standalone server. You then interact with a running Wizkers instance using a web browser. The advantage of running Wizkers in this mode, is that you can leave it connected to instruments 24/7. Server mode supports advanced features such as user management and user rights, multiple open instruments at the same time.\n\n\nRefer to the \ndeveloper documentation\n for instructions on how to checkout Wizkers from Github and build the server version.", 
            "title": "Overview"
        }, 
        {
            "location": "/#wizkers-documentation", 
            "text": "Wizkers is a universal open source application for both data visualization and control of various kinds of scientific instruments. It is a full Javascript/HTML5 application which runs on nearly any computer, phone or tablet.  It can also run as a standalone server application, on any Linux platform, from a simple Raspberry Pi or Beaglebone black, all the way to cloud-hosted AWS instances, which gives it tremendous flexibility. Basically, it is a real open source simple 'cloud' system  and one of the only 'cloud' projects out there with a fully open source (GNU Affero General Public License) front-end  and  backend.  Out of the box, Wizkers supports a variety of instruments, and it can easily be extended to support additional devices.  This documentation covers both  user instructions  as well as  developer docs .", 
            "title": "Wizkers documentation"
        }, 
        {
            "location": "/#what-can-wizkers-do", 
            "text": "At the core, Wizkers is designed to interface with various kind of sensors and scientific instruments and visualize and record their data. Wizkers lets you:   Visualize the readings coming from your sensors and instruments  Record those readings  Forward the readings to a variety of backends - from HTTP REST APIs to WebRTC  You can use this capability to forward data to IoT services, and remain independent    Remotely control and configure the sensors and instruments connected to it", 
            "title": "What can Wizkers do?"
        }, 
        {
            "location": "/#who-is-wizkers-for", 
            "text": "Wizkers is an ideal fit for anyone building or using measurement instruments, as it provides all the necessary capabilities to create an instrument utility that works on any operating system or device, is easy to maintain and fast to deploy. This enables instrument and sensor designers to focus on their project without spending too much time on the software part, and still create a best of class interface.  Wizkers is also a great solution for any sensor deployment project where there is a desire to be truly independent from third party service providers, or the deployment occurs in regions where 24/7 Internet connectivity is not a given. For this reason, Wizkers is popular with NGOs.", 
            "title": "Who is Wizkers for ?"
        }, 
        {
            "location": "/#why-wizkers", 
            "text": "Wizkers came to life for a couple of simple reasons:   Most lab instruments have no decent computer utilities even though they have great connectivity. Those utilities are usually less than user-friendly, Windows-only, and poorly supported.  It is becoming easier and easier to create and use many small and not-so-small sensors that generate data, but finding good ways to record, visualize and analyze their output, and remotely configure and control them with an engaging interface is often an afterthought.  Most IoT services are all about 'dumb' sensors and easy and free APIs, but at the cost of a completely closed backend and limited control on your data once it is sent over. Basically, you are only getting access to half of the infrastructure, and the arguably most critical part is outside of your control. But there are many situations where you want to be able to deploy your own infrastructure without having to rely on a third party, especially if you are not deploying millions of sensors, or you cannot do 24/7 connectivity for some reason.   Another issue we have experienced many times over the last few years, is that most IoT startups cannot provide any kind of continuity and stability for a project: from Pinocc.io to Pachube, Spark.io, Helium.com, etc, most of those companies tend to review and modify their business model every couple of months, and put any project that relies on them at great risk.  Wizkers solves all this issues with one elegant framework: In a nutshell, Wizkers is both the missing link between your sensors, your instruments and the Cloud, as well as the missing universal utility for scientific instruments which works on any OS and any computer.", 
            "title": "Why Wizkers ?"
        }, 
        {
            "location": "/#wizkers-overview", 
            "text": "Supported instruments  The following instruments are currently supported in Wizkers (as of August 2015):     Instrument name  Chrome App  Android App  Server       Medcom Onyx  Yes  Yes  Yes     Medcom Geiger Link  Yes  Yes  Yes     Medcom Blue Onyx  Chromebooks only  No  No     Medcom Hawk Nest  -  -  Yes     Elecraft KX3  Yes  Yes  Yes     Remote KX3 (Wizkers to Wizkers)  Yes  Not tested  Not tested     Fluke 287/289  Yes  Yes  Yes     Fried Circuits USB tester OLED backpack  Yes  Yes  Yes     Simple serial terminal  Yes  Yes  Yes     Sark 110 antena analyzer  Yes  Yes  Yes     Kromek Sigma 25  Yes  Yes  Yes      What if my instrument is not supported ?  We can help! If you are a developer, you can head over to the  developer documentation  and get started. You can also contact us at  info@wizkers.io  and find out how we can help.", 
            "title": "Wizkers overview"
        }, 
        {
            "location": "/#wizkers-and-open-source", 
            "text": "Wizkers is a fully open source project, released under the terms of the GNU Affero General Public License. The Affero version of the GPL means that if you use Wizkers in any manner (including by running it or offering it as a service), you must make the full source code, including any modifications you did available to all your users.  Wizkers also uses a variety of third party libraries which are released under multiple license schemes, but are all compatible with this global license.", 
            "title": "Wizkers and Open Source"
        }, 
        {
            "location": "/#installation-instructions", 
            "text": "Below are installation instructions for the three run modes supported on Wizkers:  Chrome packaged app  Wizkers can be  downloaded  from the Chrome app store, and is available on any computer that can run Chrome. This includes MacOS, Linux and Windows.   Chrome packaged apps rely on the Chrome runtime to run - this means you need to have Google Chrome installed on the computer - but otherwise behave as native applications.  Android app  Wizkers will eventually be available on the Google Play store, but in the mean time, you will have to build Wizkers for Android yourself (refer to the  developer documentation  for details on how to do this).  Server  You can also run Wizkers as a standalone server. You then interact with a running Wizkers instance using a web browser. The advantage of running Wizkers in this mode, is that you can leave it connected to instruments 24/7. Server mode supports advanced features such as user management and user rights, multiple open instruments at the same time.  Refer to the  developer documentation  for instructions on how to checkout Wizkers from Github and build the server version.", 
            "title": "Installation instructions"
        }, 
        {
            "location": "/userdoc/", 
            "text": "Wizkers User documentation\n\n\nWelcome to the user documentation of Wizkers. This section will help you make the most of the various capabilities of Wizkers.\n\n\nHome screen\n\n\nThe home screen contains three main zones:\n\n\n\n\nConnect/Setup/Record zone\n\n\nMain view / Live view\n\n\nSide view\n\n\n\n\n\n\nThe first time you start Wizkers, you will need to create a new instrument, as described in the next section.\n\n\nConnecting instruments\n\n\n\n\nThe top buttons are pretty much self-explanatory: the \u201cConnect\u201d button opens the connection to the instrument. The \u201cDevice Setup\u201d button will only be enabled if the device supports a Setup screen (not all do). Last, the \u201cRecord Session\u201d button lets you do a live recording of the data coming in from the device. You can view the logs that are saved there in the \u201cLogs and recordings\u201d screen.\n\n\nConfiguring instruments\n\n\nAll instrument configuration is done on the \u201cInstruments\u201d screen. The first time you start the application, no instruments will be present. To create a new instrument, click on \u201cAdd Instrument\u201d card:\n\n\n\n\nAfter pressing \u201cAdd Instrument\u201c, you will be presented with a blank configuration screen, as shown below. Some instruments display extra settings, but the following is always present:\n\n\n\n\nFirst of all, give a \u201cFriendly Name\u201d to your instrument, and select the correct instrument type.\n\n\nDepending on the instrument type, the \"port\" section will be different. Port can be:\n\n\n\n\nA serial port\n\n\nA bluetooth device\n\n\nA network address\n\n\nAn API Key\n\n\n\n\nRefer to the documentation of each instrument for more details on how to configure those fields.\n\n\nThe \nLive view length\n option defines the time length of the the home screen live view - by defaults, Wizkers displays the last five minutes of data, or last 500 points.\n\n\nPolling period\n defines how often Wizkers requests information from the instrument. Some instruments will send data at their own rate, in which case this setting will be unused for that instrument.\n\n\nLogs and recordings\n\n\nOutputs\n\n\nOutput plugins are one of the great features of Wizkers: using those plugins, you can automatically send the data generated by your instruments to various backend services.\n\n\nAt the moment, Wizkers ships with four output plugins:\n\n\n\n\nGeneric REST output\n\n\nSafecast output\n\n\nHAM Radio \n\u201crigctld\u201d emulation plugin\n, for remote control of radios.\n\n\nWebRTC Output\n\n\n\n\nCreating and configuring an output\n\n\nAll output plugins share quite a few settings: selecting what fields should be sent to the output, how often and with what conditions:\n\n\nWhen you create an output from the \u201cData Output\u201d screen (option on the top menu bar), you will see the screen below:\n\n\n\n\nNote: you should be connected to the current instrument before creating an output, because the output plugin detects the data sent by the instrument for creating its configuration.\n\n\nYou can select the output plugin, give it a name and write notes in the top part of the window.\n\n\nThe section on the right tells you when the plugin was last triggered with success, when it last attempted to send data, and what the last message from the backend was. Very useful for debugging.\n\n\nThen the screen contains three tabs: \u201cData to send\u201d, \u201cWhen to send it\u201d, \u201cOutput Settings\u201d. Only the last one (\u201cOutput Settings\u201d) is plugin-specific, the first two are identical for all output plugins.\n\n\nData to send\n\n\nAgain, you need to be connected to your instrument in order to be able to do anything with this screen. If not, it only displays a help message encouraging you to do so.\n\n\nWizkers in server mode\n\n\nIn server mode, you connect to Wizkers by pointing your Chrome browser to the IP address of the computer running Wizkers.\n\n\nIn this mode, Wizkers will behave a little bit differently:\n\n\n\n\nIt will enforce a simple user authentication mechanism\n\n\nIt will support multiple open instruments at once\n\n\nIt will keep all open instruments connected even when the user logs out of the interface\n\n\n\n\nThis makes it possible to use Wizkers for autonomous monitoring stations. When combined with local recording and output capabilties, this actually turns Wizkers into a pretty powerful system.\n\n\nUser authentication\n\n\nThe first time you access Wizkesr through the network, a default \nadmin\n user will be created. Wizkers will force you to change the default admin password before letting you access most of its functionality.\n\n\nTODO: describe user roles", 
            "title": "Users"
        }, 
        {
            "location": "/userdoc/#wizkers-user-documentation", 
            "text": "Welcome to the user documentation of Wizkers. This section will help you make the most of the various capabilities of Wizkers.", 
            "title": "Wizkers User documentation"
        }, 
        {
            "location": "/userdoc/#home-screen", 
            "text": "The home screen contains three main zones:   Connect/Setup/Record zone  Main view / Live view  Side view    The first time you start Wizkers, you will need to create a new instrument, as described in the next section.", 
            "title": "Home screen"
        }, 
        {
            "location": "/userdoc/#connecting-instruments", 
            "text": "The top buttons are pretty much self-explanatory: the \u201cConnect\u201d button opens the connection to the instrument. The \u201cDevice Setup\u201d button will only be enabled if the device supports a Setup screen (not all do). Last, the \u201cRecord Session\u201d button lets you do a live recording of the data coming in from the device. You can view the logs that are saved there in the \u201cLogs and recordings\u201d screen.", 
            "title": "Connecting instruments"
        }, 
        {
            "location": "/userdoc/#configuring-instruments", 
            "text": "All instrument configuration is done on the \u201cInstruments\u201d screen. The first time you start the application, no instruments will be present. To create a new instrument, click on \u201cAdd Instrument\u201d card:   After pressing \u201cAdd Instrument\u201c, you will be presented with a blank configuration screen, as shown below. Some instruments display extra settings, but the following is always present:   First of all, give a \u201cFriendly Name\u201d to your instrument, and select the correct instrument type.  Depending on the instrument type, the \"port\" section will be different. Port can be:   A serial port  A bluetooth device  A network address  An API Key   Refer to the documentation of each instrument for more details on how to configure those fields.  The  Live view length  option defines the time length of the the home screen live view - by defaults, Wizkers displays the last five minutes of data, or last 500 points.  Polling period  defines how often Wizkers requests information from the instrument. Some instruments will send data at their own rate, in which case this setting will be unused for that instrument.", 
            "title": "Configuring instruments"
        }, 
        {
            "location": "/userdoc/#logs-and-recordings", 
            "text": "", 
            "title": "Logs and recordings"
        }, 
        {
            "location": "/userdoc/#outputs", 
            "text": "Output plugins are one of the great features of Wizkers: using those plugins, you can automatically send the data generated by your instruments to various backend services.  At the moment, Wizkers ships with four output plugins:   Generic REST output  Safecast output  HAM Radio  \u201crigctld\u201d emulation plugin , for remote control of radios.  WebRTC Output", 
            "title": "Outputs"
        }, 
        {
            "location": "/userdoc/#creating-and-configuring-an-output", 
            "text": "All output plugins share quite a few settings: selecting what fields should be sent to the output, how often and with what conditions:  When you create an output from the \u201cData Output\u201d screen (option on the top menu bar), you will see the screen below:   Note: you should be connected to the current instrument before creating an output, because the output plugin detects the data sent by the instrument for creating its configuration.  You can select the output plugin, give it a name and write notes in the top part of the window.  The section on the right tells you when the plugin was last triggered with success, when it last attempted to send data, and what the last message from the backend was. Very useful for debugging.  Then the screen contains three tabs: \u201cData to send\u201d, \u201cWhen to send it\u201d, \u201cOutput Settings\u201d. Only the last one (\u201cOutput Settings\u201d) is plugin-specific, the first two are identical for all output plugins.", 
            "title": "Creating and configuring an output"
        }, 
        {
            "location": "/userdoc/#data-to-send", 
            "text": "Again, you need to be connected to your instrument in order to be able to do anything with this screen. If not, it only displays a help message encouraging you to do so.", 
            "title": "Data to send"
        }, 
        {
            "location": "/userdoc/#wizkers-in-server-mode", 
            "text": "In server mode, you connect to Wizkers by pointing your Chrome browser to the IP address of the computer running Wizkers.  In this mode, Wizkers will behave a little bit differently:   It will enforce a simple user authentication mechanism  It will support multiple open instruments at once  It will keep all open instruments connected even when the user logs out of the interface   This makes it possible to use Wizkers for autonomous monitoring stations. When combined with local recording and output capabilties, this actually turns Wizkers into a pretty powerful system.", 
            "title": "Wizkers in server mode"
        }, 
        {
            "location": "/userdoc/#user-authentication", 
            "text": "The first time you access Wizkesr through the network, a default  admin  user will be created. Wizkers will force you to change the default admin password before letting you access most of its functionality.  TODO: describe user roles", 
            "title": "User authentication"
        }, 
        {
            "location": "/devdoc/", 
            "text": "Developer documentation\n\n\nBuilding Wizkers\n\n\nRefer to the \nbuild instructions\n to do a check out and initial build of the code.\n\n\nWizkers architecture\n\n\nDue to its multiple supported run modes, the structure of Wizkers is split between a \u201cfront-end\u201d and a \u201cback-end\u201d part, even when it runs 100% in a browser.\n\n\nThe diagram below shows how the the various components of Wizkers interact with each other. If you want to add new instruments, this will be a good reference, though you will usually not need to go deep into those modules, and only implement instrument views and the instruments\u2019s front-end/back-end API.\n\n\n\n\nSource tree organization\n\n\nThe Wizkers source tree is organized as follows:\n\n\nREADME.md            # Top level Readme, for the benefit of Github\nbuild-tools          # A couple of build scripts used to optimize the javascript for the Chrome version\ncordova              # Cordova-specific files used to build Wizkers\ndocumentation        # The documentation you are reading right now\nserver               # Files used by Wizkers in server mode\nchrome               # Files used by Wizkers in Chrome mode\ngulpfile.js          # The toplevel gulpfile\nmerges               # er....\npackage.json         # npm toplevel package file\nwww                  # The complete javascript app - frontend only in server mode, complete app in Chrome/Cordova mode\n\n\n\n\nwww tree\n\n\nMost of the code of Wizkers is contained in the \nwww\n directory, which is organized as follows:\n\n\nwww/css             # Stylesheets used by the app\nwww/fonts           # Fonts used be the app\nwww/img             # Images used by the app\nwww/js              # The core of Wizkers, see below for organization\n...                 # A couple of extra files used for examples\n\n\n\n\nThe \njs\n directory is then structured in a modular fashion, to make it easy to extend Wizkers:\n\n\nwww/js/app              # The main Wizkers app\nwww/js/app/connections  # Used in Chrome/Cordova mode: low-level drivers for serial/bluetooth/etc\nwww/js/app/instruments  # All instruments supported by Wizkers\nwww/js/app/lib          # Wizkers shared libraries\nwww/js/app/models       # Wizkers Backbone models\nwww/js/app/outputs      # Output plugins\nwww/js/app/views        # Wizkers views (screens)\nwww/js/lib              # All third party libraries used by Wizkers\nwww/js/tpl              # All HTML templates used by the various Wizkers screens/views.\n\n\n\n\nRun-mode specific trees\n\n\nThe \ncordova\n, \nserver\n and \nchrome\n directories contain all the files that are specific to those run-modes. When \nbuilding\n Wizkers, Gulp will add the contents of those directories to the \ndist\n directory to end up with a working version of Wizkers for those various run modes.", 
            "title": "Overview"
        }, 
        {
            "location": "/devdoc/#developer-documentation", 
            "text": "", 
            "title": "Developer documentation"
        }, 
        {
            "location": "/devdoc/#building-wizkers", 
            "text": "Refer to the  build instructions  to do a check out and initial build of the code.", 
            "title": "Building Wizkers"
        }, 
        {
            "location": "/devdoc/#wizkers-architecture", 
            "text": "Due to its multiple supported run modes, the structure of Wizkers is split between a \u201cfront-end\u201d and a \u201cback-end\u201d part, even when it runs 100% in a browser.  The diagram below shows how the the various components of Wizkers interact with each other. If you want to add new instruments, this will be a good reference, though you will usually not need to go deep into those modules, and only implement instrument views and the instruments\u2019s front-end/back-end API.", 
            "title": "Wizkers architecture"
        }, 
        {
            "location": "/devdoc/#source-tree-organization", 
            "text": "The Wizkers source tree is organized as follows:  README.md            # Top level Readme, for the benefit of Github\nbuild-tools          # A couple of build scripts used to optimize the javascript for the Chrome version\ncordova              # Cordova-specific files used to build Wizkers\ndocumentation        # The documentation you are reading right now\nserver               # Files used by Wizkers in server mode\nchrome               # Files used by Wizkers in Chrome mode\ngulpfile.js          # The toplevel gulpfile\nmerges               # er....\npackage.json         # npm toplevel package file\nwww                  # The complete javascript app - frontend only in server mode, complete app in Chrome/Cordova mode  www tree  Most of the code of Wizkers is contained in the  www  directory, which is organized as follows:  www/css             # Stylesheets used by the app\nwww/fonts           # Fonts used be the app\nwww/img             # Images used by the app\nwww/js              # The core of Wizkers, see below for organization\n...                 # A couple of extra files used for examples  The  js  directory is then structured in a modular fashion, to make it easy to extend Wizkers:  www/js/app              # The main Wizkers app\nwww/js/app/connections  # Used in Chrome/Cordova mode: low-level drivers for serial/bluetooth/etc\nwww/js/app/instruments  # All instruments supported by Wizkers\nwww/js/app/lib          # Wizkers shared libraries\nwww/js/app/models       # Wizkers Backbone models\nwww/js/app/outputs      # Output plugins\nwww/js/app/views        # Wizkers views (screens)\nwww/js/lib              # All third party libraries used by Wizkers\nwww/js/tpl              # All HTML templates used by the various Wizkers screens/views.  Run-mode specific trees  The  cordova ,  server  and  chrome  directories contain all the files that are specific to those run-modes. When  building  Wizkers, Gulp will add the contents of those directories to the  dist  directory to end up with a working version of Wizkers for those various run modes.", 
            "title": "Source tree organization"
        }, 
        {
            "location": "/building/", 
            "text": "Building Wizkers\n\n\nPrerequisites\n\n\nThe only prerequisite for building (and running Wizkers in server mode) are NodeJS and npm.\n\n\nYou will need to install a recent 0.10 version of NodeJS \u2013 Wizkers is not tested on Node 0.12 yet. You can refer to \nthis guide\n for details on how to do this on Linux, in particular.\n\n\nCheck out the code\n\n\nWizkers is hosted on \ngithub\n. Create a work directory on your machine and check out the code from Github, and go to the 'release' branch:\n\n\nmkdir wizkers; cd wizkers\ngit clone https://github.com/wizkers/wizkers.git\ncd wizkers/server\ngit checkout release\n\n\n\n\nBuild it\n\n\nWizkers supports the \nHelium\n IoT network for some of its instruments. The NodeJS \"nodhelium\" module requires installing \"libhelium\" on your system. If you don't have any idea what Helium is about, you definitely don't need it, and you can edit out the two locations on Wizkers which depend on libhelium:\n\n\n\n\nserver/package.json\n\n\nserver/connectionmanager.js (line 45)\n\n\n\n\nThe next step is to install all dependencies using npm:\n\n\nnpm install\n\n\n\n\nThis can take from a couple of minutes to quite some time if you are building on a low power system such as a Beaglebone.\n\n\nOnce all dependencies are installed, Wizkers uses 'gulp' as its build system: if gulp is not installed on your system already, use npm to get it:\n\n\nnpm install -g gulp\n\n\n\n\nYou can now build Wizkers in its three supported modes:\n\n\ngulp chrome\ngulp cordova\ngulp android\n\n\n\n\nThose three gulp targets will build Wizkers in the \ndist\n directory\n\n\nFinalizing and packaging\n\n\nOnce the base code is built through Gulp, the instructions below will show you how to finalize the build for the various run modes and launch Wizkers:\n\n\nChrome app\n\n\nAfter building, the Chrome version of Wizkers will be ready in \ndist/chrome\n and \ndist/chrome-debug\n. The \nchrome-debug\n directory can be immediately loaded into Google Chrome by visiting (chrome://extensions) and loading Wizkers from there.\n\n\nThe \nchrome\n version requires finalizing the compilation by launching \nbuild-toold/build-chrome.sh\n which will optimize the javascript code. The resulting Chrome app in \ndist/chrome\n will run faster but it won't be possible to debug it easily.\n\n\nCordova (Android app)\n\n\nThe Android app version of Wizker uses the Cordova framework to package Wizkers into a native Android application.\n\n\nServer\n\n\nThe server build of Wizkers is available in \ndist/server\n. Simply go to that directory and launch the server:\n\n\ncd dist/server\nnode server.js", 
            "title": "Building"
        }, 
        {
            "location": "/building/#building-wizkers", 
            "text": "", 
            "title": "Building Wizkers"
        }, 
        {
            "location": "/building/#prerequisites", 
            "text": "The only prerequisite for building (and running Wizkers in server mode) are NodeJS and npm.  You will need to install a recent 0.10 version of NodeJS \u2013 Wizkers is not tested on Node 0.12 yet. You can refer to  this guide  for details on how to do this on Linux, in particular.", 
            "title": "Prerequisites"
        }, 
        {
            "location": "/building/#check-out-the-code", 
            "text": "Wizkers is hosted on  github . Create a work directory on your machine and check out the code from Github, and go to the 'release' branch:  mkdir wizkers; cd wizkers\ngit clone https://github.com/wizkers/wizkers.git\ncd wizkers/server\ngit checkout release", 
            "title": "Check out the code"
        }, 
        {
            "location": "/building/#build-it", 
            "text": "Wizkers supports the  Helium  IoT network for some of its instruments. The NodeJS \"nodhelium\" module requires installing \"libhelium\" on your system. If you don't have any idea what Helium is about, you definitely don't need it, and you can edit out the two locations on Wizkers which depend on libhelium:   server/package.json  server/connectionmanager.js (line 45)   The next step is to install all dependencies using npm:  npm install  This can take from a couple of minutes to quite some time if you are building on a low power system such as a Beaglebone.  Once all dependencies are installed, Wizkers uses 'gulp' as its build system: if gulp is not installed on your system already, use npm to get it:  npm install -g gulp  You can now build Wizkers in its three supported modes:  gulp chrome\ngulp cordova\ngulp android  Those three gulp targets will build Wizkers in the  dist  directory", 
            "title": "Build it"
        }, 
        {
            "location": "/building/#finalizing-and-packaging", 
            "text": "Once the base code is built through Gulp, the instructions below will show you how to finalize the build for the various run modes and launch Wizkers:  Chrome app  After building, the Chrome version of Wizkers will be ready in  dist/chrome  and  dist/chrome-debug . The  chrome-debug  directory can be immediately loaded into Google Chrome by visiting (chrome://extensions) and loading Wizkers from there.  The  chrome  version requires finalizing the compilation by launching  build-toold/build-chrome.sh  which will optimize the javascript code. The resulting Chrome app in  dist/chrome  will run faster but it won't be possible to debug it easily.  Cordova (Android app)  The Android app version of Wizker uses the Cordova framework to package Wizkers into a native Android application.  Server  The server build of Wizkers is available in  dist/server . Simply go to that directory and launch the server:  cd dist/server\nnode server.js", 
            "title": "Finalizing and packaging"
        }, 
        {
            "location": "/dev/outputs/", 
            "text": "Outputs API\n\n\nChrome/Cordova mode\n\n\nServer mode", 
            "title": "Creating outputs"
        }, 
        {
            "location": "/dev/outputs/#outputs-api", 
            "text": "", 
            "title": "Outputs API"
        }, 
        {
            "location": "/dev/outputs/#chromecordova-mode", 
            "text": "", 
            "title": "Chrome/Cordova mode"
        }, 
        {
            "location": "/dev/outputs/#server-mode", 
            "text": "", 
            "title": "Server mode"
        }, 
        {
            "location": "/dev/instruments/", 
            "text": "", 
            "title": "Creating instruments"
        }, 
        {
            "location": "/dev/connections/", 
            "text": "Connections\n\n\nConnections are the low-level hardware drivers which connect instrument drivers to the actual instruments.\n\n\nConnections can be serial ports, Bluetooth, network sockets, etc. depending on the instrument type.\n\n\nAll modes\n\n\ndescribe connection configuration templates in \nwww/js/app/views/instruments\n.\n\n\nServer mode\n\n\ndescribes where connections live in server mode, and the API\n\n\nChrome/Cordova mode\n\n\ndescribes where connections live in Chrome/Cordova mode, and the API", 
            "title": "Connections"
        }, 
        {
            "location": "/dev/connections/#connections", 
            "text": "Connections are the low-level hardware drivers which connect instrument drivers to the actual instruments.  Connections can be serial ports, Bluetooth, network sockets, etc. depending on the instrument type.", 
            "title": "Connections"
        }, 
        {
            "location": "/dev/connections/#all-modes", 
            "text": "describe connection configuration templates in  www/js/app/views/instruments .", 
            "title": "All modes"
        }, 
        {
            "location": "/dev/connections/#server-mode", 
            "text": "describes where connections live in server mode, and the API", 
            "title": "Server mode"
        }, 
        {
            "location": "/dev/connections/#chromecordova-mode", 
            "text": "describes where connections live in Chrome/Cordova mode, and the API", 
            "title": "Chrome/Cordova mode"
        }, 
        {
            "location": "/dev/debugging/", 
            "text": "Debugging Wizkers\n\n\nDepending on the run mode of Wizkers, several options are available to you:\n\n\nChrome app\n\n\nThe best way to debug Mouse Wizkers is to use the Developer tools in Chrome. You can simply load the Wizkers chrome app manually by going to the \u201cExtensions\u201d menu in Chrome, and use \u201cLoad Unpacked Extension\u2026\u201d and make it point to the the \u201cserver\u201d directory.\n\n\n\n\nThis will start Mouse Wizkers with all developer tools enabled (which is not the case in the Chrome Store version where those are disabled).\n\n\nServer mode\n\n\nIn server mode, Wizkers uses the Node.js \u201cdebug\u201d facility: simply define a \u201cDEBUG\u201d variable to enable debug output. All modules in Wizkers already define a unique debug name, so you get fairly fine grained output. You can try a \u201cDEBUG=* node server.js\u201d to get an idea of the maximum level of debug output you can get.\n\n\nAndroid application\n\n\nYou can also use Chrome to debug Wizkers running as an Android application: you need to have the Android SDK installed on your computer, and your test device connected through USB using \nadb\n.\n\n\nNetwork debugging of Android\n\n\nSince Wizkers lets you use the USB port of your Android device to connect to various kinds of instruments, you will often end up in situatino where you cannot do USB debugging. This is not a problem, since adb can also work on the network. You still need to link your Android device to the adb server on your computer through USB once:\n\n\n$ adb tcpip 5555\n\n\n\n\nThen you can disconnect the Android device from USB, and connect through the Wifi network:\n\n\n$ adb connect \ndevice-ip-address\n\n\n\n\n\nThe Chrome Webview contained in Wizkers will then start showing up on Chrome's \nchrome://inspect\n screen.", 
            "title": "Debugging"
        }, 
        {
            "location": "/dev/debugging/#debugging-wizkers", 
            "text": "Depending on the run mode of Wizkers, several options are available to you:", 
            "title": "Debugging Wizkers"
        }, 
        {
            "location": "/dev/debugging/#chrome-app", 
            "text": "The best way to debug Mouse Wizkers is to use the Developer tools in Chrome. You can simply load the Wizkers chrome app manually by going to the \u201cExtensions\u201d menu in Chrome, and use \u201cLoad Unpacked Extension\u2026\u201d and make it point to the the \u201cserver\u201d directory.   This will start Mouse Wizkers with all developer tools enabled (which is not the case in the Chrome Store version where those are disabled).", 
            "title": "Chrome app"
        }, 
        {
            "location": "/dev/debugging/#server-mode", 
            "text": "In server mode, Wizkers uses the Node.js \u201cdebug\u201d facility: simply define a \u201cDEBUG\u201d variable to enable debug output. All modules in Wizkers already define a unique debug name, so you get fairly fine grained output. You can try a \u201cDEBUG=* node server.js\u201d to get an idea of the maximum level of debug output you can get.", 
            "title": "Server mode"
        }, 
        {
            "location": "/dev/debugging/#android-application", 
            "text": "You can also use Chrome to debug Wizkers running as an Android application: you need to have the Android SDK installed on your computer, and your test device connected through USB using  adb .  Network debugging of Android  Since Wizkers lets you use the USB port of your Android device to connect to various kinds of instruments, you will often end up in situatino where you cannot do USB debugging. This is not a problem, since adb can also work on the network. You still need to link your Android device to the adb server on your computer through USB once:  $ adb tcpip 5555  Then you can disconnect the Android device from USB, and connect through the Wifi network:  $ adb connect  device-ip-address   The Chrome Webview contained in Wizkers will then start showing up on Chrome's  chrome://inspect  screen.", 
            "title": "Android application"
        }, 
        {
            "location": "/ins/medcom-onyx/", 
            "text": "Medcom Onyx\n\n\nThe Onyx is a state of the art Geiger counter, based on an Open Source design by \nBunnie Huang\n. What puts it apart from other open source Geiger counter designs, is that the Onyx is built, calibrated and supported by \nInternational Medcom\n, one of the most respected names in the nuclear detection industry.\n\n\nWizkers is the official utility for the Medcom Onxy and is guaranteed to support all its capabilities.\n\n\nWizkers displays the current and historical radiation graph on the main screen, can record the output of the Onyx at any rate, and regularly upload radioactivity values to backend services, including Safecast. Wizkers also support configuring the Onyx, remote calibrations as well as device log data downloads.\n\n\nLast, it also lets you update the firmware of the Onyx.\n\n\nThe main screen\n\n\nThe main screen of Wizkers when connected to an Onyx is similar to what you will see with most other supported Geiger Counters:\n\n\n\n\nThe main graph displays instant CPM readings (in orange) as well as a rolling 10 minute average (in dark brown). The side display shows the current CPM and \u00b5Sv/h readings, as well as a \"valid/invalid\" pill which reflects the status of the Onyx.\n\n\nDevice Setup\n\n\nSince Wizkers provides official support to Medcom for the Onyx, nearly all the capabilities of this device are supported in the Device Setup screen\n\n\n----- add a screenshot -----\n\n\nLog downloads\n\n\nThe Onyx can store 3000+ recordings in its flash memory. You can download the logs from the \"logs and recordings\" screen. Wizkers supports all Onyx log formats, including single datapoint logs, and min/max logs.\n\n\nLog display and download\n\n\nThe \"Logs and recordings\" screen lets you visualize both Wizkers recordings and downloaded device logs. \n\n\n-------- add a screenshot -----\n\n\nYou can also save any log in CSV format by clicking on the \"Download as CSV\" button.", 
            "title": "Medcom Onyx"
        }, 
        {
            "location": "/ins/medcom-onyx/#medcom-onyx", 
            "text": "The Onyx is a state of the art Geiger counter, based on an Open Source design by  Bunnie Huang . What puts it apart from other open source Geiger counter designs, is that the Onyx is built, calibrated and supported by  International Medcom , one of the most respected names in the nuclear detection industry.  Wizkers is the official utility for the Medcom Onxy and is guaranteed to support all its capabilities.  Wizkers displays the current and historical radiation graph on the main screen, can record the output of the Onyx at any rate, and regularly upload radioactivity values to backend services, including Safecast. Wizkers also support configuring the Onyx, remote calibrations as well as device log data downloads.  Last, it also lets you update the firmware of the Onyx.", 
            "title": "Medcom Onyx"
        }, 
        {
            "location": "/ins/medcom-onyx/#the-main-screen", 
            "text": "The main screen of Wizkers when connected to an Onyx is similar to what you will see with most other supported Geiger Counters:   The main graph displays instant CPM readings (in orange) as well as a rolling 10 minute average (in dark brown). The side display shows the current CPM and \u00b5Sv/h readings, as well as a \"valid/invalid\" pill which reflects the status of the Onyx.", 
            "title": "The main screen"
        }, 
        {
            "location": "/ins/medcom-onyx/#device-setup", 
            "text": "Since Wizkers provides official support to Medcom for the Onyx, nearly all the capabilities of this device are supported in the Device Setup screen  ----- add a screenshot -----", 
            "title": "Device Setup"
        }, 
        {
            "location": "/ins/medcom-onyx/#log-downloads", 
            "text": "The Onyx can store 3000+ recordings in its flash memory. You can download the logs from the \"logs and recordings\" screen. Wizkers supports all Onyx log formats, including single datapoint logs, and min/max logs.", 
            "title": "Log downloads"
        }, 
        {
            "location": "/ins/medcom-onyx/#log-display-and-download", 
            "text": "The \"Logs and recordings\" screen lets you visualize both Wizkers recordings and downloaded device logs.   -------- add a screenshot -----  You can also save any log in CSV format by clicking on the \"Download as CSV\" button.", 
            "title": "Log display and download"
        }, 
        {
            "location": "/ins/medcom-onyx-ble/", 
            "text": "Medcom Blue Onyx\n\n\nThe Blue Onyx is an exciting upcoming device from Medcom. Wizkers already support the beta devices that were issued to field testers. Since the Blue Onyx is a Bluetooth LE device, support is limited to BLE-enabled hardware.\n\n\nAs of 0.9.19, Wizkers supports BLE on the Chromebook platform only.", 
            "title": "Medcom Blue Onyx"
        }, 
        {
            "location": "/ins/medcom-onyx-ble/#medcom-blue-onyx", 
            "text": "The Blue Onyx is an exciting upcoming device from Medcom. Wizkers already support the beta devices that were issued to field testers. Since the Blue Onyx is a Bluetooth LE device, support is limited to BLE-enabled hardware.  As of 0.9.19, Wizkers supports BLE on the Chromebook platform only.", 
            "title": "Medcom Blue Onyx"
        }, 
        {
            "location": "/ins/fcoled/", 
            "text": "", 
            "title": "Fried Circuits OLED backpack"
        }, 
        {
            "location": "/ins/sark110/", 
            "text": "", 
            "title": "Sark 110"
        }, 
        {
            "location": "/ins/elecraft-kx3/", 
            "text": "Elecraft KX3", 
            "title": "Elecraft KX3"
        }, 
        {
            "location": "/ins/elecraft-kx3/#elecraft-kx3", 
            "text": "", 
            "title": "Elecraft KX3"
        }, 
        {
            "location": "/ins/elecraft-remote-kx3/", 
            "text": "", 
            "title": "Elecraft Remote KX3"
        }, 
        {
            "location": "/out/rest/", 
            "text": "REST Output\n\n\nThe REST output is deceptively simple: you can use it to talk to a very large number of REST endpoints, with very little configuration.\n\n\n\n\nNumber of Fields: input the number of data elements that will be used to build the \u201cServer URL\u201d below.\n\n\nServer URL: using the simple \u201ctag\u201d syntax explained below this field, you can design the structure of the URL that will be called or posted to.\n\n\nDo a GET or POST: as it says, you can select whether to GET or POST to the URL above.\n\n\nNotes on development\n\n\nAs it stands today, this plugin is already very useful. Future development of Wizkers might include additional predefined tags such as current time, GPS location and others, that can be combined with instrument outputs to build more complex calls. Contributions are welcome!", 
            "title": "REST API"
        }, 
        {
            "location": "/out/rest/#rest-output", 
            "text": "The REST output is deceptively simple: you can use it to talk to a very large number of REST endpoints, with very little configuration.   Number of Fields: input the number of data elements that will be used to build the \u201cServer URL\u201d below.  Server URL: using the simple \u201ctag\u201d syntax explained below this field, you can design the structure of the URL that will be called or posted to.  Do a GET or POST: as it says, you can select whether to GET or POST to the URL above.", 
            "title": "REST Output"
        }, 
        {
            "location": "/out/rest/#notes-on-development", 
            "text": "As it stands today, this plugin is already very useful. Future development of Wizkers might include additional predefined tags such as current time, GPS location and others, that can be combined with instrument outputs to build more complex calls. Contributions are welcome!", 
            "title": "Notes on development"
        }, 
        {
            "location": "/out/safecast/", 
            "text": "Safecast output\n\n\nThe Safecast output is ony available for instrument which are sending radioactivity readings. It lets you forward the readings to the \nSafecast.org\n API.", 
            "title": "Safecast"
        }, 
        {
            "location": "/out/safecast/#safecast-output", 
            "text": "The Safecast output is ony available for instrument which are sending radioactivity readings. It lets you forward the readings to the  Safecast.org  API.", 
            "title": "Safecast output"
        }, 
        {
            "location": "/out/rigctld/", 
            "text": "RigCTLd Output\n\n\nThis output is available for HAM radio transceivers. It emulates a Hamlib \"Rigctld\" daemon, so that programs like fldigi can control the KX3 through Wizkers.", 
            "title": "rigctld"
        }, 
        {
            "location": "/out/rigctld/#rigctld-output", 
            "text": "This output is available for HAM radio transceivers. It emulates a Hamlib \"Rigctld\" daemon, so that programs like fldigi can control the KX3 through Wizkers.", 
            "title": "RigCTLd Output"
        }, 
        {
            "location": "/out/webrtc/", 
            "text": "WebRTC Output\n\n\nThis output plugin forwards all the data coming from the instrument over a WebRTC data channel. If can also send bidirectional audio to a remote end. The data channel is also bidirectional.\n\n\n\n\nYou can use this plugin in two different ways: display instrument data and do remote control from remote web page, or connect to an instrument from Wizkers running on a remote computer.\n\n\nAs of 0.9.19, you can use this Output for the Elecraft KX3 for remote operations: configure a \u201cElecraft KX3 Radio\u201d instrument on a local Wizkers instance, then add the WebRTC output. Then, on another computer, create a \u201cRemote KX3\u201d instrument, which will let you connect to your KX3 remotely, including full duplex audio.\n\n\nInterfacing a web page with the WebRTC Output\n\n\nThe WebRTC output uses the PeerJS library to implement a simple wrapper around WebRTC. This makes it easy to display instrument data on a remote web page.\n\n\nTODO: create a detailed guide on how to implement an example web page once all the code is on github.", 
            "title": "WebRTC"
        }, 
        {
            "location": "/out/webrtc/#webrtc-output", 
            "text": "This output plugin forwards all the data coming from the instrument over a WebRTC data channel. If can also send bidirectional audio to a remote end. The data channel is also bidirectional.   You can use this plugin in two different ways: display instrument data and do remote control from remote web page, or connect to an instrument from Wizkers running on a remote computer.  As of 0.9.19, you can use this Output for the Elecraft KX3 for remote operations: configure a \u201cElecraft KX3 Radio\u201d instrument on a local Wizkers instance, then add the WebRTC output. Then, on another computer, create a \u201cRemote KX3\u201d instrument, which will let you connect to your KX3 remotely, including full duplex audio.", 
            "title": "WebRTC Output"
        }, 
        {
            "location": "/out/webrtc/#interfacing-a-web-page-with-the-webrtc-output", 
            "text": "The WebRTC output uses the PeerJS library to implement a simple wrapper around WebRTC. This makes it easy to display instrument data on a remote web page.  TODO: create a detailed guide on how to implement an example web page once all the code is on github.", 
            "title": "Interfacing a web page with the WebRTC Output"
        }
    ]
}