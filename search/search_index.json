{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Wizkers documentation Wizkers is a universal open source application for both data visualization and control of various kinds of scientific instruments. It is a full Javascript/HTML5 application which runs on nearly any computer, phone or tablet. It can also run as a standalone server application, on any Linux platform, from a simple Raspberry Pi or Beaglebone black, all the way to cloud-hosted AWS instances, which gives it tremendous flexibility. Basically, it is a real open source simple 'cloud' system and one of the only 'cloud' projects out there with a fully open source (GNU Affero General Public License) front-end and backend. Out of the box, Wizkers supports a variety of instruments, and it can easily be extended to support additional devices. This documentation covers both user instructions and developer docs . What can Wizkers do? At the core, Wizkers is designed to interface with various kind of sensors and scientific instruments and visualize and record their data. Wizkers lets you: Visualize the readings coming from your sensors and instruments Record those readings Forward the readings to a variety of backends - from HTTP REST APIs to WebRTC You can use this capability to forward data to IoT services, and remain independent Remotely control and configure the sensors and instruments connected to it Who is Wizkers for ? Wizkers is an ideal fit for anyone building or using measurement instruments, as it provides all the necessary capabilities to create an instrument utility that works on any operating system or device, is easy to maintain and fast to deploy. This enables instrument and sensor designers to focus on their project without spending too much time on the software part, and still create a best of class interface. Wizkers is also a great solution for any sensor deployment project where there is a desire to be truly independent from third party service providers, or the deployment occurs in regions where 24/7 Internet connectivity is not a given. For this reason, Wizkers is popular with NGOs. Why Wizkers ? Wizkers came to life for a couple of simple reasons: Most lab instruments have no decent computer utilities even though they have great connectivity. Those utilities are usually less than user-friendly, Windows-only, and poorly supported. It is becoming easier and easier to create and use many small and not-so-small sensors that generate data, but finding good ways to record, visualize and analyze their output, and remotely configure and control them with an engaging interface is often an afterthought. Most IoT services are all about 'dumb' sensors and easy and free APIs, but at the cost of a completely closed backend and limited control on your data once it is sent over. Basically, you are only getting access to half of the infrastructure, and the arguably most critical part is outside of your control. But there are many situations where you want to be able to deploy your own infrastructure without having to rely on a third party, especially if you are not deploying millions of sensors, or you cannot do 24/7 connectivity for some reason. Another issue we have experienced many times over the last few years, is that most IoT startups cannot provide any kind of continuity and stability for a project: from Pinocc.io to Pachube, Spark.io, Helium.com, etc, most of those companies tend to review and modify their business model every couple of months, and put any project that relies on them at great risk. Wizkers solves all this issues with one elegant framework: In a nutshell, Wizkers is both the missing link between your sensors, your instruments and the Cloud, as well as the missing universal utility for scientific instruments which works on any OS and any computer. Wizkers overview Supported instruments The following instruments are currently supported in Wizkers (as of August 2015): Instrument name Chrome Android Server Native (nwjs.io) Medcom Onyx Yes Yes Yes Yes Medcom Geiger Link Yes Yes Yes Yes Medcom Blue Onyx Chromebooks only Yes No Yes Medcom Hawk Nest - - Yes - Safecast bGeigie Nano Chromebooks only Yes - Yes Elecraft KX3 Yes Yes Yes Yes Remote KX3 (Wizkers to Wizkers) Yes Not tested Not tested Yes Elecraft KXPA100 Yes Yes Yes Yes Kenwood V71A Yes Yes Yes Yes Fluke 287/289 Yes Yes Yes Yes Fried Circuits USB tester OLED backpack Yes Yes Yes Yes Fried Circuits USB tested BTLE backpack Chromebooks only Yes No - Simple serial terminal Yes Yes Yes Yes Sark 110 antena analyzer Yes Yes Yes Yes Kromek Sigma 25 Yes Yes Yes Yes Kestrel 5000 series Yes Yes Yes Yes Kestrel DROP Series Yes Yes Yes Yes What if my instrument is not supported ? We can help! If you are a developer, you can head over to the developer documentation and get started. You can also contact us at info@wizkers.io and find out how we can help. Wizkers and Open Source Wizkers is a fully open source project, released under the terms of the MIT License . Some libraries included in Wizkers are subject to a couple of light restrictions and not compatible with the MIT license, please check the source code headers. Wizkers also uses a variety of third party libraries which are released under multiple license schemes, but are all compatible with this global license. Installation instructions Below are installation instructions for the three run modes supported on Wizkers: Chrome packaged app Wizkers can be downloaded from the Chrome app store, and is available on any computer that can run Chrome. This includes MacOS, Linux and Windows. Chrome packaged apps rely on the Chrome runtime to run - this means you need to have Google Chrome installed on the computer - but otherwise behave as native applications. Android app Wizkers will eventually be available on the Google Play store, but in the mean time, you will have to build Wizkers for Android yourself (refer to the developer documentation for details on how to do this). Server You can also run Wizkers as a standalone server. You then interact with a running Wizkers instance using a web browser. The advantage of running Wizkers in this mode, is that you can leave it connected to instruments 24/7. Server mode supports advanced features such as user management and user rights, multiple open instruments at the same time. Refer to the developer documentation for instructions on how to checkout Wizkers from Github and build the server version.","title":"Overview"},{"location":"#wizkers-documentation","text":"Wizkers is a universal open source application for both data visualization and control of various kinds of scientific instruments. It is a full Javascript/HTML5 application which runs on nearly any computer, phone or tablet. It can also run as a standalone server application, on any Linux platform, from a simple Raspberry Pi or Beaglebone black, all the way to cloud-hosted AWS instances, which gives it tremendous flexibility. Basically, it is a real open source simple 'cloud' system and one of the only 'cloud' projects out there with a fully open source (GNU Affero General Public License) front-end and backend. Out of the box, Wizkers supports a variety of instruments, and it can easily be extended to support additional devices. This documentation covers both user instructions and developer docs .","title":"Wizkers documentation"},{"location":"#what-can-wizkers-do","text":"At the core, Wizkers is designed to interface with various kind of sensors and scientific instruments and visualize and record their data. Wizkers lets you: Visualize the readings coming from your sensors and instruments Record those readings Forward the readings to a variety of backends - from HTTP REST APIs to WebRTC You can use this capability to forward data to IoT services, and remain independent Remotely control and configure the sensors and instruments connected to it","title":"What can Wizkers do?"},{"location":"#who-is-wizkers-for","text":"Wizkers is an ideal fit for anyone building or using measurement instruments, as it provides all the necessary capabilities to create an instrument utility that works on any operating system or device, is easy to maintain and fast to deploy. This enables instrument and sensor designers to focus on their project without spending too much time on the software part, and still create a best of class interface. Wizkers is also a great solution for any sensor deployment project where there is a desire to be truly independent from third party service providers, or the deployment occurs in regions where 24/7 Internet connectivity is not a given. For this reason, Wizkers is popular with NGOs.","title":"Who is Wizkers for ?"},{"location":"#why-wizkers","text":"Wizkers came to life for a couple of simple reasons: Most lab instruments have no decent computer utilities even though they have great connectivity. Those utilities are usually less than user-friendly, Windows-only, and poorly supported. It is becoming easier and easier to create and use many small and not-so-small sensors that generate data, but finding good ways to record, visualize and analyze their output, and remotely configure and control them with an engaging interface is often an afterthought. Most IoT services are all about 'dumb' sensors and easy and free APIs, but at the cost of a completely closed backend and limited control on your data once it is sent over. Basically, you are only getting access to half of the infrastructure, and the arguably most critical part is outside of your control. But there are many situations where you want to be able to deploy your own infrastructure without having to rely on a third party, especially if you are not deploying millions of sensors, or you cannot do 24/7 connectivity for some reason. Another issue we have experienced many times over the last few years, is that most IoT startups cannot provide any kind of continuity and stability for a project: from Pinocc.io to Pachube, Spark.io, Helium.com, etc, most of those companies tend to review and modify their business model every couple of months, and put any project that relies on them at great risk. Wizkers solves all this issues with one elegant framework: In a nutshell, Wizkers is both the missing link between your sensors, your instruments and the Cloud, as well as the missing universal utility for scientific instruments which works on any OS and any computer.","title":"Why Wizkers ?"},{"location":"#wizkers-overview","text":"","title":"Wizkers overview"},{"location":"#supported-instruments","text":"The following instruments are currently supported in Wizkers (as of August 2015): Instrument name Chrome Android Server Native (nwjs.io) Medcom Onyx Yes Yes Yes Yes Medcom Geiger Link Yes Yes Yes Yes Medcom Blue Onyx Chromebooks only Yes No Yes Medcom Hawk Nest - - Yes - Safecast bGeigie Nano Chromebooks only Yes - Yes Elecraft KX3 Yes Yes Yes Yes Remote KX3 (Wizkers to Wizkers) Yes Not tested Not tested Yes Elecraft KXPA100 Yes Yes Yes Yes Kenwood V71A Yes Yes Yes Yes Fluke 287/289 Yes Yes Yes Yes Fried Circuits USB tester OLED backpack Yes Yes Yes Yes Fried Circuits USB tested BTLE backpack Chromebooks only Yes No - Simple serial terminal Yes Yes Yes Yes Sark 110 antena analyzer Yes Yes Yes Yes Kromek Sigma 25 Yes Yes Yes Yes Kestrel 5000 series Yes Yes Yes Yes Kestrel DROP Series Yes Yes Yes Yes","title":"Supported instruments"},{"location":"#what-if-my-instrument-is-not-supported","text":"We can help! If you are a developer, you can head over to the developer documentation and get started. You can also contact us at info@wizkers.io and find out how we can help.","title":"What if my instrument is not supported ?"},{"location":"#wizkers-and-open-source","text":"Wizkers is a fully open source project, released under the terms of the MIT License . Some libraries included in Wizkers are subject to a couple of light restrictions and not compatible with the MIT license, please check the source code headers. Wizkers also uses a variety of third party libraries which are released under multiple license schemes, but are all compatible with this global license.","title":"Wizkers and Open Source"},{"location":"#installation-instructions","text":"Below are installation instructions for the three run modes supported on Wizkers:","title":"Installation instructions"},{"location":"#chrome-packaged-app","text":"Wizkers can be downloaded from the Chrome app store, and is available on any computer that can run Chrome. This includes MacOS, Linux and Windows. Chrome packaged apps rely on the Chrome runtime to run - this means you need to have Google Chrome installed on the computer - but otherwise behave as native applications.","title":"Chrome packaged app"},{"location":"#android-app","text":"Wizkers will eventually be available on the Google Play store, but in the mean time, you will have to build Wizkers for Android yourself (refer to the developer documentation for details on how to do this).","title":"Android app"},{"location":"#server","text":"You can also run Wizkers as a standalone server. You then interact with a running Wizkers instance using a web browser. The advantage of running Wizkers in this mode, is that you can leave it connected to instruments 24/7. Server mode supports advanced features such as user management and user rights, multiple open instruments at the same time. Refer to the developer documentation for instructions on how to checkout Wizkers from Github and build the server version.","title":"Server"},{"location":"building/","text":"Building Wizkers Prerequisites (all platforms) The only prerequisite for building (and running Wizkers in server mode) are NodeJS and npm. You will need to install a recent version of NodeJS. This used to be a tricky requirement on Linux, but not anymore, since it is now easy to install Node JS using most package managers . Note that NodeJS is a project that evolves very fast, and pretty much 100% of all distributions out there ship with very outdated version of Node. Resist the temptation to use the version of Node that is shipped with your distribution, it won't work properly. Likewise, do not try to use you distribution's package manager to install Node sub-dependencies, those will also be outdated and will break. Like Python, NodeJS does not play very well with the classic packaging model, which is unfortunate but beyond the scope of this discussion... At the time of this writing, Wizkers can be built and run using Node version 8.x.x (aka \"LTS\" on the nodejs.org website). Platform-specific prerequisites MacOS No additional prerequisites. Linux (Debian and Ubuntu based Linux distributions) We assume here that you are starting with a computer/server/board running on Debian or Ubuntu Linux, or a variant. This includes for instance most Beaglebone images, Rapsberry Pi, etc. Installation of Linux itself is out of the scope of this document. On a new installation, you will need to install the basic development toolchains, as well as NodeJS and git: sudo apt-get install --yes ntpdate sudo ntpdate -b -s -u pool.ntp.org sudo apt-get install --yes build-essential sudo apt-get install --yes libudev-dev libusb-1.0-0-dev curl -sL https://deb.nodesource.com/setup_8.x | sudo -E bash - sudo apt-get install --yes nodejs sudo apt-get install --yes git You can then move on to checking out the code, as described in the next section. Node-serialport issues on Linux (Note: this might be outdated on current versions of Debian/Ubuntu, to be validated) You might have to add rules in udev to make sure the right entries are created in /dev/serial because Debian does not do it by default, at least on the BeagleBone. debian@aprs:~$ cat /etc/udev/rules.d/60-ed-persistent-serial.rules ENV{.ID_PORT}==\"\", SYMLINK+=\"serial/by-id/$env{ID_BUS}-$env{ID_SERIAL}-if$env{ID_USB_INTERFACE_NUM}\" ENV{.ID_PORT}==\"?*\", SYMLINK+=\"serial/by-id/$env{ID_BUS}-$env{ID_SERIAL}-if$env{ID_USB_INTERFACE_NUM}-port$env{.ID_PORT}\" This way, you will be able to list serial ports even on the most recent versions on node-serialport. Also, for Bluetooth Low Energy support without the need to run wizkers as root, you can adjust permissions on the NodeJS executable as described in the Noble documentation: sudo setcap cap_net_raw+eip $(eval readlink -f `which node`) Windows While there is no good reason why building Wizkers on Windows shouldn't work, I have never attempted it. If you would like to contribute instructions, please reach out at info@wizkers.io . Building steps (all platforms) Check out the code Wizkers is hosted on github . These instructions suggest you use \"git\", but you can actually simply download the source code as a ZIP archive here . The upside of using git, though, is that you can easily upgrade to newer version of wizkers at a later stage by typing a simple git pull from the wizkers directory and follow the gulp steps below again. Assuming you are using git: Create a work directory on your machine and check out the code from Github: git clone https://github.com/wizkers/wizkers.git cd wizkers/wizkers Build it - step 1 The next step is to install all dependencies using npm: sudo npm install -g gulp-cli npm install This can take from a couple of minutes to quite some time if you are building on a low power system such as a Beaglebone. Once all dependencies are installed, Wizkers uses 'gulp' as its build system. Gulp automates all build steps which would otherwise be pretty complex. Pick your run mode Wizkers supports multiple modes: server, nwjs, chrome, cordova, etc. Below is a short description of each mode: Mode name Description server Run in server mode (port 8090 by default) cordova Run as an Android or iOS application. The output of the build will be an Android or iOS app that you have to install on your device. nsjw Run as a native application using the nwjs.io framework. Instructions will be added below at a later stage on how to run Wizkers in that mode. chrome Run as a Chrome app. See below for instructions on how to run in that mode. Pick your flavor There are also multiple Flavors of Wizker: Wizkers:Radio, Wizkers:Nuclear, etc. You will need to indicate the build flavor on the command line by using the \"OEM\" variable. All build flavors correspond to an actual application that is built using the Wizkers framework, and they are listed in the \"oem\" directory. The flavors that are defined at the time of this writing are: Flavor name Description radio Wizkers:Radio nuclear Wizkers:Nuclear bench Work in progress, for benchtop instruments safecast Builds Safecast:Drive, the Safecast.org Android app Build it! You can now build wizkers in the mode/flavor of your choice. For instance, for Wizkers:Radio in 'server' mode: OEM=radio gulp server The results of the build are in the dist directory. Finalizing and packaging Once the base code is built through Gulp, the instructions below will show you how to finalize the build for the various run modes and launch Wizkers: Chrome app After building, the Chrome version of Wizkers will be ready in dist/chrome and dist/chrome-debug . The chrome-debug directory can be immediately loaded into Google Chrome by visiting (chrome://extensions) and loading Wizkers from there. The chrome version requires finalizing the compilation by launching build-toold/build-chrome.sh which will optimize the javascript code. The resulting Chrome app in dist/chrome will run faster but it won't be possible to debug it easily. Cordova (Android and/or iOS app) The Android app version of Wizker uses the Cordova framework to package Wizkers into a native Android application. The first thing to do is to install Cordova on your machine: npm install -g cordova Then cd to the dist/cordova-debug directory and add the target Cordova plaforms of your choice, and build, for instance: cordova platform add Android cordova build For further instructions on how to complete the build and install on your device, please refer to the Cordova documentation online. NWJS.io Work in progress, come back soon! Server The server build of Wizkers is available in dist/server . Simply go to that directory and launch the server: cd dist/server ./start_server.sh Wizkers will be available on port 8090 on your machine. If you are running a browser on the same machine you are running Wizkers on, simply visit http://localhost:8090/ and follow the instructions!","title":"Building"},{"location":"building/#building-wizkers","text":"","title":"Building Wizkers"},{"location":"building/#prerequisites-all-platforms","text":"The only prerequisite for building (and running Wizkers in server mode) are NodeJS and npm. You will need to install a recent version of NodeJS. This used to be a tricky requirement on Linux, but not anymore, since it is now easy to install Node JS using most package managers . Note that NodeJS is a project that evolves very fast, and pretty much 100% of all distributions out there ship with very outdated version of Node. Resist the temptation to use the version of Node that is shipped with your distribution, it won't work properly. Likewise, do not try to use you distribution's package manager to install Node sub-dependencies, those will also be outdated and will break. Like Python, NodeJS does not play very well with the classic packaging model, which is unfortunate but beyond the scope of this discussion... At the time of this writing, Wizkers can be built and run using Node version 8.x.x (aka \"LTS\" on the nodejs.org website).","title":"Prerequisites (all platforms)"},{"location":"building/#platform-specific-prerequisites","text":"","title":"Platform-specific prerequisites"},{"location":"building/#macos","text":"No additional prerequisites.","title":"MacOS"},{"location":"building/#linux-debian-and-ubuntu-based-linux-distributions","text":"We assume here that you are starting with a computer/server/board running on Debian or Ubuntu Linux, or a variant. This includes for instance most Beaglebone images, Rapsberry Pi, etc. Installation of Linux itself is out of the scope of this document. On a new installation, you will need to install the basic development toolchains, as well as NodeJS and git: sudo apt-get install --yes ntpdate sudo ntpdate -b -s -u pool.ntp.org sudo apt-get install --yes build-essential sudo apt-get install --yes libudev-dev libusb-1.0-0-dev curl -sL https://deb.nodesource.com/setup_8.x | sudo -E bash - sudo apt-get install --yes nodejs sudo apt-get install --yes git You can then move on to checking out the code, as described in the next section.","title":"Linux (Debian and Ubuntu based Linux distributions)"},{"location":"building/#node-serialport-issues-on-linux","text":"(Note: this might be outdated on current versions of Debian/Ubuntu, to be validated) You might have to add rules in udev to make sure the right entries are created in /dev/serial because Debian does not do it by default, at least on the BeagleBone. debian@aprs:~$ cat /etc/udev/rules.d/60-ed-persistent-serial.rules ENV{.ID_PORT}==\"\", SYMLINK+=\"serial/by-id/$env{ID_BUS}-$env{ID_SERIAL}-if$env{ID_USB_INTERFACE_NUM}\" ENV{.ID_PORT}==\"?*\", SYMLINK+=\"serial/by-id/$env{ID_BUS}-$env{ID_SERIAL}-if$env{ID_USB_INTERFACE_NUM}-port$env{.ID_PORT}\" This way, you will be able to list serial ports even on the most recent versions on node-serialport. Also, for Bluetooth Low Energy support without the need to run wizkers as root, you can adjust permissions on the NodeJS executable as described in the Noble documentation: sudo setcap cap_net_raw+eip $(eval readlink -f `which node`)","title":"Node-serialport issues on Linux"},{"location":"building/#windows","text":"While there is no good reason why building Wizkers on Windows shouldn't work, I have never attempted it. If you would like to contribute instructions, please reach out at info@wizkers.io .","title":"Windows"},{"location":"building/#building-steps-all-platforms","text":"","title":"Building steps (all platforms)"},{"location":"building/#check-out-the-code","text":"Wizkers is hosted on github . These instructions suggest you use \"git\", but you can actually simply download the source code as a ZIP archive here . The upside of using git, though, is that you can easily upgrade to newer version of wizkers at a later stage by typing a simple git pull from the wizkers directory and follow the gulp steps below again. Assuming you are using git: Create a work directory on your machine and check out the code from Github: git clone https://github.com/wizkers/wizkers.git cd wizkers/wizkers","title":"Check out the code"},{"location":"building/#build-it-step-1","text":"The next step is to install all dependencies using npm: sudo npm install -g gulp-cli npm install This can take from a couple of minutes to quite some time if you are building on a low power system such as a Beaglebone. Once all dependencies are installed, Wizkers uses 'gulp' as its build system. Gulp automates all build steps which would otherwise be pretty complex.","title":"Build it - step 1"},{"location":"building/#pick-your-run-mode","text":"Wizkers supports multiple modes: server, nwjs, chrome, cordova, etc. Below is a short description of each mode: Mode name Description server Run in server mode (port 8090 by default) cordova Run as an Android or iOS application. The output of the build will be an Android or iOS app that you have to install on your device. nsjw Run as a native application using the nwjs.io framework. Instructions will be added below at a later stage on how to run Wizkers in that mode. chrome Run as a Chrome app. See below for instructions on how to run in that mode.","title":"Pick your run mode"},{"location":"building/#pick-your-flavor","text":"There are also multiple Flavors of Wizker: Wizkers:Radio, Wizkers:Nuclear, etc. You will need to indicate the build flavor on the command line by using the \"OEM\" variable. All build flavors correspond to an actual application that is built using the Wizkers framework, and they are listed in the \"oem\" directory. The flavors that are defined at the time of this writing are: Flavor name Description radio Wizkers:Radio nuclear Wizkers:Nuclear bench Work in progress, for benchtop instruments safecast Builds Safecast:Drive, the Safecast.org Android app","title":"Pick your flavor"},{"location":"building/#build-it","text":"You can now build wizkers in the mode/flavor of your choice. For instance, for Wizkers:Radio in 'server' mode: OEM=radio gulp server The results of the build are in the dist directory.","title":"Build it!"},{"location":"building/#finalizing-and-packaging","text":"Once the base code is built through Gulp, the instructions below will show you how to finalize the build for the various run modes and launch Wizkers:","title":"Finalizing and packaging"},{"location":"building/#chrome-app","text":"After building, the Chrome version of Wizkers will be ready in dist/chrome and dist/chrome-debug . The chrome-debug directory can be immediately loaded into Google Chrome by visiting (chrome://extensions) and loading Wizkers from there. The chrome version requires finalizing the compilation by launching build-toold/build-chrome.sh which will optimize the javascript code. The resulting Chrome app in dist/chrome will run faster but it won't be possible to debug it easily.","title":"Chrome app"},{"location":"building/#cordova-android-andor-ios-app","text":"The Android app version of Wizker uses the Cordova framework to package Wizkers into a native Android application. The first thing to do is to install Cordova on your machine: npm install -g cordova Then cd to the dist/cordova-debug directory and add the target Cordova plaforms of your choice, and build, for instance: cordova platform add Android cordova build For further instructions on how to complete the build and install on your device, please refer to the Cordova documentation online.","title":"Cordova (Android and/or iOS app)"},{"location":"building/#nwjsio","text":"Work in progress, come back soon!","title":"NWJS.io"},{"location":"building/#server","text":"The server build of Wizkers is available in dist/server . Simply go to that directory and launch the server: cd dist/server ./start_server.sh Wizkers will be available on port 8090 on your machine. If you are running a browser on the same machine you are running Wizkers on, simply visit http://localhost:8090/ and follow the instructions!","title":"Server"},{"location":"deploying/","text":"Deploy Wizkers as a server application Wizkers runs great as a server application. In that mode, you access Wizkers through a standard browser (Google Chrome being the reference browser for our tests). This section describes the various database backends you can select when running Wizkers, as well as how you should configure it with reverse proxies like nginx. Selecting the database Wizkers will run fine out of the box with no particular additional configuration: for instance, for the \"Wizkers:Radio\" flavor, a simple OEM=radio gulp server cd dist/server ./start_server.sh will be enough to get you started. In that mode, Wizkers will use a disk database called LevelDB which is the default storage mechanism for PouchDB, the internal Wizkers database API. For larger deployments where you have potentially dozens or more sensors connected at once, levelDB will not be adequate, which is why Wizkers also supports standard CouchDB servers. The database engine is selected in server/pouchdb-config.js with the backend variable. Set it to CouchDB to use CouchDB rather than PouchDB (which is the default). var backend = 'CouchDB'; Do not forget to run OEM=XXX gulp server again after making a change. Configuring CouchDB Please head over to the CouchDB documentation for details on how to install CouchDB on your particular machine. Most Linux distributions already include Couch in their standard packages, so this should be very easy. By default, CouchDB binds to the 127.0.0.1 interface, and lets anyone connect to it with no authentication. You probably do not want this for a production system, and should take the appropriate steps to secure your installation. For development purposes, this should be fine, though. The only Wizkers-specific configuration you should do on CouchDB (and this can become critical for large number of connected sensors), is configure the auto_compaction daemon so that there are no runaway databases due to frequent document updates. This can be done from the admin interface of couchdb at http://127.0.0.1:5984/_utils . From this interface, head over to \"configuration\" (menu on the right) and add the configuration for compactions: at the bottom of the page, click on the \"add a new section\" link, and enter the following: Section: compactions Option: _default value: [{db_fragmentation, \"70%\"}, {view_fragmentation, \"60%\"}] This way, CouchDB will make sure that even with frequent document updates, the overall database size does not get out of hand. Migrating from Pouch to Couch If you started your deployment with PouchDB and later decided to migrate to CouchDB, a script in the server/utils directory will automatically migrate all your data and settings to CouchDB. First of all, make sure Wizkers is not running. Then go to dist/server/utils and launch node migrate_to_couchdb.js . The process should take from a couple of seconds to a couple of minutes depending on how much data you have in your database. Last, make sure that the backend variable in dist/server/pouchdb-config.jg is set to CouchDB , then relaunch Wizkers. You should be able to login exactly like before. Wizkers auto start On a Linux distribution, you will probably want to have Wizkers automatically start when the device/computer boots. The init scripts below give you an example of how to do this. Tweak as needed! On recent Ubuntu distributions, you will need to create a /etc/init/wizkers.conf script. Note that you can enable debugging output in /tmp or not, this is optional... # Ubuntu upstart file at /etc/init/wizkers.conf start on runlevel [2345] stop on runlevel [06] setuid ubuntu script export HOME=\"/home/ubuntu/wizkers/server/dist/server\" ENABLE_CONTROLLER=\"yes\" export DEBUG=\"wizkers*\" DAEMON_ARGS=\"/home/ubuntu/wizkers/server/dist/server/server.js\" if [ -f /etc/default/wizkers ]; then . /etc/default/wizkers; fi if [ \"x$ENABLE_CONTROLLER\" = \"xyes\" ]; then cd $HOME; exec node $DAEMON_ARGS > /tmp/wizkers.log 2>&1 ; fi end script On Debian-style distributions such as Raspberry Pi's \"raspbian\", you will need to create /etc/init.d/wizkers as shown below. Don't forget to adjust the path where Wizkers is located: #!/bin/sh # kFreeBSD do not accept scripts as interpreters, using #!/bin/sh and sourcing. if [ true != \"$INIT_D_SCRIPT_SOURCED\" ] ; then set \"$0\" \"$@\"; INIT_D_SCRIPT_SOURCED=true . /lib/init/init-d-script fi ### BEGIN INIT INFO # Provides: wizkers # Required-Start: $network $local_fs $remote_fs $time # Required-Stop: $remote_fs # Default-Start: 2 3 4 5 # Default-Stop: 0 1 6 ### END INIT INFO # Author: Ed Lafargue <ed@wizkers.io> # export PATH=$PATH:/usr/local/bin DESC=\"Wizkers server\" DAEMON=`which node` DAEMON_ARGS='/home/pi/wizkers/wizkers/dist/server/server.js' export DEBUG=wizkers:*,att test -x $DAEMON || exit 0 case \"$1\" in start) log_begin_msg \"Starting Wizkers\" cd /home/pi/wizkers/wizkers/dist/server # Export the NODE_PATH variable to tell node where to get its modules export NODE_PATH=. export NOBLE_MULTI_ROLE=1 # Shortcut to (again) help node find the modules that are from the web # root: if [ ! -e app ]; then ln -s www/js/app . fi NOBLE_MULTI_ROLE=1 node server.js 2>&1 | logger -p local0.info -t wizkers & log_end_msg 0 ;; stop) ;; restart|force-reload) $0 start ;; status) $PROGRAM \u2013show ;; *) log_failure_msg \"Usage: $PROGRAM {start|stop|restart|force-reload|status}\" exit 1 esac exit 0 Wizkers behind a proxy In a production environment, you will want to run Wizkers behind a web server that will be running on port 80. NGINX or just Apache 2 are two good choices: NGINX To be detailed Apache2 On Apache2, a 'sites-available' configuration that is adequate to run Wizkers is as follows. This works for Apache 2.4 + with mod rewrite and mod proxy enabled. The trick being to handle socket.io in websockets mode without having it fall back into http polling mode. You will need to enable a couple of apache2 modules to make the configuration below work a2enmod rewrite proxy proxy_http proxy_wstunnel # Setup for Wizkers <VirtualHost *:80> ServerAlias * RewriteEngine On RewriteCond %{REQUEST_URI} ^/socket.io [NC] RewriteCond %{QUERY_STRING} transport=websocket [NC] RewriteRule /(.*) ws://localhost:8090/$1 [P,L] ProxyPass /aprs ! ProxyPass / http://localhost:8090/ ProxyPassReverse / http://localhost:8090/ </VirtualHost>","title":"Deploying (server)"},{"location":"deploying/#deploy-wizkers-as-a-server-application","text":"Wizkers runs great as a server application. In that mode, you access Wizkers through a standard browser (Google Chrome being the reference browser for our tests). This section describes the various database backends you can select when running Wizkers, as well as how you should configure it with reverse proxies like nginx.","title":"Deploy Wizkers as a server application"},{"location":"deploying/#selecting-the-database","text":"Wizkers will run fine out of the box with no particular additional configuration: for instance, for the \"Wizkers:Radio\" flavor, a simple OEM=radio gulp server cd dist/server ./start_server.sh will be enough to get you started. In that mode, Wizkers will use a disk database called LevelDB which is the default storage mechanism for PouchDB, the internal Wizkers database API. For larger deployments where you have potentially dozens or more sensors connected at once, levelDB will not be adequate, which is why Wizkers also supports standard CouchDB servers. The database engine is selected in server/pouchdb-config.js with the backend variable. Set it to CouchDB to use CouchDB rather than PouchDB (which is the default). var backend = 'CouchDB'; Do not forget to run OEM=XXX gulp server again after making a change.","title":"Selecting the database"},{"location":"deploying/#configuring-couchdb","text":"Please head over to the CouchDB documentation for details on how to install CouchDB on your particular machine. Most Linux distributions already include Couch in their standard packages, so this should be very easy. By default, CouchDB binds to the 127.0.0.1 interface, and lets anyone connect to it with no authentication. You probably do not want this for a production system, and should take the appropriate steps to secure your installation. For development purposes, this should be fine, though. The only Wizkers-specific configuration you should do on CouchDB (and this can become critical for large number of connected sensors), is configure the auto_compaction daemon so that there are no runaway databases due to frequent document updates. This can be done from the admin interface of couchdb at http://127.0.0.1:5984/_utils . From this interface, head over to \"configuration\" (menu on the right) and add the configuration for compactions: at the bottom of the page, click on the \"add a new section\" link, and enter the following: Section: compactions Option: _default value: [{db_fragmentation, \"70%\"}, {view_fragmentation, \"60%\"}] This way, CouchDB will make sure that even with frequent document updates, the overall database size does not get out of hand.","title":"Configuring CouchDB"},{"location":"deploying/#migrating-from-pouch-to-couch","text":"If you started your deployment with PouchDB and later decided to migrate to CouchDB, a script in the server/utils directory will automatically migrate all your data and settings to CouchDB. First of all, make sure Wizkers is not running. Then go to dist/server/utils and launch node migrate_to_couchdb.js . The process should take from a couple of seconds to a couple of minutes depending on how much data you have in your database. Last, make sure that the backend variable in dist/server/pouchdb-config.jg is set to CouchDB , then relaunch Wizkers. You should be able to login exactly like before.","title":"Migrating from Pouch to Couch"},{"location":"deploying/#wizkers-auto-start","text":"On a Linux distribution, you will probably want to have Wizkers automatically start when the device/computer boots. The init scripts below give you an example of how to do this. Tweak as needed! On recent Ubuntu distributions, you will need to create a /etc/init/wizkers.conf script. Note that you can enable debugging output in /tmp or not, this is optional... # Ubuntu upstart file at /etc/init/wizkers.conf start on runlevel [2345] stop on runlevel [06] setuid ubuntu script export HOME=\"/home/ubuntu/wizkers/server/dist/server\" ENABLE_CONTROLLER=\"yes\" export DEBUG=\"wizkers*\" DAEMON_ARGS=\"/home/ubuntu/wizkers/server/dist/server/server.js\" if [ -f /etc/default/wizkers ]; then . /etc/default/wizkers; fi if [ \"x$ENABLE_CONTROLLER\" = \"xyes\" ]; then cd $HOME; exec node $DAEMON_ARGS > /tmp/wizkers.log 2>&1 ; fi end script On Debian-style distributions such as Raspberry Pi's \"raspbian\", you will need to create /etc/init.d/wizkers as shown below. Don't forget to adjust the path where Wizkers is located: #!/bin/sh # kFreeBSD do not accept scripts as interpreters, using #!/bin/sh and sourcing. if [ true != \"$INIT_D_SCRIPT_SOURCED\" ] ; then set \"$0\" \"$@\"; INIT_D_SCRIPT_SOURCED=true . /lib/init/init-d-script fi ### BEGIN INIT INFO # Provides: wizkers # Required-Start: $network $local_fs $remote_fs $time # Required-Stop: $remote_fs # Default-Start: 2 3 4 5 # Default-Stop: 0 1 6 ### END INIT INFO # Author: Ed Lafargue <ed@wizkers.io> # export PATH=$PATH:/usr/local/bin DESC=\"Wizkers server\" DAEMON=`which node` DAEMON_ARGS='/home/pi/wizkers/wizkers/dist/server/server.js' export DEBUG=wizkers:*,att test -x $DAEMON || exit 0 case \"$1\" in start) log_begin_msg \"Starting Wizkers\" cd /home/pi/wizkers/wizkers/dist/server # Export the NODE_PATH variable to tell node where to get its modules export NODE_PATH=. export NOBLE_MULTI_ROLE=1 # Shortcut to (again) help node find the modules that are from the web # root: if [ ! -e app ]; then ln -s www/js/app . fi NOBLE_MULTI_ROLE=1 node server.js 2>&1 | logger -p local0.info -t wizkers & log_end_msg 0 ;; stop) ;; restart|force-reload) $0 start ;; status) $PROGRAM \u2013show ;; *) log_failure_msg \"Usage: $PROGRAM {start|stop|restart|force-reload|status}\" exit 1 esac exit 0","title":"Wizkers auto start"},{"location":"deploying/#wizkers-behind-a-proxy","text":"In a production environment, you will want to run Wizkers behind a web server that will be running on port 80. NGINX or just Apache 2 are two good choices:","title":"Wizkers behind a proxy"},{"location":"deploying/#nginx","text":"To be detailed","title":"NGINX"},{"location":"deploying/#apache2","text":"On Apache2, a 'sites-available' configuration that is adequate to run Wizkers is as follows. This works for Apache 2.4 + with mod rewrite and mod proxy enabled. The trick being to handle socket.io in websockets mode without having it fall back into http polling mode. You will need to enable a couple of apache2 modules to make the configuration below work a2enmod rewrite proxy proxy_http proxy_wstunnel # Setup for Wizkers <VirtualHost *:80> ServerAlias * RewriteEngine On RewriteCond %{REQUEST_URI} ^/socket.io [NC] RewriteCond %{QUERY_STRING} transport=websocket [NC] RewriteRule /(.*) ws://localhost:8090/$1 [P,L] ProxyPass /aprs ! ProxyPass / http://localhost:8090/ ProxyPassReverse / http://localhost:8090/ </VirtualHost>","title":"Apache2"},{"location":"devdoc/","text":"Developer documentation Building Wizkers Refer to the build instructions to do a check out and initial build of the code. Wizkers mostly being a javascript application, there is no \"compilation\" per se, but rather automated code optimization, download of dependencies, etc. Wizkers architecture Due to its multiple supported run modes, the structure of Wizkers is split between a \u201cfront-end\u201d and a \u201cback-end\u201d part, even when it runs 100% in a browser. The diagram below shows how the the various components of Wizkers interact with each other. If you want to add new instruments, this will be a good reference, though you will usually not need to go deep into those modules, and only implement instrument views and the instruments\u2019s front-end/back-end API. Global Wizkers services The Wizkers front-end exposes a couple of global objects/services throughout the application: The Instrument manager The Output manager The link manager All communication between the various parts of Wizkers, whether they are located in the browser or on the server, are done using those three services. Wizkers also exposes a couple of utility services: The statistics service, which enables the connection of Wizkers to analytics services The global settings The link manager The link manager is the interface between the front-end and the back-end of Wizkers. In particular, the front-end only talks to instruments through the link manager. Even when Wizkers is running on its own (not in server mode), it makes use of the link manager, which makes it possible to use a single architecture for both in-app and server modes. In server mode, the link manager uses socket.io to communicate with the server for all commands and instrument data - the HTML and javascript resources are loaded directly using HTTP. In Chrome or Cordova mode, the link manager talks to the chromeSocket.js object, which emulates the API of socker.io but implements the backend on the app directly. The Instrument manager The instrument manager loads new instruments, switches between instruments. The Output manager The output manager subscribes to all data coming in from instruments, is in charge or starting/stopping outputs depending on what is enabled for a particular instrument, and forwards instrument data to all active outputs. Source tree organization The Wizkers source tree is organized as follows: README.md # Top level Readme, for the benefit of Github build-tools # A couple of build scripts used to optimize the javascript for the Chrome version cordova # Cordova-specific files used to build Wizkers documentation # The documentation you are reading right now server # Files used by Wizkers in server mode chrome # Files used by Wizkers in Chrome mode gulpfile.js # The toplevel gulpfile merges # er.... package.json # npm toplevel package file www # The complete javascript app - frontend only in server mode, complete app in Chrome/Cordova mode www tree Most of the code of Wizkers is contained in the www directory, which is organized as follows: www/css # Stylesheets used by the app www/fonts # Fonts used be the app www/img # Images used by the app www/js # The core of Wizkers, see below for organization ... # A couple of extra files used for examples The js directory is then structured in a modular fashion, to make it easy to extend Wizkers: www/js/app # The main Wizkers app www/js/app/connections # Used in Chrome/Cordova mode: low-level drivers for serial/bluetooth/etc www/js/app/instruments # All instruments supported by Wizkers www/js/app/lib # Wizkers shared libraries www/js/app/models # Wizkers Backbone models www/js/app/outputs # Output plugins www/js/app/views # Wizkers views (screens) www/js/lib # All third party libraries used by Wizkers www/js/tpl # All HTML templates used by the various Wizkers screens/views. Run-mode specific trees The cordova , server and chrome directories contain all the files that are specific to those run-modes. When building Wizkers, Gulp will add the contents of those directories to the dist directory to end up with a working version of Wizkers for those various run modes.","title":"Overview"},{"location":"devdoc/#developer-documentation","text":"","title":"Developer documentation"},{"location":"devdoc/#building-wizkers","text":"Refer to the build instructions to do a check out and initial build of the code. Wizkers mostly being a javascript application, there is no \"compilation\" per se, but rather automated code optimization, download of dependencies, etc.","title":"Building Wizkers"},{"location":"devdoc/#wizkers-architecture","text":"Due to its multiple supported run modes, the structure of Wizkers is split between a \u201cfront-end\u201d and a \u201cback-end\u201d part, even when it runs 100% in a browser. The diagram below shows how the the various components of Wizkers interact with each other. If you want to add new instruments, this will be a good reference, though you will usually not need to go deep into those modules, and only implement instrument views and the instruments\u2019s front-end/back-end API.","title":"Wizkers architecture"},{"location":"devdoc/#global-wizkers-services","text":"The Wizkers front-end exposes a couple of global objects/services throughout the application: The Instrument manager The Output manager The link manager All communication between the various parts of Wizkers, whether they are located in the browser or on the server, are done using those three services. Wizkers also exposes a couple of utility services: The statistics service, which enables the connection of Wizkers to analytics services The global settings","title":"Global Wizkers services"},{"location":"devdoc/#the-link-manager","text":"The link manager is the interface between the front-end and the back-end of Wizkers. In particular, the front-end only talks to instruments through the link manager. Even when Wizkers is running on its own (not in server mode), it makes use of the link manager, which makes it possible to use a single architecture for both in-app and server modes. In server mode, the link manager uses socket.io to communicate with the server for all commands and instrument data - the HTML and javascript resources are loaded directly using HTTP. In Chrome or Cordova mode, the link manager talks to the chromeSocket.js object, which emulates the API of socker.io but implements the backend on the app directly.","title":"The link manager"},{"location":"devdoc/#the-instrument-manager","text":"The instrument manager loads new instruments, switches between instruments.","title":"The Instrument manager"},{"location":"devdoc/#the-output-manager","text":"The output manager subscribes to all data coming in from instruments, is in charge or starting/stopping outputs depending on what is enabled for a particular instrument, and forwards instrument data to all active outputs.","title":"The Output manager"},{"location":"devdoc/#source-tree-organization","text":"The Wizkers source tree is organized as follows: README.md # Top level Readme, for the benefit of Github build-tools # A couple of build scripts used to optimize the javascript for the Chrome version cordova # Cordova-specific files used to build Wizkers documentation # The documentation you are reading right now server # Files used by Wizkers in server mode chrome # Files used by Wizkers in Chrome mode gulpfile.js # The toplevel gulpfile merges # er.... package.json # npm toplevel package file www # The complete javascript app - frontend only in server mode, complete app in Chrome/Cordova mode","title":"Source tree organization"},{"location":"devdoc/#www-tree","text":"Most of the code of Wizkers is contained in the www directory, which is organized as follows: www/css # Stylesheets used by the app www/fonts # Fonts used be the app www/img # Images used by the app www/js # The core of Wizkers, see below for organization ... # A couple of extra files used for examples The js directory is then structured in a modular fashion, to make it easy to extend Wizkers: www/js/app # The main Wizkers app www/js/app/connections # Used in Chrome/Cordova mode: low-level drivers for serial/bluetooth/etc www/js/app/instruments # All instruments supported by Wizkers www/js/app/lib # Wizkers shared libraries www/js/app/models # Wizkers Backbone models www/js/app/outputs # Output plugins www/js/app/views # Wizkers views (screens) www/js/lib # All third party libraries used by Wizkers www/js/tpl # All HTML templates used by the various Wizkers screens/views.","title":"www tree"},{"location":"devdoc/#run-mode-specific-trees","text":"The cordova , server and chrome directories contain all the files that are specific to those run-modes. When building Wizkers, Gulp will add the contents of those directories to the dist directory to end up with a working version of Wizkers for those various run modes.","title":"Run-mode specific trees"},{"location":"instruments/","text":"","title":"Instruments"},{"location":"userdoc/","text":"Wizkers User documentation Welcome to the user documentation of Wizkers. This section will help you make the most of the various capabilities of Wizkers. Refer to the introduction for installation instructions. Home screen The home screen contains three main zones: Connect/Setup/Record zone Main view / Live view Side view The first time you start Wizkers, you will need to create a new instrument, as described in the next section. Connecting instruments The top buttons are pretty much self-explanatory: the \u201cConnect\u201d button opens the connection to the instrument. The \u201cDevice Setup\u201d button will only be enabled if the device supports a Setup screen (not all do). Last, the \u201cRecord Session\u201d button lets you do a live recording of the data coming in from the device. You can view the logs that are saved there in the \u201cLogs and recordings\u201d screen. Configuring instruments All instrument configuration is done on the \u201cInstruments\u201d screen. The first time you start the application, no instruments will be present. To create a new instrument, click on \u201cAdd Instrument\u201d card: After pressing \u201cAdd Instrument\u201c, you will be presented with a blank configuration screen, as shown below. Some instruments display extra settings, but the following is always present: First of all, give a \u201cFriendly Name\u201d to your instrument, and select the correct instrument type. Depending on the instrument type, the \"port\" section will be different. Port can be: A serial port A bluetooth device A network address An API Key Refer to the documentation of each instrument for more details on how to configure those fields. The Live view length option defines the time length of the the home screen live view - by defaults, Wizkers displays the last five minutes of data, or last 500 points. Polling period defines how often Wizkers requests information from the instrument. Some instruments will send data at their own rate, in which case this setting will be unused for that instrument. Logs and recordings The Logs and recordings screen gives you access to all the recordings and logs saved on Wizkers, as well as an interface to download device logs if the currently connected instrument supports this. Outputs Output plugins are one of the great features of Wizkers: using those plugins, you can automatically send the data generated by your instruments to various backend services. At the moment, Wizkers ships with four output plugins: Generic REST output Safecast output HAM Radio \u201crigctld\u201d emulation plugin , for remote control of radios. WebRTC Output Creating and configuring an output All output plugins share quite a few settings: selecting what fields should be sent to the output, how often and with what conditions: When you create an output from the \u201cData Output\u201d screen (option on the top menu bar), you will see the screen below: Note: you should be connected to the current instrument before creating an output, because the output plugin detects the data sent by the instrument for creating its configuration. You can select the output plugin, give it a name and write notes in the top part of the window. The section on the right tells you when the plugin was last triggered with success, when it last attempted to send data, and what the last message from the backend was. Very useful for debugging. Then the screen contains three tabs: \u201cData to send\u201d, \u201cWhen to send it\u201d, \u201cOutput Settings\u201d. Only the last one (\u201cOutput Settings\u201d) is plugin-specific, the first two are identical for all output plugins. Data to send Again, you need to be connected to your instrument in order to be able to do anything with this screen. If not, it only displays a help message encouraging you to do so. Wizkers in server mode In server mode, you connect to Wizkers by pointing your Chrome browser to the IP address of the computer running Wizkers. In this mode, Wizkers will behave a little bit differently: It will enforce a simple user authentication mechanism It will support multiple open instruments at once It will keep all open instruments connected even when the user logs out of the interface This makes it possible to use Wizkers for autonomous monitoring stations. When combined with local recording and output capabilties, this actually turns Wizkers into a pretty powerful system. User authentication The first time you access Wizkesr through the network, a default admin user will be created. Wizkers will force you to change the default admin password before letting you access most of its functionality. TODO: describe user roles Autorecord and autoreconnect Wizkers is designed to be a very resilient system: when running by itself on small embedded devices, there can be situations such as power cuts which will lead the device to reboot. For this reason, in server mode you will see two extra flags on Wizkers on each instrument configuration screen: Those two options are fairly self-explanatory: when the Wizkers server is started, it will go through all configured instruments, and automatically reconnect (and start recording) them according to those check boxes. Multiple open devices While Wizkers in Chrome and Android modes only supports one open instrument at a time, you can open multiple instruments simultaneously in server mode, and simply switch from one to another without closing them. In the \"Instruments\" screen, you will see a little green badge next to all connected instruments.","title":"Users"},{"location":"userdoc/#wizkers-user-documentation","text":"Welcome to the user documentation of Wizkers. This section will help you make the most of the various capabilities of Wizkers. Refer to the introduction for installation instructions.","title":"Wizkers User documentation"},{"location":"userdoc/#home-screen","text":"The home screen contains three main zones: Connect/Setup/Record zone Main view / Live view Side view The first time you start Wizkers, you will need to create a new instrument, as described in the next section.","title":"Home screen"},{"location":"userdoc/#connecting-instruments","text":"The top buttons are pretty much self-explanatory: the \u201cConnect\u201d button opens the connection to the instrument. The \u201cDevice Setup\u201d button will only be enabled if the device supports a Setup screen (not all do). Last, the \u201cRecord Session\u201d button lets you do a live recording of the data coming in from the device. You can view the logs that are saved there in the \u201cLogs and recordings\u201d screen.","title":"Connecting instruments"},{"location":"userdoc/#configuring-instruments","text":"All instrument configuration is done on the \u201cInstruments\u201d screen. The first time you start the application, no instruments will be present. To create a new instrument, click on \u201cAdd Instrument\u201d card: After pressing \u201cAdd Instrument\u201c, you will be presented with a blank configuration screen, as shown below. Some instruments display extra settings, but the following is always present: First of all, give a \u201cFriendly Name\u201d to your instrument, and select the correct instrument type. Depending on the instrument type, the \"port\" section will be different. Port can be: A serial port A bluetooth device A network address An API Key Refer to the documentation of each instrument for more details on how to configure those fields. The Live view length option defines the time length of the the home screen live view - by defaults, Wizkers displays the last five minutes of data, or last 500 points. Polling period defines how often Wizkers requests information from the instrument. Some instruments will send data at their own rate, in which case this setting will be unused for that instrument.","title":"Configuring instruments"},{"location":"userdoc/#logs-and-recordings","text":"The Logs and recordings screen gives you access to all the recordings and logs saved on Wizkers, as well as an interface to download device logs if the currently connected instrument supports this.","title":"Logs and recordings"},{"location":"userdoc/#outputs","text":"Output plugins are one of the great features of Wizkers: using those plugins, you can automatically send the data generated by your instruments to various backend services. At the moment, Wizkers ships with four output plugins: Generic REST output Safecast output HAM Radio \u201crigctld\u201d emulation plugin , for remote control of radios. WebRTC Output","title":"Outputs"},{"location":"userdoc/#creating-and-configuring-an-output","text":"All output plugins share quite a few settings: selecting what fields should be sent to the output, how often and with what conditions: When you create an output from the \u201cData Output\u201d screen (option on the top menu bar), you will see the screen below: Note: you should be connected to the current instrument before creating an output, because the output plugin detects the data sent by the instrument for creating its configuration. You can select the output plugin, give it a name and write notes in the top part of the window. The section on the right tells you when the plugin was last triggered with success, when it last attempted to send data, and what the last message from the backend was. Very useful for debugging. Then the screen contains three tabs: \u201cData to send\u201d, \u201cWhen to send it\u201d, \u201cOutput Settings\u201d. Only the last one (\u201cOutput Settings\u201d) is plugin-specific, the first two are identical for all output plugins.","title":"Creating and configuring an output"},{"location":"userdoc/#data-to-send","text":"Again, you need to be connected to your instrument in order to be able to do anything with this screen. If not, it only displays a help message encouraging you to do so.","title":"Data to send"},{"location":"userdoc/#wizkers-in-server-mode","text":"In server mode, you connect to Wizkers by pointing your Chrome browser to the IP address of the computer running Wizkers. In this mode, Wizkers will behave a little bit differently: It will enforce a simple user authentication mechanism It will support multiple open instruments at once It will keep all open instruments connected even when the user logs out of the interface This makes it possible to use Wizkers for autonomous monitoring stations. When combined with local recording and output capabilties, this actually turns Wizkers into a pretty powerful system.","title":"Wizkers in server mode"},{"location":"userdoc/#user-authentication","text":"The first time you access Wizkesr through the network, a default admin user will be created. Wizkers will force you to change the default admin password before letting you access most of its functionality. TODO: describe user roles","title":"User authentication"},{"location":"userdoc/#autorecord-and-autoreconnect","text":"Wizkers is designed to be a very resilient system: when running by itself on small embedded devices, there can be situations such as power cuts which will lead the device to reboot. For this reason, in server mode you will see two extra flags on Wizkers on each instrument configuration screen: Those two options are fairly self-explanatory: when the Wizkers server is started, it will go through all configured instruments, and automatically reconnect (and start recording) them according to those check boxes.","title":"Autorecord and autoreconnect"},{"location":"userdoc/#multiple-open-devices","text":"While Wizkers in Chrome and Android modes only supports one open instrument at a time, you can open multiple instruments simultaneously in server mode, and simply switch from one to another without closing them. In the \"Instruments\" screen, you will see a little green badge next to all connected instruments.","title":"Multiple open devices"},{"location":"dev/api/","text":"Wizkers API access in server mode When running on a server, you can also interact with it using a REST API, so that all the data from the server can be queried/streamed to external systems. Live recording Wizkers exposes a public \"live recording\" API, which lets you query data that is currently being recorded. The syntax is as follows /live/:id/:period with id being the instrument ID, and period being in minutes - get the live recording for the last period minutes. Low level API access You can access the low level RESTFUL API of Wizkers using the standard authentication mechanism that is used by the Wizkers front-end web app. The simple Shell script below demonstrates how to get a list of instruments in JSON format. #!/bin/sh ## Example of Wizkers authentication then API request ## Save cookies to the \"cookies.txt\" file curl --cookie-jar cookies.txt -H \"Content-Type: application/json\" -X POST http://localhost:8090/login -d \"{\\\"email\\\": \\\"admin\\\", \\\"password\\\": \\\"abc123\\\"}\" ## Now you can do queries: curl --cookie cookies.txt -X GET http://localhost:8090/instruments Listing instruments You can get a list of all instruments registered in a Wizkers instance by doing an HTTP GET to /instruments/ . Note that this returns all instruments contents, not only a list of references. Example below: [ { \"name\":\"Piglet\", \"type\":\"simple_serial\", \"tag\":\"\", \"uuid\":\"00000000 (n.a.)\", \"port\":\"/dev/cu.usbserial-FTGDPEGI\", \"comment\":\"enter your notes here\", \"icon\":\"\", \"liveviewspan\":600, \"liveviewperiod\":1, \"liveviewlogscale\":false, \"metadata\":{\"baudrate\":\"9600\",\"lines\":\"40\"}, \"_id\":\"5AD6B170-A8AC-820E-9070-6DB9619661C4\", \"_rev\":\"19-5199b8924f8388771d32d13f0b26c508\" }, { \"name\":\"OLED\", \"type\":\"fcoledv1\", \"tag\":\"\", \"uuid\":\"00000000 (n.a.)\", \"port\":\"/dev/cu.usbmodem14121\", \"comment\":\"enter your notes here\", \"icon\":\"\", \"liveviewspan\":600, \"liveviewperiod\":1, \"liveviewlogscale\":false, \"metadata\":{}, \"_id\":\"6C8BCEB8-77C7-DF73-930A-3DEA48992119\", \"_rev\":\"3-643fc192e8094b885f0b29c4f944e8f3\" }, { \"name\":\"FCOLED\", \"type\":\"fcoledv1\", \"tag\":\"\", \"uuid\":\"00000000 (n.a.)\", \"port\":\"/dev/cu.usbmodem1451\", \"comment\":\"enter your notes here\", \"icon\":\"\", \"liveviewspan\":600, \"liveviewperiod\":1, \"liveviewlogscale\":false, \"metadata\":{}, \"_id\":\"8E7A801E-8AD1-FB5C-B772-CABA61B8FCC6\", \"_rev\":\"7-13d2c6309ffeab1bcf87833fae563764\" }, ] Instruments details Returns one instrument's details (http GET): http://localhost:8090/instruments/6C8BCEB8-77C7-DF73-930A-3DEA48992119 Listing logs for an instrument You can get all the logs for a given instrument by doing a GET on /logs : http://localhost:8090/instruments/E1B65550-BEA8-63BB-9AFA-58F94E0D881D/logs [ { \"instrumentid\":\"E1B65550-BEA8-63BB-9AFA-58F94E0D881D\", \"name\":\"Autorecord\", \"description\":\"Autorecord\", \"logtype\":\"live\", \"startstamp\":1437430818782.795, \"isrecording\":false, \"datapoints\":11, \"swversion\":0, \"endstamp\":1437431082121.264, \"_id\":\"4E148536-1F12-8F85-AF9B-6E48401F030C\", \"_rev\":\"5-ef4df5e4f9a9e85e26252cbfc175706f\" } ] Log download The contents of a log are returned with (http GET): http://localhost:8090/logs/4E148536-1F12-8F85-AF9B-6E48401F030C/entries Each log record contains two keys: timestamp: javascript timestamp (milliseconds since January 1 1970). Time when the entry was added to the log. Sometimes (esp for on-intrument log download), the timestamp in the 'data' key will be more important. data : structure depends on the instrument. [ { \"timestamp\":1437430818782.795, \"data\":{\"uniqueID\":\"00000000 (n.a.)\"}, \"_id\":\"1437430818782.795\" }, { \"timestamp\":1437430878351.307, \"data\":{ \"probeid\":3001739, \"timestamp\":25544, \"devicestamp\":1437426924000, \"cpm\":{ \"value\":0, \"valid\":true }, \"cpm2\":{ \"value\":0, \"valid\":true } }, \"_id\":\"1437430878351.307\" }, { \"timestamp\":1437430878351.7, \"data\":{ ... }, \"_id\":\"1437430878351.7\" } .... ]","title":"API Access"},{"location":"dev/api/#wizkers-api-access-in-server-mode","text":"When running on a server, you can also interact with it using a REST API, so that all the data from the server can be queried/streamed to external systems.","title":"Wizkers API access in server mode"},{"location":"dev/api/#live-recording","text":"Wizkers exposes a public \"live recording\" API, which lets you query data that is currently being recorded. The syntax is as follows /live/:id/:period with id being the instrument ID, and period being in minutes - get the live recording for the last period minutes.","title":"Live recording"},{"location":"dev/api/#low-level-api-access","text":"You can access the low level RESTFUL API of Wizkers using the standard authentication mechanism that is used by the Wizkers front-end web app. The simple Shell script below demonstrates how to get a list of instruments in JSON format. #!/bin/sh ## Example of Wizkers authentication then API request ## Save cookies to the \"cookies.txt\" file curl --cookie-jar cookies.txt -H \"Content-Type: application/json\" -X POST http://localhost:8090/login -d \"{\\\"email\\\": \\\"admin\\\", \\\"password\\\": \\\"abc123\\\"}\" ## Now you can do queries: curl --cookie cookies.txt -X GET http://localhost:8090/instruments","title":"Low level API access"},{"location":"dev/api/#listing-instruments","text":"You can get a list of all instruments registered in a Wizkers instance by doing an HTTP GET to /instruments/ . Note that this returns all instruments contents, not only a list of references. Example below: [ { \"name\":\"Piglet\", \"type\":\"simple_serial\", \"tag\":\"\", \"uuid\":\"00000000 (n.a.)\", \"port\":\"/dev/cu.usbserial-FTGDPEGI\", \"comment\":\"enter your notes here\", \"icon\":\"\", \"liveviewspan\":600, \"liveviewperiod\":1, \"liveviewlogscale\":false, \"metadata\":{\"baudrate\":\"9600\",\"lines\":\"40\"}, \"_id\":\"5AD6B170-A8AC-820E-9070-6DB9619661C4\", \"_rev\":\"19-5199b8924f8388771d32d13f0b26c508\" }, { \"name\":\"OLED\", \"type\":\"fcoledv1\", \"tag\":\"\", \"uuid\":\"00000000 (n.a.)\", \"port\":\"/dev/cu.usbmodem14121\", \"comment\":\"enter your notes here\", \"icon\":\"\", \"liveviewspan\":600, \"liveviewperiod\":1, \"liveviewlogscale\":false, \"metadata\":{}, \"_id\":\"6C8BCEB8-77C7-DF73-930A-3DEA48992119\", \"_rev\":\"3-643fc192e8094b885f0b29c4f944e8f3\" }, { \"name\":\"FCOLED\", \"type\":\"fcoledv1\", \"tag\":\"\", \"uuid\":\"00000000 (n.a.)\", \"port\":\"/dev/cu.usbmodem1451\", \"comment\":\"enter your notes here\", \"icon\":\"\", \"liveviewspan\":600, \"liveviewperiod\":1, \"liveviewlogscale\":false, \"metadata\":{}, \"_id\":\"8E7A801E-8AD1-FB5C-B772-CABA61B8FCC6\", \"_rev\":\"7-13d2c6309ffeab1bcf87833fae563764\" }, ]","title":"Listing instruments"},{"location":"dev/api/#instruments-details","text":"Returns one instrument's details (http GET): http://localhost:8090/instruments/6C8BCEB8-77C7-DF73-930A-3DEA48992119","title":"Instruments details"},{"location":"dev/api/#listing-logs-for-an-instrument","text":"You can get all the logs for a given instrument by doing a GET on /logs : http://localhost:8090/instruments/E1B65550-BEA8-63BB-9AFA-58F94E0D881D/logs [ { \"instrumentid\":\"E1B65550-BEA8-63BB-9AFA-58F94E0D881D\", \"name\":\"Autorecord\", \"description\":\"Autorecord\", \"logtype\":\"live\", \"startstamp\":1437430818782.795, \"isrecording\":false, \"datapoints\":11, \"swversion\":0, \"endstamp\":1437431082121.264, \"_id\":\"4E148536-1F12-8F85-AF9B-6E48401F030C\", \"_rev\":\"5-ef4df5e4f9a9e85e26252cbfc175706f\" } ]","title":"Listing logs for an instrument"},{"location":"dev/api/#log-download","text":"The contents of a log are returned with (http GET): http://localhost:8090/logs/4E148536-1F12-8F85-AF9B-6E48401F030C/entries Each log record contains two keys: timestamp: javascript timestamp (milliseconds since January 1 1970). Time when the entry was added to the log. Sometimes (esp for on-intrument log download), the timestamp in the 'data' key will be more important. data : structure depends on the instrument. [ { \"timestamp\":1437430818782.795, \"data\":{\"uniqueID\":\"00000000 (n.a.)\"}, \"_id\":\"1437430818782.795\" }, { \"timestamp\":1437430878351.307, \"data\":{ \"probeid\":3001739, \"timestamp\":25544, \"devicestamp\":1437426924000, \"cpm\":{ \"value\":0, \"valid\":true }, \"cpm2\":{ \"value\":0, \"valid\":true } }, \"_id\":\"1437430878351.307\" }, { \"timestamp\":1437430878351.7, \"data\":{ ... }, \"_id\":\"1437430878351.7\" } .... ]","title":"Log download"},{"location":"dev/connections/","text":"Connections Connections are the low-level hardware drivers which connect instrument drivers to the actual instruments. They can be serial ports, Bluetooth, network sockets, etc. depending on the instrument type. From an architecture standpoint, connections are created and managed by instrument backend drivers ( wizkers/server/www/js/app/instruments/XXX/backend_driver.js in Chrome/Cordova mode and wizkers/server/server/parsers in server mode). The backend driver listens to the various events coming from the low level drivers. All modes All connections implement the following API: open close write (optional) read (optional) flush And connections emit the data event whenever there is data ready to be sent to the upper level driver. Connection configuration Each connection type should also provide a configuration view, located in wizkers/server/www/js/app/views/instruments/ , along with a template in wizkers/server/www/js/tpl/connections . You can refer to the structure of existing connections to get a clearer understanding of how they work. Making a new connection available to instruments In Chrome/Cordova mode, a new connection is connected to the rest of the Wizkers codebase by refering to it in wizkers/server/www/js/app/instruments/connectionmanager.js as part of the instrument plugin setup. In server mode, new connections are used directly by instrument backend-drivers (in wizkers/server/server/parsers ). Connection support by mode Connection type Chrome Cordova Server Comment Serial Yes Yes Yes Standard serial ports (incl. serial over USB) TCP/IP Sockets Yes No No Serial over TCP sockets USB HID Yes No No USB HID communications. Helium No No Yes Network connection to the helium.com IoT network. Pinocc.io No No Yes Network connection to the Pinocc.io IoT network Bluetooth LE Yes Yes Yes Chrome support on Chromebooks only WebRTC Yes Not tested No Connection over a WebRTC data channel (using the peerjs.com library) Serial Connection The serial connection is the first that was supported in Wizkers. It works in every mode (Server, Android/Cordova, Chrome) and provides access to any serial device that is connected to the computer. Serial over TCP/IP Sockets This is accessible in Chrome mode only for now. TCP/IP sockets are an extension to the serial connection, and are managed along with the serial connection (this adds an extra entry in the serial port dropdown). You will have to explicitely add support for this on your instrument's backend driver, like you can see here: www/js/app/instruments/elecraft/backend_driver.js . USB HID Connection This connection type is only supported in Chrome packaged app mode at the moment (0.9.3). It provides read/write access to generic USB HID devices through the usual connection API. Due to the nature of USB HID, which is a polling system, you will need to call the \u201cread\u201d method on the driver to get data from the device. You can look at the Sark110 backend driver in www/js/app/instruments/sark110/backend_driver.js for an example of how this can be implemented. Helium connection This connection is only supported in server mode. It establishes a 'subscription' to a device on the Helium.com netword, and supports the usual write/open/close methods. Data is automatically sent through the 'data' event. Pinocc.io connection Likewise, the Pinocc.io plugin lets you talk and receive data from devices connected to the Pinocc.io IoT network. Note: the Pinocc.io network is now obsolete, and a standalone pinoccio-server.js alternative makes it possible to use Pinocc.io devices without the Pinocc.io IoT backend. Bluetooth LE connection This connection is supported on Chromebooks only because of a Chrome runtime limitation (August 2015). Bluetooth LE also works on Android as well as Server modes. WebRTC This connection should work on both Chrome and Cordova, but is only tested on Chrome. This is very experimental.","title":"Connections"},{"location":"dev/connections/#connections","text":"Connections are the low-level hardware drivers which connect instrument drivers to the actual instruments. They can be serial ports, Bluetooth, network sockets, etc. depending on the instrument type. From an architecture standpoint, connections are created and managed by instrument backend drivers ( wizkers/server/www/js/app/instruments/XXX/backend_driver.js in Chrome/Cordova mode and wizkers/server/server/parsers in server mode). The backend driver listens to the various events coming from the low level drivers.","title":"Connections"},{"location":"dev/connections/#all-modes","text":"All connections implement the following API: open close write (optional) read (optional) flush And connections emit the data event whenever there is data ready to be sent to the upper level driver.","title":"All modes"},{"location":"dev/connections/#connection-configuration","text":"Each connection type should also provide a configuration view, located in wizkers/server/www/js/app/views/instruments/ , along with a template in wizkers/server/www/js/tpl/connections . You can refer to the structure of existing connections to get a clearer understanding of how they work.","title":"Connection configuration"},{"location":"dev/connections/#making-a-new-connection-available-to-instruments","text":"In Chrome/Cordova mode, a new connection is connected to the rest of the Wizkers codebase by refering to it in wizkers/server/www/js/app/instruments/connectionmanager.js as part of the instrument plugin setup. In server mode, new connections are used directly by instrument backend-drivers (in wizkers/server/server/parsers ).","title":"Making a new connection available to instruments"},{"location":"dev/connections/#connection-support-by-mode","text":"Connection type Chrome Cordova Server Comment Serial Yes Yes Yes Standard serial ports (incl. serial over USB) TCP/IP Sockets Yes No No Serial over TCP sockets USB HID Yes No No USB HID communications. Helium No No Yes Network connection to the helium.com IoT network. Pinocc.io No No Yes Network connection to the Pinocc.io IoT network Bluetooth LE Yes Yes Yes Chrome support on Chromebooks only WebRTC Yes Not tested No Connection over a WebRTC data channel (using the peerjs.com library)","title":"Connection support by mode"},{"location":"dev/connections/#serial-connection","text":"The serial connection is the first that was supported in Wizkers. It works in every mode (Server, Android/Cordova, Chrome) and provides access to any serial device that is connected to the computer.","title":"Serial Connection"},{"location":"dev/connections/#serial-over-tcpip-sockets","text":"This is accessible in Chrome mode only for now. TCP/IP sockets are an extension to the serial connection, and are managed along with the serial connection (this adds an extra entry in the serial port dropdown). You will have to explicitely add support for this on your instrument's backend driver, like you can see here: www/js/app/instruments/elecraft/backend_driver.js .","title":"Serial over TCP/IP Sockets"},{"location":"dev/connections/#usb-hid-connection","text":"This connection type is only supported in Chrome packaged app mode at the moment (0.9.3). It provides read/write access to generic USB HID devices through the usual connection API. Due to the nature of USB HID, which is a polling system, you will need to call the \u201cread\u201d method on the driver to get data from the device. You can look at the Sark110 backend driver in www/js/app/instruments/sark110/backend_driver.js for an example of how this can be implemented.","title":"USB HID Connection"},{"location":"dev/connections/#helium-connection","text":"This connection is only supported in server mode. It establishes a 'subscription' to a device on the Helium.com netword, and supports the usual write/open/close methods. Data is automatically sent through the 'data' event.","title":"Helium connection"},{"location":"dev/connections/#pinoccio-connection","text":"Likewise, the Pinocc.io plugin lets you talk and receive data from devices connected to the Pinocc.io IoT network. Note: the Pinocc.io network is now obsolete, and a standalone pinoccio-server.js alternative makes it possible to use Pinocc.io devices without the Pinocc.io IoT backend.","title":"Pinocc.io connection"},{"location":"dev/connections/#bluetooth-le-connection","text":"This connection is supported on Chromebooks only because of a Chrome runtime limitation (August 2015). Bluetooth LE also works on Android as well as Server modes.","title":"Bluetooth LE connection"},{"location":"dev/connections/#webrtc","text":"This connection should work on both Chrome and Cordova, but is only tested on Chrome. This is very experimental.","title":"WebRTC"},{"location":"dev/debugging/","text":"Debugging Wizkers Depending on the run mode of Wizkers, several options are available to you: Chrome app The best way to debug Mouse Wizkers is to use the Developer tools in Chrome. You can simply load the Wizkers chrome app manually by going to the \u201cExtensions\u201d menu in Chrome, and use \u201cLoad Unpacked Extension\u2026\u201d and make it point to the the \u201cserver\u201d directory. This will start Mouse Wizkers with all developer tools enabled (which is not the case in the Chrome Store version where those are disabled). You can then fire up the Chrome developer tools and do complete debugging of Wizkers by clicking on the \"Inspect views:\" links as shown below: Server mode In server mode, Wizkers uses the Node.js \u201cdebug\u201d facility: simply define a \u201cDEBUG\u201d variable to enable debug output. All modules in Wizkers already define a unique debug name, so you get fairly fine grained output. You can try a \u201cDEBUG=* node server.js\u201d to get an idea of the maximum level of debug output you can get. Using node-inspector You can also debug the server side using the Chrome debugger, thanks to node-inspector . This gives your nearly the same ease of debugging as doing everything browser-side. You can install node-inspector by visiting github and following the instructions. Android application You can also use Chrome to debug Wizkers running as an Android application: you need to have the Android SDK installed on your computer, and your test device connected through USB using adb . Network debugging of Android Since Wizkers lets you use the USB port of your Android device to connect to various kinds of instruments, you will often end up in situatino where you cannot do USB debugging. This is not a problem, since adb can also work on the network. You still need to link your Android device to the adb server on your computer through USB once: $ adb tcpip 5555 Then you can disconnect the Android device from USB, and connect through the Wifi network: $ adb connect <device-ip-address> The Chrome Webview contained in Wizkers will then start showing up on Chrome's chrome://inspect screen.","title":"Debugging"},{"location":"dev/debugging/#debugging-wizkers","text":"Depending on the run mode of Wizkers, several options are available to you:","title":"Debugging Wizkers"},{"location":"dev/debugging/#chrome-app","text":"The best way to debug Mouse Wizkers is to use the Developer tools in Chrome. You can simply load the Wizkers chrome app manually by going to the \u201cExtensions\u201d menu in Chrome, and use \u201cLoad Unpacked Extension\u2026\u201d and make it point to the the \u201cserver\u201d directory. This will start Mouse Wizkers with all developer tools enabled (which is not the case in the Chrome Store version where those are disabled). You can then fire up the Chrome developer tools and do complete debugging of Wizkers by clicking on the \"Inspect views:\" links as shown below:","title":"Chrome app"},{"location":"dev/debugging/#server-mode","text":"In server mode, Wizkers uses the Node.js \u201cdebug\u201d facility: simply define a \u201cDEBUG\u201d variable to enable debug output. All modules in Wizkers already define a unique debug name, so you get fairly fine grained output. You can try a \u201cDEBUG=* node server.js\u201d to get an idea of the maximum level of debug output you can get.","title":"Server mode"},{"location":"dev/debugging/#using-node-inspector","text":"You can also debug the server side using the Chrome debugger, thanks to node-inspector . This gives your nearly the same ease of debugging as doing everything browser-side. You can install node-inspector by visiting github and following the instructions.","title":"Using node-inspector"},{"location":"dev/debugging/#android-application","text":"You can also use Chrome to debug Wizkers running as an Android application: you need to have the Android SDK installed on your computer, and your test device connected through USB using adb .","title":"Android application"},{"location":"dev/debugging/#network-debugging-of-android","text":"Since Wizkers lets you use the USB port of your Android device to connect to various kinds of instruments, you will often end up in situatino where you cannot do USB debugging. This is not a problem, since adb can also work on the network. You still need to link your Android device to the adb server on your computer through USB once: $ adb tcpip 5555 Then you can disconnect the Android device from USB, and connect through the Wifi network: $ adb connect <device-ip-address> The Chrome Webview contained in Wizkers will then start showing up on Chrome's chrome://inspect screen.","title":"Network debugging of Android"},{"location":"dev/instruments/","text":"Adding a new instrument The basic structure Instrument plugins are stored in wizkers/server/www/js/app/instruments . Each instrument plugin is made of the following: In every run mode: icon.png should be a 350x350px icon representing the instrument instrument.js . The main plugin entry point: defines what capabilities the instrument has, and the path to the other plugin files. driver_frontend.js The front-end driver, which runs in the browser settings.js Instruments specific settings screen (displayed in the \"instrument details\" view) display_live.js The main \"live\" visualization. Can be as simple as a graph, or as sophisticated as the Elecraft KX3 controller display_numeric.js The right side visualization display_diag.js The interface for instrument configuration display_.log.js Log visualization interface, usually similar to \u2018display_live\u2019 display_logmanager.js Interface to manage and download on-device logs, if supported display_logedit.js Interface to manage editing log contents directly on Wizkers (optional) All these files can be optional, depending on the capabilities you want to implement in your instrument. In Chrome and Cordova mode, you will also need to add the following: driver_backend.js The back-end driver: the low-level driver for the instrument, which forwards its data to the front-end driver. In server mode, the backend driver lives in wizkers/server/server/parsers/ . Usually, the Chrome/Cordova driver_backend.js and the parsers/instrument_backend.js are similar, though the server-mode low level drivers tend to make use of the NodeJS buffer objects whereas the Chrome version uses pure Javascript ArrayBuffers. This list might seem a bit overwhelming, but there are already many instruments defined in Wizkers, and you should definitely start a new instrument by 'borrowing' from an existing intrument, rather than restart everything from scratch. Wizkers also contains a wizkers/server/www/js/app/instruments/sample_instrument which is a sample instrument scaffolding and can be used to quickly add a new instrument. Connecting your instrument plugin to the rest of Wizkers Once you have implemented those files, you will need to add a reference to the main plugin file (instrument.js) in server/www/js/app/instruments/instrumentmanager.js . In server mode, you will also need to add a reference to the parser in wizkers/server/server/connectionmanager.js to make it available on the server. Instrument view templates All templates are stored in wizkers/server/www/js/tpl . The best practice for new instruments is to add new templates in www/js/tpl/instruments/instrument_name/XXX.html . Wizkers uses the basic BackboneJS \"handlebars\" template style.","title":"Instruments"},{"location":"dev/instruments/#adding-a-new-instrument","text":"","title":"Adding a new instrument"},{"location":"dev/instruments/#the-basic-structure","text":"Instrument plugins are stored in wizkers/server/www/js/app/instruments . Each instrument plugin is made of the following: In every run mode: icon.png should be a 350x350px icon representing the instrument instrument.js . The main plugin entry point: defines what capabilities the instrument has, and the path to the other plugin files. driver_frontend.js The front-end driver, which runs in the browser settings.js Instruments specific settings screen (displayed in the \"instrument details\" view) display_live.js The main \"live\" visualization. Can be as simple as a graph, or as sophisticated as the Elecraft KX3 controller display_numeric.js The right side visualization display_diag.js The interface for instrument configuration display_.log.js Log visualization interface, usually similar to \u2018display_live\u2019 display_logmanager.js Interface to manage and download on-device logs, if supported display_logedit.js Interface to manage editing log contents directly on Wizkers (optional) All these files can be optional, depending on the capabilities you want to implement in your instrument. In Chrome and Cordova mode, you will also need to add the following: driver_backend.js The back-end driver: the low-level driver for the instrument, which forwards its data to the front-end driver. In server mode, the backend driver lives in wizkers/server/server/parsers/ . Usually, the Chrome/Cordova driver_backend.js and the parsers/instrument_backend.js are similar, though the server-mode low level drivers tend to make use of the NodeJS buffer objects whereas the Chrome version uses pure Javascript ArrayBuffers. This list might seem a bit overwhelming, but there are already many instruments defined in Wizkers, and you should definitely start a new instrument by 'borrowing' from an existing intrument, rather than restart everything from scratch. Wizkers also contains a wizkers/server/www/js/app/instruments/sample_instrument which is a sample instrument scaffolding and can be used to quickly add a new instrument.","title":"The basic structure"},{"location":"dev/instruments/#connecting-your-instrument-plugin-to-the-rest-of-wizkers","text":"Once you have implemented those files, you will need to add a reference to the main plugin file (instrument.js) in server/www/js/app/instruments/instrumentmanager.js . In server mode, you will also need to add a reference to the parser in wizkers/server/server/connectionmanager.js to make it available on the server.","title":"Connecting your instrument plugin to the rest of Wizkers"},{"location":"dev/instruments/#instrument-view-templates","text":"All templates are stored in wizkers/server/www/js/tpl . The best practice for new instruments is to add new templates in www/js/tpl/instruments/instrument_name/XXX.html . Wizkers uses the basic BackboneJS \"handlebars\" template style.","title":"Instrument view templates"},{"location":"dev/outputs/","text":"Outputs Outputs are plugins which subscribe to 'data' events coming from connected instruments, and are able to forward those events to other services. They extend the capabilities of Wizkers a great deal by turning it into a middleware between your sensors and any number of backend services. A typical use case for outputs, is using the safecast output to connect a Geiger counter to the Safecast.org service to send regular radiation readings to the Safecast API. General architecture. Due to the fact Wizkers in server mode supports multiple open devices at once and standalone operation, there are slight differences in the way outputs work in server vs Chrome mode, but a lot of similarities too. wizkers/server/www/js/app/outputs/<output_name>/logo.png is the output logo. Output definition Outputs are defined in wizkers/server/www/js/app/outputs/<output_name>/<output_name>.js . This file defines a couple of high level output characteristics which are used by Wizkers to understand how and when it can be used. this.wantOnly returns an array of strings that describe the type of data the output will accept. For instance, the safecast.js output will return ['radioactivity'] so that it does not show up as an available output to devices which don't sent that sort of reading. this.requestAllData is true if the output want Wizkers to send it everything in \"pass through\" mode rather than use the regular/alarm mechanism this.outputFields is the list of fields required by the output to work. The result can be \"variable\" in case the output does not have a fixed number of fields or \"none\" if the output does not support the concept of fields. Front-end output config Outputs always provide a configuration view, which is located in wizkers/server/www/js/app/outputs/<output_name>/settings.js . The corresponding template, by convention, lives in wizkers/server/www/js/tpl/outputs/ . The front-end view is a Backbone view: refer to the existing outputs to get an idea of how to manage output-specific settings, which are merged with general output settings automatically. Output backend drivers Chrome/Cordova mode In this mode, you want to implement wizkers/server/www/js/app/outputs/<output_name>/backend_driver.js . The backend driver needs to implement a couple of public methods which are expected by the output manager: setup onClose resolveMapping sendData Server mode In server mode, output backends live in wizkers/server/server/outputs/ and implement the same API as in Chrome/Cordova mode. Since the outputs are executed in a NodeJS environment, they often use different low-level APIs which is the reason why they are separate from the 'app mode' output code.","title":"Outputs"},{"location":"dev/outputs/#outputs","text":"Outputs are plugins which subscribe to 'data' events coming from connected instruments, and are able to forward those events to other services. They extend the capabilities of Wizkers a great deal by turning it into a middleware between your sensors and any number of backend services. A typical use case for outputs, is using the safecast output to connect a Geiger counter to the Safecast.org service to send regular radiation readings to the Safecast API.","title":"Outputs"},{"location":"dev/outputs/#general-architecture","text":"Due to the fact Wizkers in server mode supports multiple open devices at once and standalone operation, there are slight differences in the way outputs work in server vs Chrome mode, but a lot of similarities too. wizkers/server/www/js/app/outputs/<output_name>/logo.png is the output logo.","title":"General architecture."},{"location":"dev/outputs/#output-definition","text":"Outputs are defined in wizkers/server/www/js/app/outputs/<output_name>/<output_name>.js . This file defines a couple of high level output characteristics which are used by Wizkers to understand how and when it can be used. this.wantOnly returns an array of strings that describe the type of data the output will accept. For instance, the safecast.js output will return ['radioactivity'] so that it does not show up as an available output to devices which don't sent that sort of reading. this.requestAllData is true if the output want Wizkers to send it everything in \"pass through\" mode rather than use the regular/alarm mechanism this.outputFields is the list of fields required by the output to work. The result can be \"variable\" in case the output does not have a fixed number of fields or \"none\" if the output does not support the concept of fields.","title":"Output definition"},{"location":"dev/outputs/#front-end-output-config","text":"Outputs always provide a configuration view, which is located in wizkers/server/www/js/app/outputs/<output_name>/settings.js . The corresponding template, by convention, lives in wizkers/server/www/js/tpl/outputs/ . The front-end view is a Backbone view: refer to the existing outputs to get an idea of how to manage output-specific settings, which are merged with general output settings automatically.","title":"Front-end output config"},{"location":"dev/outputs/#output-backend-drivers","text":"","title":"Output backend drivers"},{"location":"dev/outputs/#chromecordova-mode","text":"In this mode, you want to implement wizkers/server/www/js/app/outputs/<output_name>/backend_driver.js . The backend driver needs to implement a couple of public methods which are expected by the output manager: setup onClose resolveMapping sendData","title":"Chrome/Cordova mode"},{"location":"dev/outputs/#server-mode","text":"In server mode, output backends live in wizkers/server/server/outputs/ and implement the same API as in Chrome/Cordova mode. Since the outputs are executed in a NodeJS environment, they often use different low-level APIs which is the reason why they are separate from the 'app mode' output code.","title":"Server mode"},{"location":"ins/bgeigie/","text":"Safecast bGeigie Nano The bGeigie Nano is a portable Geiger counter / logger designed by Safecast . The full story behind the bGeigie is fascinating, as it was created as a rapid response instrument after the Fukushima Daiichi nuclear accident, and is really a brilliant 'no nonsense' design. Hundreds of bGeigie units have been built so far, and they can all be equipped with Bluetooth Low Energy modules for serial communications. Wizkers supports the bGeigie when running on a Chromebook, or as an Android app, as long as the Android device supports Bluetooth Low Energy. Device setup When creating a bGeigie device, you will need to select the Bluetooth device name that corresponds to your bGeigie. This is also where you can enter your Safecast API key (you can get an API key at http://api.safecast.org/). Without the API key, you will not be able to upload your drives to Safecast. You can add the key at any point, even after creating a drive. The main screen (Chrome) On Chromebooks, the bGeigie Nano instrument displays pretty much the same data as the Onyx, except that the GPS coordinates come from the bGeigie and not the localization API of Chrome. Due to content policy restrictions on Chrome, there is no mapping support for the bGeigie yet, though a future revision of Wizkers will probably add this. The main screen (Cordova app / Android) Mapping is enabled by default in Android mode. Wizkers displays the trace on the map using color dots that go from white to red depending on the CPM value.","title":"Safecast bGeigie Nano"},{"location":"ins/bgeigie/#safecast-bgeigie-nano","text":"The bGeigie Nano is a portable Geiger counter / logger designed by Safecast . The full story behind the bGeigie is fascinating, as it was created as a rapid response instrument after the Fukushima Daiichi nuclear accident, and is really a brilliant 'no nonsense' design. Hundreds of bGeigie units have been built so far, and they can all be equipped with Bluetooth Low Energy modules for serial communications. Wizkers supports the bGeigie when running on a Chromebook, or as an Android app, as long as the Android device supports Bluetooth Low Energy.","title":"Safecast bGeigie Nano"},{"location":"ins/bgeigie/#device-setup","text":"When creating a bGeigie device, you will need to select the Bluetooth device name that corresponds to your bGeigie. This is also where you can enter your Safecast API key (you can get an API key at http://api.safecast.org/). Without the API key, you will not be able to upload your drives to Safecast. You can add the key at any point, even after creating a drive.","title":"Device setup"},{"location":"ins/bgeigie/#the-main-screen-chrome","text":"On Chromebooks, the bGeigie Nano instrument displays pretty much the same data as the Onyx, except that the GPS coordinates come from the bGeigie and not the localization API of Chrome. Due to content policy restrictions on Chrome, there is no mapping support for the bGeigie yet, though a future revision of Wizkers will probably add this.","title":"The main screen (Chrome)"},{"location":"ins/bgeigie/#the-main-screen-cordova-app-android","text":"Mapping is enabled by default in Android mode. Wizkers displays the trace on the map using color dots that go from white to red depending on the CPM value.","title":"The main screen (Cordova app / Android)"},{"location":"ins/elecraft-kx3/","text":"Elecraft KX3 The KX3 instrument plugin gives you pretty extensive rig controller capabilities from your computer. The first and foremost feature of this plugin is the reproduction of the KX3 faceplace \u2013 you can click on the buttons, nearly everything works. But this instrument also support advanced capabilities including complete KXPA100 monitoring and configuration, as well as PX3 support with Screenshots. You will also get access to features that are either not directly supported or a bit involved to work with on the KX3 such as: Memory Management Monitoring of KXPA100 health Direct frequency access TX and RX equalizer setup And when used with the \"rigctld\" output plugin, you can use Wizkers as the rig controller for third party software such as fldigi. The main screen The KX3 Faceplace Not much to say there: most buttons work as they should \u2013 click on the text below the buttons for accessing those functions which are usually accessed by \u201cholding\u201d the buttons. The display mostly works, a few elements are not kept in sync, most notably the SWR. This will be implemented in a future revision. Direct input area In this area, you can enter VFO A and VFO B frequencies, select input power, and adjust AF gain, RF attenuation, Mic gain, filter bandwidth and center frequency. Press the * button to recenter the filter. Waterfall display The waterfall display is the most recent feature of this plugin. It is an Audio (not IQ) display, and uses the computer\u2019s default sound input. Press the small \"power\" icon on the upper left to start the waterfall. The Headphones icon sends the audio to the computer\u2019s speakers, which is good for monitoring in digital modes, for instance. The \"Scale\" and \"Ref\" controls let you change the rendering of the waterfall. Smoothing and FFT window are further controls to fine-tune how the waterfall looks. Graph displays The right side of the page shows you three graphs: Amplifier temperature Transmit power Power supply voltage/current Those graphs really make most sense when a KXPA100 unit is connected to the setup. But even witout a KXPA100, you can graph the KX3 amp temperature (PA.I) or the internal oscillator temp (OSC) by enabling the display of that value on VFOB. Only one value at a time can be monitored, due to the way the KX3 is designed. Data mode You can access a simple data mode terminal by clicking on the \"Data\" tab next to the \"Memories\" tab: The layout should be pretty much self-explanatory. Note that Wizkers will continuously scan for call signs in the terminal window and populate the \"you\" dropdown menu for you. The buttons called CQ, ANS, KN, etc. are macros, which can be configured in the \"Settings\" screen of Wizkers, on the top black menu on the right: KX3 Setup The \"Device Setup\" screen cover the following capabilities: Quick diagnostics: KX3, KXPA100, PX3 versions, options installed, etc Configuration of the KX3 receive and transmit equalizers Full KXPA100 configuration and monitoring PX3 screenshots KX3 diagnostics This screen is a quick summary of the current state of the KX-line setup: KX3, KXPA100 and PX3 configurations, options etc. Audio settings You can adjust the TX and RX equalizers there. This is a feature of the KX3 that is often underused because changing those settings on the radio is fairly cumbersome: the Wizkers UI makes it super easy. Note: the KX3 seems to keep separate TX/RX EQ settings depending on the band. Moreover, if your KX3 is in \"DATA\" mode when trying to modify the settings, the UI will freeze. Put the Radio in USB mode to resume operations. KXPA100 configuration and monitoring This tab reproduces nearly all the capabilities of the official Elecraft KXPA100 utility, and is also able to graph most amplifier values in real time. You can adjust your KXPA100 settings from there and check all operating parameters. The values are refreshed twice per second. PX3 Utility The PX3 utility lets you take screenshots of the PX3 screen, not much to say there. Click on the image to save it: Configuring KX3 instruments on Wizkers On the \"Instruments\" screen, create a new \"Elecraft Radio\" instrument, as shown below. Most of the fields are self-explanatory: Pick the correct serial port If you are planning to connect your radio audio to the KX3, you can also setup your sound cards here Important note: you will need to set your KX3 baud rate to 38400 for Wizkers to talk to your KX3. If you want to use the Pignology Piglet with this instrument, select \"TCP/IP\" in the serial port dropdown. You will then need to enter the Piglet's IP address and port (7373 by default). You also need to make sure the Piglet is configured for 38'400 baud. Sound card setup The KX3 instrument gives you the ability to visualize the audio from the KX3 on a \"waterfall\" display, as well as monitor the audio on the computer. It can also send audio coming from your computer (a microphone for instance) to the radio. This is convenient since the radio's audio input and output are connected to your computer, to it is not possible to connect your microphone to the radio anymore. For doing this, you will need to setup the \"audio from radio\" and \"audio to radio\" drop-downs to indicate which sound card the radio is connected to. And you can use the \"audio from/to operator\" dropdowns to indicate the sound card used by the operator. Note that making full use of this setup requires two sound cards, but you can choose to simply setup the \"audio from radio\" and \"audio to operator\" dropdowns to do a simple monitoring when working on digital modes. Why are the \"Audio to...\" dropdowns empty ? : You need to enable experimental support in Chrome 45.0.2441.x or later by selecting Enable experimental Web Platform features in chrome://flags or by using command line flag \"--enable-blink-features=EnumerateDevices,AudioOutputDevices\"","title":"Elecraft KX3"},{"location":"ins/elecraft-kx3/#elecraft-kx3","text":"The KX3 instrument plugin gives you pretty extensive rig controller capabilities from your computer. The first and foremost feature of this plugin is the reproduction of the KX3 faceplace \u2013 you can click on the buttons, nearly everything works. But this instrument also support advanced capabilities including complete KXPA100 monitoring and configuration, as well as PX3 support with Screenshots. You will also get access to features that are either not directly supported or a bit involved to work with on the KX3 such as: Memory Management Monitoring of KXPA100 health Direct frequency access TX and RX equalizer setup And when used with the \"rigctld\" output plugin, you can use Wizkers as the rig controller for third party software such as fldigi.","title":"Elecraft KX3"},{"location":"ins/elecraft-kx3/#the-main-screen","text":"","title":"The main screen"},{"location":"ins/elecraft-kx3/#the-kx3-faceplace","text":"Not much to say there: most buttons work as they should \u2013 click on the text below the buttons for accessing those functions which are usually accessed by \u201cholding\u201d the buttons. The display mostly works, a few elements are not kept in sync, most notably the SWR. This will be implemented in a future revision.","title":"The KX3 Faceplace"},{"location":"ins/elecraft-kx3/#direct-input-area","text":"In this area, you can enter VFO A and VFO B frequencies, select input power, and adjust AF gain, RF attenuation, Mic gain, filter bandwidth and center frequency. Press the * button to recenter the filter.","title":"Direct input area"},{"location":"ins/elecraft-kx3/#waterfall-display","text":"The waterfall display is the most recent feature of this plugin. It is an Audio (not IQ) display, and uses the computer\u2019s default sound input. Press the small \"power\" icon on the upper left to start the waterfall. The Headphones icon sends the audio to the computer\u2019s speakers, which is good for monitoring in digital modes, for instance. The \"Scale\" and \"Ref\" controls let you change the rendering of the waterfall. Smoothing and FFT window are further controls to fine-tune how the waterfall looks.","title":"Waterfall display"},{"location":"ins/elecraft-kx3/#graph-displays","text":"The right side of the page shows you three graphs: Amplifier temperature Transmit power Power supply voltage/current Those graphs really make most sense when a KXPA100 unit is connected to the setup. But even witout a KXPA100, you can graph the KX3 amp temperature (PA.I) or the internal oscillator temp (OSC) by enabling the display of that value on VFOB. Only one value at a time can be monitored, due to the way the KX3 is designed.","title":"Graph displays"},{"location":"ins/elecraft-kx3/#data-mode","text":"You can access a simple data mode terminal by clicking on the \"Data\" tab next to the \"Memories\" tab: The layout should be pretty much self-explanatory. Note that Wizkers will continuously scan for call signs in the terminal window and populate the \"you\" dropdown menu for you. The buttons called CQ, ANS, KN, etc. are macros, which can be configured in the \"Settings\" screen of Wizkers, on the top black menu on the right:","title":"Data mode"},{"location":"ins/elecraft-kx3/#kx3-setup","text":"The \"Device Setup\" screen cover the following capabilities: Quick diagnostics: KX3, KXPA100, PX3 versions, options installed, etc Configuration of the KX3 receive and transmit equalizers Full KXPA100 configuration and monitoring PX3 screenshots","title":"KX3 Setup"},{"location":"ins/elecraft-kx3/#kx3-diagnostics","text":"This screen is a quick summary of the current state of the KX-line setup: KX3, KXPA100 and PX3 configurations, options etc.","title":"KX3 diagnostics"},{"location":"ins/elecraft-kx3/#audio-settings","text":"You can adjust the TX and RX equalizers there. This is a feature of the KX3 that is often underused because changing those settings on the radio is fairly cumbersome: the Wizkers UI makes it super easy. Note: the KX3 seems to keep separate TX/RX EQ settings depending on the band. Moreover, if your KX3 is in \"DATA\" mode when trying to modify the settings, the UI will freeze. Put the Radio in USB mode to resume operations.","title":"Audio settings"},{"location":"ins/elecraft-kx3/#kxpa100-configuration-and-monitoring","text":"This tab reproduces nearly all the capabilities of the official Elecraft KXPA100 utility, and is also able to graph most amplifier values in real time. You can adjust your KXPA100 settings from there and check all operating parameters. The values are refreshed twice per second.","title":"KXPA100 configuration and monitoring"},{"location":"ins/elecraft-kx3/#px3-utility","text":"The PX3 utility lets you take screenshots of the PX3 screen, not much to say there. Click on the image to save it:","title":"PX3 Utility"},{"location":"ins/elecraft-kx3/#configuring-kx3-instruments-on-wizkers","text":"On the \"Instruments\" screen, create a new \"Elecraft Radio\" instrument, as shown below. Most of the fields are self-explanatory: Pick the correct serial port If you are planning to connect your radio audio to the KX3, you can also setup your sound cards here Important note: you will need to set your KX3 baud rate to 38400 for Wizkers to talk to your KX3. If you want to use the Pignology Piglet with this instrument, select \"TCP/IP\" in the serial port dropdown. You will then need to enter the Piglet's IP address and port (7373 by default). You also need to make sure the Piglet is configured for 38'400 baud.","title":"Configuring KX3 instruments on Wizkers"},{"location":"ins/elecraft-kx3/#sound-card-setup","text":"The KX3 instrument gives you the ability to visualize the audio from the KX3 on a \"waterfall\" display, as well as monitor the audio on the computer. It can also send audio coming from your computer (a microphone for instance) to the radio. This is convenient since the radio's audio input and output are connected to your computer, to it is not possible to connect your microphone to the radio anymore. For doing this, you will need to setup the \"audio from radio\" and \"audio to radio\" drop-downs to indicate which sound card the radio is connected to. And you can use the \"audio from/to operator\" dropdowns to indicate the sound card used by the operator. Note that making full use of this setup requires two sound cards, but you can choose to simply setup the \"audio from radio\" and \"audio to operator\" dropdowns to do a simple monitoring when working on digital modes. Why are the \"Audio to...\" dropdowns empty ? : You need to enable experimental support in Chrome 45.0.2441.x or later by selecting Enable experimental Web Platform features in chrome://flags or by using command line flag \"--enable-blink-features=EnumerateDevices,AudioOutputDevices\"","title":"Sound card setup"},{"location":"ins/elecraft-kxpa100/","text":"Elecraft KXPA100 The KXPA100 instrument plugin is a complete interface for monitoring and configuring the Elecraft KXPA100 HF amplifier. Nearly all LEDs on the front panel monitor are functional, so you can get a display of the KXPA100 even when it is located far away. You can either use the KXPA100 monitor along with a KX3, in which case you can access it through the \"Device Setup\" screen, or simply in standalone mode, in case you are using the KXPA100 without a KX3. In that case, just configure it as a standalone instrument through the \"Instruments\" screen. The main screen The KXPA100 faceplate As mentioned above, most LEDs on the faceplate follow the LEDs on the KXPA100 display - the only LED that is not implemented at the moment is the \"TX\" led. Two LED brightness levels are used, in order to avoid polling the KXPA100 too fast but still provide great visual feedback AMP and ATU Configuration As shown on the screenshot above, you can control pretty much every aspect of the configuration of the KXPA100 by directly clicking on the checkboxes and dropdowns. Changes are done instantly. Parameter Monitoring The bottom of the screen displays four graphs: Power: input, forward and reflected power Temperature Voltage and current SWR Evolutions In a future release, the KXPA100 monitor will also display the fault history.","title":"Elecraft KXPA100"},{"location":"ins/elecraft-kxpa100/#elecraft-kxpa100","text":"The KXPA100 instrument plugin is a complete interface for monitoring and configuring the Elecraft KXPA100 HF amplifier. Nearly all LEDs on the front panel monitor are functional, so you can get a display of the KXPA100 even when it is located far away. You can either use the KXPA100 monitor along with a KX3, in which case you can access it through the \"Device Setup\" screen, or simply in standalone mode, in case you are using the KXPA100 without a KX3. In that case, just configure it as a standalone instrument through the \"Instruments\" screen.","title":"Elecraft KXPA100"},{"location":"ins/elecraft-kxpa100/#the-main-screen","text":"","title":"The main screen"},{"location":"ins/elecraft-kxpa100/#the-kxpa100-faceplate","text":"As mentioned above, most LEDs on the faceplate follow the LEDs on the KXPA100 display - the only LED that is not implemented at the moment is the \"TX\" led. Two LED brightness levels are used, in order to avoid polling the KXPA100 too fast but still provide great visual feedback","title":"The KXPA100 faceplate"},{"location":"ins/elecraft-kxpa100/#amp-and-atu-configuration","text":"As shown on the screenshot above, you can control pretty much every aspect of the configuration of the KXPA100 by directly clicking on the checkboxes and dropdowns. Changes are done instantly.","title":"AMP and ATU Configuration"},{"location":"ins/elecraft-kxpa100/#parameter-monitoring","text":"The bottom of the screen displays four graphs: Power: input, forward and reflected power Temperature Voltage and current SWR","title":"Parameter Monitoring"},{"location":"ins/elecraft-kxpa100/#evolutions","text":"In a future release, the KXPA100 monitor will also display the fault history.","title":"Evolutions"},{"location":"ins/elecraft-remote-kx3/","text":"Elecraft remote KX3 The remote KX3 instrument is very similar to the standard KX3 instrument , with one very big difference: instead of connecting to a local KX3, this instrument will connect to a remote Wizkers instance over a WebRTC channel. Full rig control as well as full duplex audio are supported. Note: KX3 remote capabilities are very experimental and require a bit of manual setup in order to work properly. Contact us at info@wizkers.io for help if required. Setting up Wizkers for KX3 remote control Local end The first requirement for using this instrument, is to have another Chrome instance of Wizkers running somewhere, and configured with a standard KX3 instrument . On that first instance, you need to then enable a WebRTC output . Refer to the WebRTC output documentation for details on how to do this. Once the KX3 and the WebRTC output are configured, simply connect the KX3. You are done on this end. Remote end On the remote end, things are a lot simpler: just create a Remote KX3 instrument. Most of the screen is similar to any other instrument, with the following differences: WebRTC Peer needs to point to the call establishment server (see the WebRTC output doc for details on what this is). You should select the correct sound card inputs and outputs for the audio. Audio from the radio comes in from the WebRTC audio channel, what you are setting up here is local audio (your microphone and speaker/headphones, in other words). Establishing a call With the KX3 turned on and connected to the 'local end' Wizkers, you can now start Wizkers on the \"remote end\" device - which can be as simple as a low-end Chromebook, and press \"Connect\". You should see the KX3 display start to update, and you will be able to remotely control the KX3 in the same way you would with the local instance. In order to start audio, press the \"power\" icon next to the waterfall. This will establish audio communications. You can now use the \"XMIT\" button on the KX3 faceplate to start talking. Be very careful about Audio feedback if you are not using headphones!","title":"Elecraft Remote KX3"},{"location":"ins/elecraft-remote-kx3/#elecraft-remote-kx3","text":"The remote KX3 instrument is very similar to the standard KX3 instrument , with one very big difference: instead of connecting to a local KX3, this instrument will connect to a remote Wizkers instance over a WebRTC channel. Full rig control as well as full duplex audio are supported. Note: KX3 remote capabilities are very experimental and require a bit of manual setup in order to work properly. Contact us at info@wizkers.io for help if required.","title":"Elecraft remote KX3"},{"location":"ins/elecraft-remote-kx3/#setting-up-wizkers-for-kx3-remote-control","text":"","title":"Setting up Wizkers for KX3 remote control"},{"location":"ins/elecraft-remote-kx3/#local-end","text":"The first requirement for using this instrument, is to have another Chrome instance of Wizkers running somewhere, and configured with a standard KX3 instrument . On that first instance, you need to then enable a WebRTC output . Refer to the WebRTC output documentation for details on how to do this. Once the KX3 and the WebRTC output are configured, simply connect the KX3. You are done on this end.","title":"Local end"},{"location":"ins/elecraft-remote-kx3/#remote-end","text":"On the remote end, things are a lot simpler: just create a Remote KX3 instrument. Most of the screen is similar to any other instrument, with the following differences: WebRTC Peer needs to point to the call establishment server (see the WebRTC output doc for details on what this is). You should select the correct sound card inputs and outputs for the audio. Audio from the radio comes in from the WebRTC audio channel, what you are setting up here is local audio (your microphone and speaker/headphones, in other words).","title":"Remote end"},{"location":"ins/elecraft-remote-kx3/#establishing-a-call","text":"With the KX3 turned on and connected to the 'local end' Wizkers, you can now start Wizkers on the \"remote end\" device - which can be as simple as a low-end Chromebook, and press \"Connect\". You should see the KX3 display start to update, and you will be able to remotely control the KX3 in the same way you would with the local instance. In order to start audio, press the \"power\" icon next to the waterfall. This will establish audio communications. You can now use the \"XMIT\" button on the KX3 faceplate to start talking. Be very careful about Audio feedback if you are not using headphones!","title":"Establishing a call"},{"location":"ins/elecraft-xg3/","text":"Elecraft XG3 The XG3 instrument plugin lets you configure and operate the Elecraft XG3 RF signal source. One of this really nice features is that it makes it very simple to operate the XG3 in CW or RTTY beacon mode, which is not very easy when just interfacing with the XG3 Elecraft utility or a serial terminal. The main screen The XG3 faceplate The XG3 faceplate is active. In particular, in order to select a band memory, simply click on the LED of the band you want to select. Same thing for the output levels. Note that the red buttons are not active yet. Direct frequency selection and memory edit You can select a frequency directly in the \"Current frequency\" field. The monitor screen displays the frequency of all band memories. You can modify any memory and press \"Save\" to send the changes to the XG3. Note that Wizkers is 'smart' and will only send actual changes to the XG3 and will not overwrite a memory for unchanged memories. CW/RTTY beacon The \"Beacon Mode\" panel lets you define the beacon string. The XG3 supports quite a few special characters as part of the beacon string, and the monitor can display a quick 'cheat sheet' by pressing \"Syntax Help\". Note that when clicking \"Send Beacon\", the XG3 PF1 memory is automatically reprogrammed to activate beacon memory. The XG3 will send the beacon (continuously if the beacon ends with '#') until a command is sent to the XG3, for instance by changing the band. The XG3 can also send an arbitraty string of characters in CW or RTTY mode using the \"send immediately\" field. Sweep mode Sweeps are not implemented on this version yet!","title":"Elecraft XG3"},{"location":"ins/elecraft-xg3/#elecraft-xg3","text":"The XG3 instrument plugin lets you configure and operate the Elecraft XG3 RF signal source. One of this really nice features is that it makes it very simple to operate the XG3 in CW or RTTY beacon mode, which is not very easy when just interfacing with the XG3 Elecraft utility or a serial terminal.","title":"Elecraft XG3"},{"location":"ins/elecraft-xg3/#the-main-screen","text":"","title":"The main screen"},{"location":"ins/elecraft-xg3/#the-xg3-faceplate","text":"The XG3 faceplate is active. In particular, in order to select a band memory, simply click on the LED of the band you want to select. Same thing for the output levels. Note that the red buttons are not active yet.","title":"The XG3 faceplate"},{"location":"ins/elecraft-xg3/#direct-frequency-selection-and-memory-edit","text":"You can select a frequency directly in the \"Current frequency\" field. The monitor screen displays the frequency of all band memories. You can modify any memory and press \"Save\" to send the changes to the XG3. Note that Wizkers is 'smart' and will only send actual changes to the XG3 and will not overwrite a memory for unchanged memories.","title":"Direct frequency selection and memory edit"},{"location":"ins/elecraft-xg3/#cwrtty-beacon","text":"The \"Beacon Mode\" panel lets you define the beacon string. The XG3 supports quite a few special characters as part of the beacon string, and the monitor can display a quick 'cheat sheet' by pressing \"Syntax Help\". Note that when clicking \"Send Beacon\", the XG3 PF1 memory is automatically reprogrammed to activate beacon memory. The XG3 will send the beacon (continuously if the beacon ends with '#') until a command is sent to the XG3, for instance by changing the band. The XG3 can also send an arbitraty string of characters in CW or RTTY mode using the \"send immediately\" field.","title":"CW/RTTY beacon"},{"location":"ins/elecraft-xg3/#sweep-mode","text":"Sweeps are not implemented on this version yet!","title":"Sweep mode"},{"location":"ins/fcoled/","text":"Fried Circuits OLED Backpack This plugin really unlocks the potential of this great instrument: the OLED backpack actually contains pretty sophisticated code that monitors current/voltage fluctuations within each sampling period. The build-in monochrome OLED screen is too low resolution to visualize this, but Wizkers is able to create great graphs, as shown below: On the right side of the screen, you can adjust the sampling rate of the backpack, from 150ms to several seconds per sample. You can also set the alarm level (current above which the blue LED switches on), and manually switch screens on the backpack. Firmware Upgrade One exciting feature of this instrument, is that you can upgrade the OLED backpack firmware directly from Wizkers: go to \"Settings\", and click on \"Firmware Upgrade\", the rest should be fairly self-explanatory. You can either pick a pre-compiled firmware package (\"Hex\" file), or click on \"Download\" to automatically fetch the latest firmware from Fried Circuits. Once the firmware is ready and checked by Wizkers, the \"Download\" button will turn green and you can upgrade the backpack\u2019s firmware, which takes about 10 seconds\u2026","title":"Fried Circuits OLED backpack"},{"location":"ins/fcoled/#fried-circuits-oled-backpack","text":"This plugin really unlocks the potential of this great instrument: the OLED backpack actually contains pretty sophisticated code that monitors current/voltage fluctuations within each sampling period. The build-in monochrome OLED screen is too low resolution to visualize this, but Wizkers is able to create great graphs, as shown below: On the right side of the screen, you can adjust the sampling rate of the backpack, from 150ms to several seconds per sample. You can also set the alarm level (current above which the blue LED switches on), and manually switch screens on the backpack.","title":"Fried Circuits OLED Backpack"},{"location":"ins/fcoled/#firmware-upgrade","text":"One exciting feature of this instrument, is that you can upgrade the OLED backpack firmware directly from Wizkers: go to \"Settings\", and click on \"Firmware Upgrade\", the rest should be fairly self-explanatory. You can either pick a pre-compiled firmware package (\"Hex\" file), or click on \"Download\" to automatically fetch the latest firmware from Fried Circuits. Once the firmware is ready and checked by Wizkers, the \"Download\" button will turn green and you can upgrade the backpack\u2019s firmware, which takes about 10 seconds\u2026","title":"Firmware Upgrade"},{"location":"ins/fluke289/","text":"Fluke 287/289 Multimeters The Fluke 287/289 instrument provides real time visualization and data logging when connected to those multimeters. It also enables complete remote control through the \"Instrument Settings\" screen, with remote display of the screen and control of all the buttons of the multimeter. The plugin also support downloading data from the instrument memory, visualize and export it.","title":"Fluke 287/289 DMMs"},{"location":"ins/fluke289/#fluke-287289-multimeters","text":"The Fluke 287/289 instrument provides real time visualization and data logging when connected to those multimeters. It also enables complete remote control through the \"Instrument Settings\" screen, with remote display of the screen and control of all the buttons of the multimeter. The plugin also support downloading data from the instrument memory, visualize and export it.","title":"Fluke 287/289 Multimeters"},{"location":"ins/gammarae/","text":"RAE Systems / Honeywell GammaRAE II R The GammaRAE II R is a High-performance personal gamma radiation detector and full-range dosimeter from RAE systems. This device includes a Bluetooth interface which enables communication for downloading the current dose and receive a variety of information. Note that there is apparently no way of getting live readings over Bluetooth. The interface is over classic bluetooth, not Bluetooth low energy. Support status The GammaRAE II is supported on any system that supports Bluetooth, including Android. On Windows or MacOS, the GammaRAE appears as a standard serial port over bluetooth. Note that it seems that due to firmware limitations on the GammaRAE, the unit requires getting paired again at each new connection (pairing code is 1234) Wizkers.io app Support Framework level Not available on open source version. Contact wizkers.io for details. Wizkers:Nuclear Android, Server, tested on MacOS Supported capabilities Currently (Mid 2017) only a couple of capabilities are supported on the GammaRAE: Operational status Running parameters (date, background calibration date, etc) Current dose There is no support for downloading device logs so far Main screen","title":"RAE Systems GammaRAE II R"},{"location":"ins/gammarae/#rae-systems-honeywell-gammarae-ii-r","text":"The GammaRAE II R is a High-performance personal gamma radiation detector and full-range dosimeter from RAE systems. This device includes a Bluetooth interface which enables communication for downloading the current dose and receive a variety of information. Note that there is apparently no way of getting live readings over Bluetooth. The interface is over classic bluetooth, not Bluetooth low energy.","title":"RAE Systems / Honeywell GammaRAE II R"},{"location":"ins/gammarae/#support-status","text":"The GammaRAE II is supported on any system that supports Bluetooth, including Android. On Windows or MacOS, the GammaRAE appears as a standard serial port over bluetooth. Note that it seems that due to firmware limitations on the GammaRAE, the unit requires getting paired again at each new connection (pairing code is 1234) Wizkers.io app Support Framework level Not available on open source version. Contact wizkers.io for details. Wizkers:Nuclear Android, Server, tested on MacOS","title":"Support status"},{"location":"ins/gammarae/#supported-capabilities","text":"Currently (Mid 2017) only a couple of capabilities are supported on the GammaRAE: Operational status Running parameters (date, background calibration date, etc) Current dose There is no support for downloading device logs so far","title":"Supported capabilities"},{"location":"ins/gammarae/#main-screen","text":"","title":"Main screen"},{"location":"ins/inspector-ble/","text":"Medcom Inspector BLE The Medcom Inspector BLE is an upgraded version of the famous Medcom Inspector which is one of the best high sensitivity radiation monitors out there. The Inspector BLE was developed in partnership with Wizkers, and uses IMI Gateway as its mobile phone app for data logging and surveying. Support status The Inspector BLE is fully supported on Wizkers apps for all platforms where Wizkers supports Bluetooth Low Energy. Wizkers.io app Supported Notes Framework level Yes Android, iOS, Server IMI Gateway Yes All IMI Gateway platforms Wizkers:Nuclear Yes All Wizkers:Nuclear platforms Features The Inspector BLE instrument on Wizkers supports real time display of CPM, conversion to \u00b5Sv/h , recording and real time mapping.","title":"Medcom Inspector BLE"},{"location":"ins/inspector-ble/#medcom-inspector-ble","text":"The Medcom Inspector BLE is an upgraded version of the famous Medcom Inspector which is one of the best high sensitivity radiation monitors out there. The Inspector BLE was developed in partnership with Wizkers, and uses IMI Gateway as its mobile phone app for data logging and surveying.","title":"Medcom Inspector BLE"},{"location":"ins/inspector-ble/#support-status","text":"The Inspector BLE is fully supported on Wizkers apps for all platforms where Wizkers supports Bluetooth Low Energy. Wizkers.io app Supported Notes Framework level Yes Android, iOS, Server IMI Gateway Yes All IMI Gateway platforms Wizkers:Nuclear Yes All Wizkers:Nuclear platforms","title":"Support status"},{"location":"ins/inspector-ble/#features","text":"The Inspector BLE instrument on Wizkers supports real time display of CPM, conversion to \u00b5Sv/h , recording and real time mapping.","title":"Features"},{"location":"ins/kestrel5/","text":"Kestrel 5 series Kestrel 5 series are professional portable weather stations that monitor temperature, humidity, pressure as well as wind force and direction. The 5 series communicate over Bluetooth low energy and are supported on Wizkers.io Device setup Simply select \"Kestrel 5 series\" in the device type selection in the instrument setup screen, and pick the unit that is detected in the dropdown. Note that your Kestrel unit needs to be powered on, and bluetooth enabled.","title":"Kestrel 5 series"},{"location":"ins/kestrel5/#kestrel-5-series","text":"Kestrel 5 series are professional portable weather stations that monitor temperature, humidity, pressure as well as wind force and direction. The 5 series communicate over Bluetooth low energy and are supported on Wizkers.io","title":"Kestrel 5 series"},{"location":"ins/kestrel5/#device-setup","text":"Simply select \"Kestrel 5 series\" in the device type selection in the instrument setup screen, and pick the unit that is detected in the dropdown. Note that your Kestrel unit needs to be powered on, and bluetooth enabled.","title":"Device setup"},{"location":"ins/medcom-geigerlink/","text":"Medcom GeigerLink The GeigerLink is one of the newest additions to the Medcom family. Geigerlink interfaces with all the geiger counters produced by Medcom and any third party geiger counter equipped with a pulse output connection. GeigerLink is fully supported by Wizkers, and turns any Geiger counter into a powerful graphical logger. Support status The GeigerLink requires USB support on the target platform Wizkers.io app Support Framework level All platforms IMI Gateway All platforms Wizkers:Nuclear All platforms Wizkers support On Wizkers, you can not only plot and record readings coming from the geiger counter through the GeigerLink, but also configure all its settings. Android version The Android version offers all the same features as the Chrome or server version of Wizkers, and also adds geolocation support through the GPS of the Android device:","title":"Medcom GeigerLink"},{"location":"ins/medcom-geigerlink/#medcom-geigerlink","text":"The GeigerLink is one of the newest additions to the Medcom family. Geigerlink interfaces with all the geiger counters produced by Medcom and any third party geiger counter equipped with a pulse output connection. GeigerLink is fully supported by Wizkers, and turns any Geiger counter into a powerful graphical logger.","title":"Medcom GeigerLink"},{"location":"ins/medcom-geigerlink/#support-status","text":"The GeigerLink requires USB support on the target platform Wizkers.io app Support Framework level All platforms IMI Gateway All platforms Wizkers:Nuclear All platforms","title":"Support status"},{"location":"ins/medcom-geigerlink/#wizkers-support","text":"On Wizkers, you can not only plot and record readings coming from the geiger counter through the GeigerLink, but also configure all its settings.","title":"Wizkers support"},{"location":"ins/medcom-geigerlink/#android-version","text":"The Android version offers all the same features as the Chrome or server version of Wizkers, and also adds geolocation support through the GPS of the Android device:","title":"Android version"},{"location":"ins/medcom-onyx-ble/","text":"Medcom Blue Onyx The Blue Onyx is an exciting upcoming device from Medcom. Wizkers already support the beta devices that were issued to field testers. Since the Blue Onyx is a Bluetooth LE device, support is limited to BLE-enabled hardware. Support status The Blue Onyx requires Bluetooth LE support on the target platform Wizkers.io app Supported Notes Framework level Yes Android, Server IMI Gateway Yes Android Wizkers:Nuclear Yes Android, Server Safecast:Drive Yes Android","title":"Medcom Blue Onyx"},{"location":"ins/medcom-onyx-ble/#medcom-blue-onyx","text":"The Blue Onyx is an exciting upcoming device from Medcom. Wizkers already support the beta devices that were issued to field testers. Since the Blue Onyx is a Bluetooth LE device, support is limited to BLE-enabled hardware.","title":"Medcom Blue Onyx"},{"location":"ins/medcom-onyx-ble/#support-status","text":"The Blue Onyx requires Bluetooth LE support on the target platform Wizkers.io app Supported Notes Framework level Yes Android, Server IMI Gateway Yes Android Wizkers:Nuclear Yes Android, Server Safecast:Drive Yes Android","title":"Support status"},{"location":"ins/medcom-onyx/","text":"Medcom Onyx The Onyx is a state of the art Geiger counter, based on an Open Source design by Bunnie Huang . What puts it apart from other open source Geiger counter designs, is that the Onyx is built, calibrated and supported by International Medcom , one of the most respected names in the nuclear detection industry. Wizkers is the official utility for the Medcom Onxy and is guaranteed to support all its capabilities. Wizkers displays the current and historical radiation graph on the main screen, can record the output of the Onyx at any rate, and regularly upload radioactivity values to backend services, including Safecast. Wizkers also support configuring the Onyx, remote calibrations as well as device log data downloads. Last, it also lets you update the firmware of the Onyx. Support status The Onyx is supported on all existing target platforms as long as they support USB. This includes USB OTG for Android devices Wizkers.io app Supported Notes Framework level Yes All platforms Wizkers:Nuclear Yes All platforms Safecast:Drive Yes All platforms The main screen The main screen of Wizkers when connected to an Onyx is similar to what you will see with most other supported Geiger Counters: The main graph displays instant CPM readings (in orange) as well as a rolling 10 minute average (in dark brown). The side display shows the current CPM and \u00b5Sv/h readings, as well as a \"valid/invalid\" pill which reflects the status of the Onyx. Device Setup Since Wizkers provides official support to Medcom for the Onyx, nearly all the capabilities of this device are supported in the Device Setup screen Log downloads The Onyx can store 3000+ recordings in its flash memory. You can download the logs from the \"logs and recordings\" screen. Wizkers supports all Onyx log formats, including single datapoint logs, and min/max logs. Log display The \"Logs and recordings\" screen lets you visualize both Wizkers recordings and downloaded device logs. Depending on the logging mode on the Onyx, logs will be displayed either as a single recording, or as minimum/maximum limits and recording, as shown below: You can also save any log in CSV format by clicking on the \"Download as CSV\" button. Firmware upgrades Note: firmware upgrades have been tested on Wizkers running on Chromebooks, MacOS, as well as Windows on all version from XP to Windows 10. Starting with Onyx firmware 12.26-b, it is now possible to upgrade the firmware of the Onyx directly from Wizkers. Important: if your Onyx firmware version is lower than 12.26-b, you will need to do one final manual upgrade to get it up to date, by following the \"Recovering from a failed upgrade\" procedure described just below. If your firmware is 12.26-b or more recent, simply head over to the \"Settings\" screen, then click on \"Upgrade Firmware\", as shown below: Wizkers will first verify that the existing Onyx firmware can be upgraded, then, if successful, will let you either manually select a firmware file on your hard drive, or download the latest version of the Onyx firmware directly from the Wizkers firmware service. You can then press \u201cUpgrade Firmware\u201d (it should turn green once Wizkers is happy with the firmware file or download). Do not switch screens once the firmware upgrade starts, it will crash the upgrade process and the Onyx will be temporarily \u2018bricked\u2019. Which brings us to the next section: recovering from a failed firmware upgrade. Recovering from a failed upgrade If for any reason, the firmware upgrade process is not successful, the Onyx screen will remain blank and the unit will not react to its power/standby switch anymore. Fear not, though, you can recover from this fairly easily. Depending on the operating system you are using, the procedure will be slightly different. Please note that at the moment, it is not possible to recover from a failed upgrade from a Chromebook, you will need a Mac, Linux or a Windows computer. Recovering on MacOS X In order to recover from a failed upgrade, you will need access to the two files below: Onyx firmware loader (MacOS) Onyx firmware You then need to uncompress the Onyx firmware loader in your home directory. Also put the firmware file in the same location. The rest takes place on a terminal: launch the \u201cTerminal\u201d application and follow the procedure below: Unload the FTDI drivers from the MacOS kernel: sudo kextunload -b com.apple.driver.AppleUSBFTDI This command works on MacOS Yosemite and later. If you are running an older version of MacOS, please replace com.apple.driver.AppleUSBFTDI with \u201ccom.FTDI.driver.FTDIUSBSerialDriver\u201d. You might get an error at this stage, but this is nothing to worry about, the driver is unloaded anyway. Do the firmware recovery (please use the correct name for the firmware file, 12.26-c is used here as an example) chmod a+x fwload ./fwload -f firmware-12.26-c.bin Recovery takes about two minutes, you will see a progress indicator move slowly. If the utility complains it cannot find the Onyx, please unplug it, wait a couple of seconds, then replug it and retry the last step (./fwload -f firmware-12.26-c.bin) You should now be up and running again. Reload the MacOS FTDI drivers so that the Onyx serial port is available again: sudo kextload -b com.apple.driver.AppleUSBFTDI Again, this is for Yosemite and later, use \u201ccom.FTDI.driver.FTDIUSBSerialDriver\u201d for earlier MacOS versions. Recovering on Windows Recovery on Windows is done with a different utility, and the same firmware file: firmware 12.26-c and the OnyxLink utility are bundled in the ZIP file below: OnyxLink Once you have downloaded OnyxLink.zip, extract it to your desktop, and run the \u201cOnyxLink\u201d application, to do a firmware upgrade using firmware.12-26-c.bin and get back on your feet . You will then be able to use Wizkers to upgrade to the latest firmware.","title":"Medcom Onyx"},{"location":"ins/medcom-onyx/#medcom-onyx","text":"The Onyx is a state of the art Geiger counter, based on an Open Source design by Bunnie Huang . What puts it apart from other open source Geiger counter designs, is that the Onyx is built, calibrated and supported by International Medcom , one of the most respected names in the nuclear detection industry. Wizkers is the official utility for the Medcom Onxy and is guaranteed to support all its capabilities. Wizkers displays the current and historical radiation graph on the main screen, can record the output of the Onyx at any rate, and regularly upload radioactivity values to backend services, including Safecast. Wizkers also support configuring the Onyx, remote calibrations as well as device log data downloads. Last, it also lets you update the firmware of the Onyx.","title":"Medcom Onyx"},{"location":"ins/medcom-onyx/#support-status","text":"The Onyx is supported on all existing target platforms as long as they support USB. This includes USB OTG for Android devices Wizkers.io app Supported Notes Framework level Yes All platforms Wizkers:Nuclear Yes All platforms Safecast:Drive Yes All platforms","title":"Support status"},{"location":"ins/medcom-onyx/#the-main-screen","text":"The main screen of Wizkers when connected to an Onyx is similar to what you will see with most other supported Geiger Counters: The main graph displays instant CPM readings (in orange) as well as a rolling 10 minute average (in dark brown). The side display shows the current CPM and \u00b5Sv/h readings, as well as a \"valid/invalid\" pill which reflects the status of the Onyx.","title":"The main screen"},{"location":"ins/medcom-onyx/#device-setup","text":"Since Wizkers provides official support to Medcom for the Onyx, nearly all the capabilities of this device are supported in the Device Setup screen","title":"Device Setup"},{"location":"ins/medcom-onyx/#log-downloads","text":"The Onyx can store 3000+ recordings in its flash memory. You can download the logs from the \"logs and recordings\" screen. Wizkers supports all Onyx log formats, including single datapoint logs, and min/max logs.","title":"Log downloads"},{"location":"ins/medcom-onyx/#log-display","text":"The \"Logs and recordings\" screen lets you visualize both Wizkers recordings and downloaded device logs. Depending on the logging mode on the Onyx, logs will be displayed either as a single recording, or as minimum/maximum limits and recording, as shown below: You can also save any log in CSV format by clicking on the \"Download as CSV\" button.","title":"Log display"},{"location":"ins/medcom-onyx/#firmware-upgrades","text":"Note: firmware upgrades have been tested on Wizkers running on Chromebooks, MacOS, as well as Windows on all version from XP to Windows 10. Starting with Onyx firmware 12.26-b, it is now possible to upgrade the firmware of the Onyx directly from Wizkers. Important: if your Onyx firmware version is lower than 12.26-b, you will need to do one final manual upgrade to get it up to date, by following the \"Recovering from a failed upgrade\" procedure described just below. If your firmware is 12.26-b or more recent, simply head over to the \"Settings\" screen, then click on \"Upgrade Firmware\", as shown below: Wizkers will first verify that the existing Onyx firmware can be upgraded, then, if successful, will let you either manually select a firmware file on your hard drive, or download the latest version of the Onyx firmware directly from the Wizkers firmware service. You can then press \u201cUpgrade Firmware\u201d (it should turn green once Wizkers is happy with the firmware file or download). Do not switch screens once the firmware upgrade starts, it will crash the upgrade process and the Onyx will be temporarily \u2018bricked\u2019. Which brings us to the next section: recovering from a failed firmware upgrade.","title":"Firmware upgrades"},{"location":"ins/medcom-onyx/#recovering-from-a-failed-upgrade","text":"If for any reason, the firmware upgrade process is not successful, the Onyx screen will remain blank and the unit will not react to its power/standby switch anymore. Fear not, though, you can recover from this fairly easily. Depending on the operating system you are using, the procedure will be slightly different. Please note that at the moment, it is not possible to recover from a failed upgrade from a Chromebook, you will need a Mac, Linux or a Windows computer.","title":"Recovering from a failed upgrade"},{"location":"ins/medcom-onyx/#recovering-on-macos-x","text":"In order to recover from a failed upgrade, you will need access to the two files below: Onyx firmware loader (MacOS) Onyx firmware You then need to uncompress the Onyx firmware loader in your home directory. Also put the firmware file in the same location. The rest takes place on a terminal: launch the \u201cTerminal\u201d application and follow the procedure below: Unload the FTDI drivers from the MacOS kernel: sudo kextunload -b com.apple.driver.AppleUSBFTDI This command works on MacOS Yosemite and later. If you are running an older version of MacOS, please replace com.apple.driver.AppleUSBFTDI with \u201ccom.FTDI.driver.FTDIUSBSerialDriver\u201d. You might get an error at this stage, but this is nothing to worry about, the driver is unloaded anyway. Do the firmware recovery (please use the correct name for the firmware file, 12.26-c is used here as an example) chmod a+x fwload ./fwload -f firmware-12.26-c.bin Recovery takes about two minutes, you will see a progress indicator move slowly. If the utility complains it cannot find the Onyx, please unplug it, wait a couple of seconds, then replug it and retry the last step (./fwload -f firmware-12.26-c.bin) You should now be up and running again. Reload the MacOS FTDI drivers so that the Onyx serial port is available again: sudo kextload -b com.apple.driver.AppleUSBFTDI Again, this is for Yosemite and later, use \u201ccom.FTDI.driver.FTDIUSBSerialDriver\u201d for earlier MacOS versions.","title":"Recovering on MacOS X"},{"location":"ins/medcom-onyx/#recovering-on-windows","text":"Recovery on Windows is done with a different utility, and the same firmware file: firmware 12.26-c and the OnyxLink utility are bundled in the ZIP file below: OnyxLink Once you have downloaded OnyxLink.zip, extract it to your desktop, and run the \u201cOnyxLink\u201d application, to do a firmware upgrade using firmware.12-26-c.bin and get back on your feet . You will then be able to use Wizkers to upgrade to the latest firmware.","title":"Recovering on Windows"},{"location":"ins/sark110/","text":"Sark 110 The Sark110 is a powerful graphical antenna analyzer. Wizkers provides basic support for it at this stage. Support status The Sark 110 is fully supported on Wizkers:Radio for all its current distribution platforms. At the framework level, it works on Android and NWJS. Wizkers.io app Supported Notes Framework level Yes Android, NWJS Wizkers:Radio Yes All platforms","title":"Sark 110"},{"location":"ins/sark110/#sark-110","text":"The Sark110 is a powerful graphical antenna analyzer. Wizkers provides basic support for it at this stage.","title":"Sark 110"},{"location":"ins/sark110/#support-status","text":"The Sark 110 is fully supported on Wizkers:Radio for all its current distribution platforms. At the framework level, it works on Android and NWJS. Wizkers.io app Supported Notes Framework level Yes Android, NWJS Wizkers:Radio Yes All platforms","title":"Support status"},{"location":"ins/simple-serial/","text":"Simple serial terminal Sometimes, you just want to hook up a serial device to your computer and check if it works: this is exactly what the simple serial terminal is for. Terminal settings So far, the simple serial terminal does not support many settings, only a switch between \"raw\" mode and \"Hexadecimal\" which will output the data as a Hex dump.","title":"Simple serial terminal"},{"location":"ins/simple-serial/#simple-serial-terminal","text":"Sometimes, you just want to hook up a serial device to your computer and check if it works: this is exactly what the simple serial terminal is for.","title":"Simple serial terminal"},{"location":"ins/simple-serial/#terminal-settings","text":"So far, the simple serial terminal does not support many settings, only a switch between \"raw\" mode and \"Hexadecimal\" which will output the data as a Hex dump.","title":"Terminal settings"},{"location":"out/rest/","text":"REST Output The REST output is deceptively simple: you can use it to talk to a very large number of REST endpoints, with very little configuration. Number of Fields: input the number of data elements that will be used to build the \u201cServer URL\u201d below. Server URL: using the simple \u201ctag\u201d syntax explained below this field, you can design the structure of the URL that will be called or posted to. Do a GET or POST: as it says, you can select whether to GET or POST to the URL above. Notes on development As it stands today, this plugin is already very useful. Future development of Wizkers might include additional predefined tags such as current time, GPS location and others, that can be combined with instrument outputs to build more complex calls. Contributions are welcome!","title":"REST API"},{"location":"out/rest/#rest-output","text":"The REST output is deceptively simple: you can use it to talk to a very large number of REST endpoints, with very little configuration. Number of Fields: input the number of data elements that will be used to build the \u201cServer URL\u201d below. Server URL: using the simple \u201ctag\u201d syntax explained below this field, you can design the structure of the URL that will be called or posted to. Do a GET or POST: as it says, you can select whether to GET or POST to the URL above.","title":"REST Output"},{"location":"out/rest/#notes-on-development","text":"As it stands today, this plugin is already very useful. Future development of Wizkers might include additional predefined tags such as current time, GPS location and others, that can be combined with instrument outputs to build more complex calls. Contributions are welcome!","title":"Notes on development"},{"location":"out/rigctld/","text":"RigCTLd Output This output is available for HAM radio transceivers. It emulates a Hamlib \"Rigctld\" daemon, so that programs like fldigi can control the KX3 through Wizkers.","title":"rigctld"},{"location":"out/rigctld/#rigctld-output","text":"This output is available for HAM radio transceivers. It emulates a Hamlib \"Rigctld\" daemon, so that programs like fldigi can control the KX3 through Wizkers.","title":"RigCTLd Output"},{"location":"out/safecast/","text":"Safecast output The Safecast output is ony available for instrument which are sending radioactivity readings. It lets you forward the readings to the Safecast.org API.","title":"Safecast"},{"location":"out/safecast/#safecast-output","text":"The Safecast output is ony available for instrument which are sending radioactivity readings. It lets you forward the readings to the Safecast.org API.","title":"Safecast output"},{"location":"out/text/","text":"Text output The text output plugin is simple but very effective: it will regularly create - or append to - a file with the data fields of your choice. This makes it possible to either create flat log files for later analysis, or more interestingly, interact with external processes which will read those files and process the data in real time. Configuration The text output works with a simple tag style template which lets you create lines containing the fields of your choice. You can setup the location of the output file, as well as whether Wizkers should append to the file or overwrite it at each plugin trigger. The example above shows how Wizkers can be setup to simply write an instrument value (radioactivity in this case) so that an external program can use it (direwolf in this case, for broadcasting this value as a telemetry packet over the Amateur Radio band).","title":"Text"},{"location":"out/text/#text-output","text":"The text output plugin is simple but very effective: it will regularly create - or append to - a file with the data fields of your choice. This makes it possible to either create flat log files for later analysis, or more interestingly, interact with external processes which will read those files and process the data in real time.","title":"Text output"},{"location":"out/text/#configuration","text":"The text output works with a simple tag style template which lets you create lines containing the fields of your choice. You can setup the location of the output file, as well as whether Wizkers should append to the file or overwrite it at each plugin trigger. The example above shows how Wizkers can be setup to simply write an instrument value (radioactivity in this case) so that an external program can use it (direwolf in this case, for broadcasting this value as a telemetry packet over the Amateur Radio band).","title":"Configuration"},{"location":"out/webrtc/","text":"WebRTC Output This output plugin forwards all the data coming from the instrument over a WebRTC data channel. If can also send bidirectional audio to a remote end. The data channel is also bidirectional. You can use this plugin in two different ways: display instrument data and do remote control from remote web pages, or connect to an instrument from Wizkers running on a remote computer. Think of it as \"Wizkers to Wizkers\" communication. As of 0.9.19, you can use this Output for the Elecraft KX3 for remote operations: configure a \u201cElecraft KX3 Radio\u201d instrument on a local Wizkers instance, then add the WebRTC output. Then, on another computer, create a \u201cRemote KX3\u201d instrument, which will let you connect to your KX3 remotely, including full duplex audio. Audio settings If enabled, the WebRTC output will forward local audio to any peer connected to it, and will receive remote audio. Self-hosted vs PeerJS The WebRTC is now working fine. But in order to establish communication between two peers, a broker service is required: we are using PeerJS to do this. The PeerJS seems to be a bit dormant at the moment and its broker service does not work. But PeerJS also provides everything you need to run your own broker service, and this is currently the recommended way of working with the WebRTC output. Follow instructions on Github to run PeerServer on a local machine on your network. Once your PeerServer is running, configure the WebRTC output as \"Self-hosted\" in the connection method, and put the IP:Port of the peer server in the \"Server IP:Port\" field. Interfacing a web page with the WebRTC Output The WebRTC output uses the PeerJS library to implement a simple wrapper around WebRTC. This makes it easy to display instrument data on a remote web page. TODO: create a detailed guide on how to implement an example web page once all the code is on github. Future evolutions of the WebRTC output We are currently investigating running a Wizkers.io PeerServer for Wizkers users, which will make it a lot easier to use the output (no manual installation of PeerServer required). But self-hosting will always be supported anyway.","title":"WebRTC"},{"location":"out/webrtc/#webrtc-output","text":"This output plugin forwards all the data coming from the instrument over a WebRTC data channel. If can also send bidirectional audio to a remote end. The data channel is also bidirectional. You can use this plugin in two different ways: display instrument data and do remote control from remote web pages, or connect to an instrument from Wizkers running on a remote computer. Think of it as \"Wizkers to Wizkers\" communication. As of 0.9.19, you can use this Output for the Elecraft KX3 for remote operations: configure a \u201cElecraft KX3 Radio\u201d instrument on a local Wizkers instance, then add the WebRTC output. Then, on another computer, create a \u201cRemote KX3\u201d instrument, which will let you connect to your KX3 remotely, including full duplex audio.","title":"WebRTC Output"},{"location":"out/webrtc/#audio-settings","text":"If enabled, the WebRTC output will forward local audio to any peer connected to it, and will receive remote audio.","title":"Audio settings"},{"location":"out/webrtc/#self-hosted-vs-peerjs","text":"The WebRTC is now working fine. But in order to establish communication between two peers, a broker service is required: we are using PeerJS to do this. The PeerJS seems to be a bit dormant at the moment and its broker service does not work. But PeerJS also provides everything you need to run your own broker service, and this is currently the recommended way of working with the WebRTC output. Follow instructions on Github to run PeerServer on a local machine on your network. Once your PeerServer is running, configure the WebRTC output as \"Self-hosted\" in the connection method, and put the IP:Port of the peer server in the \"Server IP:Port\" field.","title":"Self-hosted vs PeerJS"},{"location":"out/webrtc/#interfacing-a-web-page-with-the-webrtc-output","text":"The WebRTC output uses the PeerJS library to implement a simple wrapper around WebRTC. This makes it easy to display instrument data on a remote web page. TODO: create a detailed guide on how to implement an example web page once all the code is on github.","title":"Interfacing a web page with the WebRTC Output"},{"location":"out/webrtc/#future-evolutions-of-the-webrtc-output","text":"We are currently investigating running a Wizkers.io PeerServer for Wizkers users, which will make it a lot easier to use the output (no manual installation of PeerServer required). But self-hosting will always be supported anyway.","title":"Future evolutions of the WebRTC output"},{"location":"out/xmlrpc/","text":"XML-RPC Output This output is available for HAM radio transceivers only. It is a fairly complete implementation of the XML-RPC server that fldigi expects for rig control. While you can use the rigctld output with fldigi as well, the XML-RPC implementation is much more robust, faster and flexible. In essence, this lets Wizkers emulate the 'flrig' program, so any software that is compatible with flrig will be able to work with Wizkers. There are no specific settings for the XML-RPC output, just create it, then enable it in the \"Outputs\" screen, fldigi will automatically connect to Wizkers as soon as it starts.","title":"XML-RPC"},{"location":"out/xmlrpc/#xml-rpc-output","text":"This output is available for HAM radio transceivers only. It is a fairly complete implementation of the XML-RPC server that fldigi expects for rig control. While you can use the rigctld output with fldigi as well, the XML-RPC implementation is much more robust, faster and flexible. In essence, this lets Wizkers emulate the 'flrig' program, so any software that is compatible with flrig will be able to work with Wizkers. There are no specific settings for the XML-RPC output, just create it, then enable it in the \"Outputs\" screen, fldigi will automatically connect to Wizkers as soon as it starts.","title":"XML-RPC Output"}]}